module ParserSemicolonTest

from "../submodules/graintest/lib/test.gr" include Test
use Test.*

from "list" include List
from "../src/core/surface_ast.gr" include SurfaceAst
use SurfaceAst.*
from "../src/core/error.gr" include Error
use Error.{ clearErrors, getMarkedErrors }
from "../src/frontend/parser.gr" include Parser

setSourceFile("./tests/parser_semicolon_test.gr")

test("parser semicolon mark smoke", () => {
  let source = "let a = 1\nlet b = 2;"
  let _ = Parser.parseResult(source)

  let blockSource = "let x = { let y = 1 y };"
  let _ = Parser.parseResult(blockSource)

  let exprStmtSource = "let x = { 1 let y = 2; y };"
  let _ = Parser.parseResult(exprStmtSource)

  let _ = Parser.parseResult("let a;")
  let _ = Parser.parseResult("let x = { y = ; y };")
  let _ = Parser.parseResult("let x = (1 + 2;")
  let _ = Parser.parseResult("let x = { let y = 1;")
  let _ = Parser.parseResult("oops ; let ok = 1;")

  clearErrors()
  let _ = Parser.parseResult("let main = => {}")
  let marked = getMarkedErrors()
  let hasMissingTopLevelSemi = List.some(
    (entry: Error.MarkedError) => match (entry) {
      { mark, _ } => match (mark.kind) {
        SurfaceAst.MissingSemicolon => true,
        _ => false,
      },
    },
    marked
  )
  assertTrue(hasMissingTopLevelSemi)
})

test("parser folds block body into let", () => {
  let foldedSource = "let x = { let y = 1; y };"
  let foldedProgram = Parser.parse(foldedSource)
  let foldedOk = match (foldedProgram.items) {
    [SurfaceAst.DeclGroup(dg)] => match (dg.decls) {
      [SurfaceAst.LetDecl(ld)] => match (ld.bindings) {
        [binding] => match (binding.value.kind) {
          SurfaceAst.Block(block) => match (block.body.kind) {
            SurfaceAst.Let(letBinding, letBody) =>
              match ((letBinding.value.kind, letBody.kind)) {
                (
                  SurfaceAst.Lit(SurfaceAst.Int(1)),
                  SurfaceAst.Ident({ text, _ }),
                ) when text == "y" => true,
                _ => false,
              },
            _ => false,
          },
          _ => false,
        },
        _ => false,
      },
      _ => false,
    },
    _ => false,
  }
  assertTrue(foldedOk)
})

test("parser treats top-level semicolon as sequencing in let RHS", () => {
  let seqSource = "let x = (1; 2);"
  let seqProgram = Parser.parse(seqSource)
  let seqOk = match (seqProgram.items) {
    [SurfaceAst.DeclGroup(dg)] => match (dg.decls) {
      [SurfaceAst.LetDecl(ld)] => match (ld.bindings) {
        [binding] => match (binding.value.kind) {
          SurfaceAst.Seq(items) => match (items) {
            [
              { kind: SurfaceAst.Lit(SurfaceAst.Int(1)), _ },
              { kind: SurfaceAst.Lit(SurfaceAst.Int(2)), _ },
            ] => true,
            _ => false,
          },
          _ => false,
        },
        _ => false,
      },
      _ => false,
    },
    _ => false,
  }
  assertTrue(seqOk)
})

test("parser supports generic record declarations and type arguments", () => {
  clearErrors()
  let source = "record Helper<T> = { trues: List<T>, falses: List<T> };"
  let parsed = Parser.parse(source)

  let shapeOk = match (parsed.items) {
    [SurfaceAst.DeclGroup(group)] => match (group.decls) {
      [SurfaceAst.RecordDecl(recordDecl)] => {
        let hasOneTypeParam = List.length(recordDecl.typeParams) == 1
        let fieldTypesLookGeneric = List.reduce(
          (acc: Bool, entry: (SurfaceAst.Name, SurfaceAst.TypeExpr)) =>
            acc && match (entry) {
              (_, ty) => match (ty.kind) {
                SurfaceAst.Ref(_, [arg]) => match (arg.kind) {
                  SurfaceAst.Ref(_, []) => true,
                  _ => false,
                },
                _ => false,
              },
            },
          true,
          recordDecl.fields
        )
        hasOneTypeParam && fieldTypesLookGeneric
      },
      _ => false,
    },
    _ => false,
  }

  let hasErrors = List.length(getMarkedErrors()) > 0
  all([assertTrue(shapeOk), assertFalse(hasErrors)])
})

test("parser supports if condition with equality comparison", () => {
  clearErrors()
  let source = "let f = (count) => { if (count == 3) { count } else { 0 } };"
  let _ = Parser.parseResult(source)
  let hasErrors = List.length(getMarkedErrors()) > 0
  assertFalse(hasErrors)
})

test(
  "parser supports multiline functional call arguments with multiplication",
  () => {
    clearErrors()
    let source = "let x = makeStep(\n"
      ++ "  leftStep.value * rightStep.value,\n"
      ++ "  expectCharAt(chars, rightStep.next, charCloseParen, ExpectedCloseParen)\n"
      ++ ");"
    let _ = Parser.parseResult(source)
    let hasErrors = List.length(getMarkedErrors()) > 0
    assertFalse(hasErrors)
  }
)

test("parser supports exported generic variant type aliases", () => {
  clearErrors()
  let source = "export type Option<T> = Some<T> | None;"
  let parsed = Parser.parse(source)
  let isGenericParamType = (ty: SurfaceAst.TypeExpr) => match (ty.kind) {
    SurfaceAst.Var({ text: "T", _ }) => true,
    SurfaceAst.Ref({ text: "T", _ }, []) => true,
    _ => false,
  }

  let shapeOk = match (parsed.items) {
    [SurfaceAst.Export(_), SurfaceAst.DeclGroup(group)] => {
      if (!group.exported) {
        false
      } else {
        match (group.decls) {
          [SurfaceAst.TypeDecl(typeDecl)] => match (typeDecl.body) {
            SurfaceAst.Variant(cases, _) => match (cases) {
              [
                ({ text: "Some", _ }, Some(payload), _),
                ({ text: "None", _ }, None, _),
              ] => isGenericParamType(payload),
              _ => false,
            },
            _ => false,
          },
          _ => false,
        }
      }
    },
    _ => false,
  }

  let hasErrors = List.length(getMarkedErrors()) > 0
  all([assertTrue(shapeOk), assertFalse(hasErrors)])
})

let results = runTests()
printResultsAndExit(results)
