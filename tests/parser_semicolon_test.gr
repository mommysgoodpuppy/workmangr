module ParserSemicolonTest

from "../submodules/graintest/lib/test.gr" include Test
use Test.*

from "list" include List
from "../src/core/surface_ast.gr" include SurfaceAst
use SurfaceAst.*
from "../src/core/error.gr" include Error
use Error.{ clearErrors, getMarkedErrors }
from "../src/frontend/parser.gr" include Parser

setSourceFile("./tests/parser_semicolon_test.gr")

test("parser semicolon mark smoke", () => {
  let source = "let a = 1\nlet b = 2;"
  let _ = Parser.parseResult(source)

  let blockSource = "let x = { let y = 1 y };"
  let _ = Parser.parseResult(blockSource)

  let exprStmtSource = "let x = { 1 let y = 2; y };"
  let _ = Parser.parseResult(exprStmtSource)

  let _ = Parser.parseResult("let a;")
  let _ = Parser.parseResult("let x = { y = ; y };")
  let _ = Parser.parseResult("let x = (1 + 2;")
  let _ = Parser.parseResult("let x = { let y = 1;")
  let _ = Parser.parseResult("oops ; let ok = 1;")

  clearErrors()
  let _ = Parser.parseResult("let main = => {}")
  let marked = getMarkedErrors()
  let hasMissingTopLevelSemi = List.some(
    (entry: Error.MarkedError) => match (entry) {
      { mark, _ } => match (mark.kind) {
        SurfaceAst.MissingSemicolon => true,
        _ => false,
      },
    },
    marked,
  )
  assertTrue(
    hasMissingTopLevelSemi,
  )
})

test("parser folds block body into let", () => {
  let foldedSource = "let x = { let y = 1; y };"
  let foldedProgram = Parser.parse(foldedSource)
  let foldedOk = match (foldedProgram.items) {
    [SurfaceAst.DeclGroup(dg)] => match (dg.decls) {
      [SurfaceAst.LetDecl(ld)] => match (ld.bindings) {
        [binding] => match (binding.value.kind) {
          SurfaceAst.Block(block) => match (block.body.kind) {
            SurfaceAst.Let(letBinding, letBody) =>
              match ((letBinding.value.kind, letBody.kind)) {
                (SurfaceAst.Lit(SurfaceAst.Int(1)), SurfaceAst.Ident({ _, text })) when text == "y" => true,
                _ => false,
              },
            _ => false,
          },
          _ => false,
        },
        _ => false,
      },
      _ => false,
    },
    _ => false,
  }
  assertTrue(foldedOk)
})

test("parser treats top-level semicolon as sequencing in let RHS", () => {
  let seqSource = "let x = (1; 2);"
  let seqProgram = Parser.parse(seqSource)
  let seqOk = match (seqProgram.items) {
    [SurfaceAst.DeclGroup(dg)] => match (dg.decls) {
      [SurfaceAst.LetDecl(ld)] => match (ld.bindings) {
        [binding] => match (binding.value.kind) {
          SurfaceAst.Seq(items) =>
            match (items) {
              [
                { kind: SurfaceAst.Lit(SurfaceAst.Int(1)), _ },
                { kind: SurfaceAst.Lit(SurfaceAst.Int(2)), _ },
              ] => true,
              _ => false,
            },
          _ => false,
        },
        _ => false,
      },
      _ => false,
    },
    _ => false,
  }
  assertTrue(seqOk)
})

let results = runTests()
printResultsAndExit(results)
