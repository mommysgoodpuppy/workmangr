module ModuleSystemTest

from "../submodules/graintest/lib/test.gr" include Test
use Test.*

from "list" include List
from "map" include Map
from "string" include String

from "../src/core/surface_ast.gr" include SurfaceAst
from "../src/core/error.gr" include Error
from "../src/frontend/parser.gr" include Parser
from "../src/module/module_system.gr" include ModuleSystem

setSourceFile("./tests/module_system_test.gr")

test("parser supports core/import/reexport module syntax", () => {
  let source = "@core;\nfrom \"./dep\" import * as List;\nreexport \"./types\";\nlet x = 1;"
  let parsed = Parser.parse(source)

  let hasCore = parsed.core
  let hasImport = List.some(
    item => match (item) {
      SurfaceAst.Import(importDecl) =>
        importDecl.modulePath == "./dep"
          && match (importDecl.alias) {
            Some(alias) => alias.text == "List",
            None => false,
          },
      _ => false,
    },
    parsed.items
  )
  let hasReexport = List.some(
    item => match (item) {
      SurfaceAst.Reexport(reexportDecl) => reexportDecl.modulePath == "./types",
      _ => false,
    },
    parsed.items
  )

  all([
    assertTrue(hasCore),
    assertTrue(hasImport),
    assertTrue(hasReexport),
  ])
})

test("parser supports export-from type reexport syntax", () => {
  let source =
    "export from \"std/coretypes\" type Ordering(..);\n"
      ++ "export from \"std/coretypes\" type List(..);\n"
      ++ "let x = 1;"
  let parsed = Parser.parse(source)
  let reexports = List.filterMap((item: SurfaceAst.TopItem) =>
    match (item) {
      SurfaceAst.Reexport(reexportDecl) => Some(reexportDecl.modulePath),
      _ => None,
    }, parsed.items)
  assertEquals(["std/coretypes", "std/coretypes"], reexports)
})

test("module graph resolves imports and reexports from overrides", () => {
  let overrides = Map.make()
  Map.set(
    "entry.wm",
    "from \"./a\" import { foo };\nreexport \"./b\";\nlet main = 1;",
    overrides
  )
  Map.set("a.wm", "let foo = 1;", overrides)
  Map.set("b.wm", "let thing = 2;", overrides)

  let graph = ModuleSystem.buildGraph(
    "entry",
    options={ ...ModuleSystem.defaultOptions(), sourceOverrides: overrides }
  )

  let entryNodeOpt = Map.get("entry.wm", graph.nodes)
  let edgesOk = match (entryNodeOpt) {
    Some(node) =>
      node.imports == ["a.wm"] && node.reexports == ["b.wm"],
    None => false,
  }

  all([
    assertTrue(edgesOk),
    assertTrue(List.length(graph.topo) == 3),
  ])
})

test("module graph resolves export-from type reexports from overrides", () => {
  let overrides = Map.make()
  Map.set(
    "entry.wm",
    "export from \"./types\" type List(..);\nlet main = 1;",
    overrides
  )
  Map.set("types.wm", "type List<T> = Empty | Link<T>;", overrides)

  let graph = ModuleSystem.buildGraph(
    "entry",
    options={ ...ModuleSystem.defaultOptions(), sourceOverrides: overrides }
  )

  let entryNodeOpt = Map.get("entry.wm", graph.nodes)
  let edgesOk = match (entryNodeOpt) {
    Some(node) => node.reexports == ["types.wm"],
    None => false,
  }

  all([
    assertTrue(edgesOk),
    assertTrue(List.length(graph.topo) == 2),
  ])
})

test("module graph reports cycle diagnostics", () => {
  let overrides = Map.make()
  Map.set("entry.wm", "from \"./a\" import { x };\nlet main = x;", overrides)
  Map.set("a.wm", "from \"./b\" import { y };\nlet x = y;", overrides)
  Map.set("b.wm", "from \"./a\" import { x };\nlet y = x;", overrides)

  let graph = ModuleSystem.buildGraph(
    "entry",
    options={ ...ModuleSystem.defaultOptions(), sourceOverrides: overrides }
  )

  let aDiags = match (Map.get("a.wm", graph.diagnosticsById)) {
    Some(diags) => diags,
    None => [],
  }
  let hasCycle = List.some(
    (diag: Error.CompilerError) =>
      String.startsWith("Circular module dependency: ", diag.message),
    aDiags
  )

  assertTrue(hasCycle)
})

test("module graph resolves std imports via std roots", () => {
  let overrides = Map.make()
  Map.set(
    "entry.wm",
    "from \"std/list\" import * as List;\nlet main = 1;",
    overrides
  )
  Map.set("stdroot/list.wm", "let map = 1;", overrides)

  let graph = ModuleSystem.buildGraph(
    "entry",
    options={
      ...ModuleSystem.defaultOptions(),
      stdRoots: ["stdroot"],
      sourceOverrides: overrides,
    }
  )

  let entryNodeOpt = Map.get("entry.wm", graph.nodes)
  let resolvesStd = match (entryNodeOpt) {
    Some(node) => List.some(path => path == "stdroot/list.wm", node.imports),
    None => false,
  }

  assertTrue(resolvesStd)
})

test("module graph implicitly imports std/prelude for non-core modules", () => {
  let overrides = Map.make()
  Map.set("entry.wm", "let main = Empty;", overrides)
  Map.set("stdroot/prelude.wm", "let preludeMarker = 1;", overrides)

  let graph = ModuleSystem.buildGraph(
    "entry",
    options={
      ...ModuleSystem.defaultOptions(),
      stdRoots: ["stdroot"],
      sourceOverrides: overrides,
    }
  )

  let entryNodeOpt = Map.get("entry.wm", graph.nodes)
  let hasPreludeDep = match (entryNodeOpt) {
    Some(node) => List.some(path => path == "stdroot/prelude.wm", node.imports),
    None => false,
  }

  assertTrue(hasPreludeDep)
})

test("module graph survives lex errors in dependencies", () => {
  let overrides = Map.make()
  Map.set("entry.wm", "from \"./bad\" import { x };\nlet main = 1;", overrides)
  Map.set("bad.wm", "let x = 'a\nlet y = 2;", overrides)

  let graph = ModuleSystem.buildGraph(
    "entry",
    options={ ...ModuleSystem.defaultOptions(), sourceOverrides: overrides }
  )

  let badDiags = match (Map.get("bad.wm", graph.diagnosticsById)) {
    Some(diags) => diags,
    None => [],
  }
  let hasLexError = List.some(
    (diag: Error.CompilerError) =>
      diag.stage == Error.Lexing
        && String.startsWith("Unclosed character literal", diag.message),
    badDiags
  )

  all([
    assertTrue(Map.get("entry.wm", graph.nodes) != None),
    assertTrue(Map.get("bad.wm", graph.nodes) != None),
    assertTrue(hasLexError),
  ])
})

test("module graph keeps absolute unix paths absolute", () => {
  let overrides = Map.make()
  Map.set(
    "/abs/entry.wm",
    "from \"./dep\" import { x };\nlet main = x;",
    overrides
  )
  Map.set("/abs/dep.wm", "let x = 1;", overrides)

  let graph = ModuleSystem.buildGraph(
    "/abs/entry",
    options={
      ...ModuleSystem.defaultOptions(),
      rootDir: "/abs",
      sourceOverrides: overrides,
    }
  )

  let hasEntry = Map.get("/abs/entry.wm", graph.nodes) != None
  let hasDep = Map.get("/abs/dep.wm", graph.nodes) != None
  let entryImportsDep = match (Map.get("/abs/entry.wm", graph.nodes)) {
    Some(node) => node.imports == ["/abs/dep.wm"],
    None => false,
  }

  all([
    assertTrue(hasEntry),
    assertTrue(hasDep),
    assertTrue(entryImportsDep),
  ])
})

let results = runTests()
printResultsAndExit(results)
