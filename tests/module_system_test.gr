module ModuleSystemTest

from "../submodules/graintest/lib/test.gr" include Test
use Test.*

from "list" include List
from "map" include Map
from "string" include String

from "../src/core/surface_ast.gr" include SurfaceAst
from "../src/core/error.gr" include Error
from "../src/frontend/parser.gr" include Parser
from "../src/module/module_system.gr" include ModuleSystem

setSourceFile("./tests/module_system_test.gr")

test("parser supports core/import/reexport module syntax", () => {
  let source = "@core;\nfrom \"./dep\" import { foo, bar as baz };\nreexport \"./types\";\nlet x = 1;"
  let parsed = Parser.parse(source)

  let hasCore = parsed.core
  let hasImport = List.some(
    item => match (item) {
      SurfaceAst.Import(importDecl) => importDecl.modulePath == "./dep",
      _ => false,
    },
    parsed.items
  )
  let hasReexport = List.some(
    item => match (item) {
      SurfaceAst.Reexport(reexportDecl) => reexportDecl.modulePath == "./types",
      _ => false,
    },
    parsed.items
  )

  all([
    assertTrue(hasCore),
    assertTrue(hasImport),
    assertTrue(hasReexport),
  ])
})

test("module graph resolves imports and reexports from overrides", () => {
  let overrides = Map.make()
  Map.set(
    "entry.wm",
    "from \"./a\" import { foo };\nreexport \"./b\";\nlet main = 1;",
    overrides
  )
  Map.set("a.wm", "let foo = 1;", overrides)
  Map.set("b.wm", "let thing = 2;", overrides)

  let graph = ModuleSystem.buildGraph(
    "entry",
    options={ ...ModuleSystem.defaultOptions(), sourceOverrides: overrides }
  )

  let entryNodeOpt = Map.get("entry.wm", graph.nodes)
  let edgesOk = match (entryNodeOpt) {
    Some(node) =>
      node.imports == ["a.wm"] && node.reexports == ["b.wm"],
    None => false,
  }

  all([
    assertTrue(edgesOk),
    assertTrue(List.length(graph.topo) == 3),
  ])
})

test("module graph reports cycle diagnostics", () => {
  let overrides = Map.make()
  Map.set("entry.wm", "from \"./a\" import { x };\nlet main = x;", overrides)
  Map.set("a.wm", "from \"./b\" import { y };\nlet x = y;", overrides)
  Map.set("b.wm", "from \"./a\" import { x };\nlet y = x;", overrides)

  let graph = ModuleSystem.buildGraph(
    "entry",
    options={ ...ModuleSystem.defaultOptions(), sourceOverrides: overrides }
  )

  let aDiags = match (Map.get("a.wm", graph.diagnosticsById)) {
    Some(diags) => diags,
    None => [],
  }
  let hasCycle = List.some(
    (diag: Error.CompilerError) =>
      String.startsWith("Circular module dependency: ", diag.message),
    aDiags
  )

  assertTrue(hasCycle)
})

test("module graph resolves std imports via std roots", () => {
  let overrides = Map.make()
  Map.set(
    "entry.wm",
    "from \"std/list\" import * as list;\nlet main = 1;",
    overrides
  )
  Map.set("stdroot/list.wm", "let map = 1;", overrides)

  let graph = ModuleSystem.buildGraph(
    "entry",
    options={
      ...ModuleSystem.defaultOptions(),
      stdRoots: ["stdroot"],
      sourceOverrides: overrides,
    }
  )

  let entryNodeOpt = Map.get("entry.wm", graph.nodes)
  let resolvesStd = match (entryNodeOpt) {
    Some(node) => node.imports == ["stdroot/list.wm"],
    None => false,
  }

  assertTrue(resolvesStd)
})

test("module graph survives lex errors in dependencies", () => {
  let overrides = Map.make()
  Map.set("entry.wm", "from \"./bad\" import { x };\nlet main = 1;", overrides)
  Map.set("bad.wm", "let x = 'a\nlet y = 2;", overrides)

  let graph = ModuleSystem.buildGraph(
    "entry",
    options={ ...ModuleSystem.defaultOptions(), sourceOverrides: overrides }
  )

  let badDiags = match (Map.get("bad.wm", graph.diagnosticsById)) {
    Some(diags) => diags,
    None => [],
  }
  let hasLexError = List.some(
    (diag: Error.CompilerError) =>
      diag.stage == Error.Lexing
        && String.startsWith("Unclosed character literal", diag.message),
    badDiags
  )

  all([
    assertTrue(Map.get("entry.wm", graph.nodes) != None),
    assertTrue(Map.get("bad.wm", graph.nodes) != None),
    assertTrue(hasLexError),
  ])
})

let results = runTests()
printResultsAndExit(results)
