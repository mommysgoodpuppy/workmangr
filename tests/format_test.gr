module FormatTest

from "../submodules/graintest/lib/test.gr" include Test
use Test.*

from "../src/util.gr" include Util
from "../src/frontend/formatter.gr" include Formatter
from "../src/core/error.gr" include Error
from "../src/core/surface_ast.gr" include SurfaceAst
from "string" include String
from "list" include List

setSourceFile("./tests/format_test.gr")

let canonicalNonWs = (text: String) => {
  let noSpace = String.replaceAll(" ", "", text)
  let noTab = String.replaceAll("\t", "", noSpace)
  let noLf = String.replaceAll("\n", "", noTab)
  String.replaceAll("\r", "", noLf)
}

test("formatting is stable on a small program", () => {
  let source = "
let x = (y) => { match(y) { y => { 1 } } };
"
  let formatted1 = Formatter.format(source)
  let formatted2 = Formatter.format(formatted1)
  assertEquals(formatted1, formatted2)
})

test("formatting ocaml type", () => {
  let source =
    "
type ParseResult =
  | NotMul
  | ExpectedDigit
  | ExpectedComma
  | ExpectedCloseParen;
"
  Error.clearErrors()
  let formatted = Formatter.formatWithMode(source, Formatter.RealFix)
  let marks = Error.getMarkedErrors()
  assertEquals(canonicalNonWs(source), canonicalNonWs(formatted))
  assertEquals(marks, [])
})

test("formatting ts union", () => {
  let source =
    "
type ParseResult = NotMul
  | ExpectedDigit
  | ExpectedComma
  | ExpectedCloseParen;
"
  Error.clearErrors()
  let formatted = Formatter.formatWithMode(source, Formatter.RealFix)
  let marks = Error.getMarkedErrors()
  assertEquals(canonicalNonWs(source), canonicalNonWs(formatted))
  assertEquals(marks, [])
})

test("formatter produces mark on broken input", () => {
  let source = "
record broekn = .{ value: Int, next: Int };
"
  Error.clearErrors()
  let formatted = Formatter.formatWithMode(source, Formatter.RealFix)
  let marks = Error.getMarkedErrors()
  let fmtMarks = List.filter(
    (m: Error.MarkedError) => match (m.mark.kind) {
      SurfaceAst.FormattingMismatch(_) => true,
      _ => false,
    },
    marks
  )
  assertEquals(canonicalNonWs(source), canonicalNonWs(formatted))
  assertTrue(List.length(fmtMarks) > 0)
})

test("formatting roundtrips util.testStr", () => {
  let formatted1 = Formatter.format(Util.testStr)
  let formatted2 = Formatter.format(formatted1)
  assertEquals(formatted1, formatted2)
})

test("real formatter preserves non-whitespace tokens on util.testStr", () => {
  let formatted = Formatter.format(Util.testStr)
  assertEquals(canonicalNonWs(Util.testStr), canonicalNonWs(formatted))
})

test("fix mode doesnt insert semicolon in broken case", () => {
  let source = "
let= 25
and= 

let= {
  let= 25
  and= 6
"

  let fixExpected = "
let= 25
and= 

let= {
  let= 25
  and= 6
"

  let fixOut = Formatter.formatWithMode(source, Formatter.RealFix)
  assertEquals(canonicalNonWs(fixExpected), canonicalNonWs(fixOut))
})

test("fix mode does not spray semicolons in broken record line", () => {
  let source =
    "
type Orientation = N | E | S | W;
let start: Location = { x= 0, y= 0 }; //have a bug on purpose, missing .{

let main = => {
print(process(input));
}

let x = 1
"
  let fixOut = Formatter.formatWithMode(source, Formatter.RealFix)
  let expected =
    "
type Orientation = N | E | S | W;
let start: Location = { x= 0, y= 0 }; //have a bug on purpose, missing .{

let main = => {
print(process(input));
};

let x = 1;
"
  assertEquals(canonicalNonWs(expected), canonicalNonWs(fixOut))
})

test("formatter real handles incomplete example", () => {
  let source = "
let main = => {
  let x =
"

  let realOut = Formatter.formatWithMode(source, Formatter.Real)
  assertEquals(canonicalNonWs(source), canonicalNonWs(realOut))

  //step2
  let source = "
let incompl
"

  let realOut = Formatter.formatWithMode(source, Formatter.Real)
  assertEquals(canonicalNonWs(source), canonicalNonWs(realOut))
})

test("preserve trivia", () => {
  let source = "
let main = => {
  let x =

// comment
"

  let realOut = Formatter.formatWithMode(source, Formatter.Real)
  assertEquals(canonicalNonWs(source), canonicalNonWs(realOut))

  //step2
  let source = "
let incompl

// comment
"

  let realOut = Formatter.formatWithMode(source, Formatter.Real)
  assertEquals(canonicalNonWs(source), canonicalNonWs(realOut))
})

test("formatter real handles opaque trivia", () => {
  let source =
    "
let main = => {
  let x =

just some random disruption

}
lorem
//comment
"

  let realOut = Formatter.formatWithMode(source, Formatter.Real)
  assertEquals(canonicalNonWs(source), canonicalNonWs(realOut))

  //step2
  let source =
    "
let incompl

just some random disruption
} <- cuz why not Uppercase trivia
"

  let realOut = Formatter.formatWithMode(source, Formatter.Real)
  assertEquals(canonicalNonWs(source), canonicalNonWs(realOut))
})

test("edge case with trivia", () => {
  let source =
    "
let start: Location = .{ x= 0, y= 0 };

random trivia
let x =
"

  let expectedVirtual =
    "
let start: Location = .{ x= 0, y= 0 };

random trivia
let x = ?;
"

  let expectedFix =
    "
let start: Location = .{ x= 0, y= 0 };

random trivia
let x =
"

  let outVirtual = Formatter.formatWithMode(source, Formatter.Virtual)
  let outFix = Formatter.formatWithMode(source, Formatter.RealFix)
  assertEquals(canonicalNonWs(expectedVirtual), canonicalNonWs(outVirtual))
  assertEquals(canonicalNonWs(expectedFix), canonicalNonWs(outFix))
})

test("formatter modes handle missing semicolon and brace", () => {
  let source = "
let main = => {
  let x = 
"
  let realOut = Formatter.formatWithMode(source, Formatter.Real)
  let virtualOut = Formatter.formatWithMode(source, Formatter.Virtual)
  let fixOut = Formatter.formatWithMode(source, Formatter.RealFix)

  assertEquals(canonicalNonWs(source), canonicalNonWs(realOut))
  assertEquals(canonicalNonWs(source), canonicalNonWs(fixOut))

  let expectedVirtual = "
let main = () => {
  let x = ?
};
"
  assertEquals(canonicalNonWs(expectedVirtual), canonicalNonWs(virtualOut))
})

test("formatter handles broken record decl", () => {
  let source = "
let start: Location = .{ x= 0, y= 0 };
"
  let realOut = Formatter.formatWithMode(source, Formatter.Real)
  let virtualOut = Formatter.formatWithMode(source, Formatter.Virtual)
  let fixOut = Formatter.formatWithMode(source, Formatter.RealFix)

  let expectedVirtual = "
let start : Location = .{ x = 0, y = 0 };
"
  all(
    [
      assertEquals(canonicalNonWs(source), canonicalNonWs(realOut)),
      assertEquals(canonicalNonWs(expectedVirtual), canonicalNonWs(fixOut)),
      assertEquals(canonicalNonWs(expectedVirtual), canonicalNonWs(virtualOut)),
    ]
  )
})

test("formatter modes handle missing semicolon and brace 2", () => {
  let source = "
let main = => {
"
  let realOut = Formatter.formatWithMode(source, Formatter.Real)
  let virtualOut = Formatter.formatWithMode(source, Formatter.Virtual)
  let fixOut = Formatter.formatWithMode(source, Formatter.RealFix)

  let expectedVirtual = "
let main = () => {
};
"
  all(
    [
      assertEquals(canonicalNonWs(source), canonicalNonWs(realOut)),
      assertEquals(canonicalNonWs(source), canonicalNonWs(fixOut)),
      assertEquals(canonicalNonWs(expectedVirtual), canonicalNonWs(virtualOut)),
    ]
  )
})

test("format virtual difficult", () => {
  let source =
    "
let 
=
25
and 
=
67
let 
= 
{
let 
=
25
and 
=
67
"
  let realOut = Formatter.formatWithMode(source, Formatter.Real)
  let virtualOut = Formatter.formatWithMode(source, Formatter.Virtual)
  let fixOut = Formatter.formatWithMode(source, Formatter.RealFix)

  let expectedFix =
    "
let
=
25
and
=
67
let
=
{
let
=
25
and
=
67
"

  let expectedVirtual =
    "
let _ = 25
and _ = 67;

let _ = {
  let _ = 25
  and _ = 67
};
"
  all(
    [
      assertEquals(canonicalNonWs(source), canonicalNonWs(realOut)),
      assertEquals(canonicalNonWs(expectedFix), canonicalNonWs(fixOut)),
      assertEquals(canonicalNonWs(expectedVirtual), canonicalNonWs(virtualOut)),
    ]
  )
})

test("formatter fix aoc", () => {
  let source =
    "
let input = \"L1, R3, R1, L5, L2, L5\";

export type GenericError =
  | Error;

record Location = { x: Int, y: Int };
record Operation = { direction: Direction, distance: Int };
type Direction = L | R;
type Orientation = N | E | S | W;
let start: Location = { x= 0, y= 0 };

// Function to parse a string into an Operation
let produceOp = (in) => {
  let intL = 'L' :> charToInt;
  let intR = 'R' :> charToInt;
  let val = (in, 0) :> list.at :> stripErr;
  let direction = stripErr(
    match(val) {
      intL => { IOk(L) },
      intR => { IOk(R) },
      _ => { IErr(Error) }
    }
  );
  let distance = (isDigit, in) 
    :> list.filter 
    :> posIntStringToInt;
  let yoink = match(direction, distance) {
    (direction, Some(distance)) => { 
      IOk(Operation{ direction, distance }) 
    },
    (direction, None) => { 
      IErr((direction, distance)) 
    }
  };
  yoink
};

// Function to create a movement function based on orientation and distance
let move = (orient, distance) => {
  (pos) => {
    match(orient) {
      N => { .{ x= pos.x, y= pos.y + distance } },
      E => { .{ x= pos.x + distance, y= pos.y } },
      S => { .{ x= pos.x, y= pos.y - distance } },
      W => { .{ x= pos.x - distance, y= pos.y } }
    }
  }
};
let rec walker = (opList, orient, location) => {
  let (opx, opList2) = stripErr(list.uncons(opList));
  let newOrient = match((opx.direction, orient)) {
    (L, N) => { W },
    (L, E) => { N },
    (L, S) => { E },
    (L, W) => { S },
    (R, N) => { E },
    (R, E) => { S },
    (R, S) => { W },
    (R, W) => { N }
  };
  let amount = opx.distance;
  let newLoc = move(newOrient, amount)(location);
  if (list.length(opList2) > 0) { 
    walker(opList2, newOrient, newLoc) 
  } else {
    newLoc
  }
};

let rec yoink = (infectedList) => {
  match(list.uncons(infectedList)) {
    IOk((head, tail)) => {
      match(head, yoink(tail)) {
        (IOk(value), IOk(restList)) => { IOk(Link(value, restList)) },
        (IErr(err), _) => { IErr(err) },
        (_, IErr(err)) => { IErr(err) }
      }
    },
    IErr(_) => { IOk(Empty) }
  }
};

let process = (in) => {
  let str = stringToList(in);
  let cleanedStr = list.remove(char(\" \"), str);
  let opStrList = list.splitBy(cleanedStr, char(\",\"));
  let opList = list.map(produceOp, opStrList);
  let cleanOpList = stripErr(yoink(opList));
  let finalLoc = walker(cleanOpList, N, start);
  abs(finalLoc.x) + abs(finalLoc.y)
};

let main = => {
print(process(input));
}

let x = 1
"

  let target =
    "
let input = \"L1, R3, R1, L5, L2, L5\";



export type GenericError = | Error;

record Location = { x : Int, y : Int };

record Operation = { direction : Direction, distance : Int };

type Direction = L | R;

type Orientation = N | E | S | W;

let start : Location = {
  x = 0,
  y = 0
};

// Function to parse a string into an Operation

let produceOp = (in) => {
  let intL = 'L' :> charToInt;
  let intR = 'R' :> charToInt;
  let val = (in, 0) :> list.at :> stripErr;
  let direction = stripErr(match(val) { intL => {
    IOk(L)
  }, intR => {
    IOk(R)
  }, _ => {
    IErr(Error)
  } });
  let distance = (isDigit, in) :> list.filter :> posIntStringToInt;
  let yoink = match(direction, distance) { (direction, Some(distance)) => {
    IOk(Operation{ direction, distance })
  }, (direction, None) => {
    IErr((direction, distance))
  } };
  yoink
};

// Function to create a movement function based on orientation and distance

let move = (orient, distance) => {
  (pos) => {
    match(orient) { N => {
      .{ x = pos.x, y = pos.y + distance }
    }, E => {
      .{ x = pos.x + distance, y = pos.y }
    }, S => {
      .{ x = pos.x, y = pos.y - distance }
    }, W => {
      .{ x = pos.x - distance, y = pos.y }
    } }
  }
};

let rec walker = (opList, orient, location) => {
  let (opx, opList2) = stripErr(list.uncons(opList));
  let newOrient = match((opx.direction, orient)) { (L, N) => {
    W
  }, (L, E) => {
    N
  }, (L, S) => {
    E
  }, (L, W) => {
    S
  }, (R, N) => {
    E
  }, (R, E) => {
    S
  }, (R, S) => {
    W
  }, (R, W) => {
    N
  } };
  let amount = opx.distance;
  let newLoc = move(newOrient, amount)(location);
  if (list.length(opList2) > 0) {
    walker(opList2, newOrient, newLoc)
  } else {
    newLoc
  }
};

let rec yoink = (infectedList) => {
  match(list.uncons(infectedList)) { IOk((head, tail)) => {
    match(head, yoink(tail)) { (IOk(value), IOk(restList)) => {
      IOk(Link(value, restList))
    }, (IErr(err), _) => {
      IErr(err)
    }, (_, IErr(err)) => {
      IErr(err)
    } }
  }, IErr(_) => {
    IOk(Empty)
  } }
};

let process = (in) => {
  let str = stringToList(in);
  let cleanedStr = list.remove(char(\" \"), str);
  let opStrList = list.splitBy(cleanedStr, char(\",\"));
  let opList = list.map(produceOp, opStrList);
  let cleanOpList = stripErr(yoink(opList));
  let finalLoc = walker(cleanOpList, N, start);
  abs(finalLoc.x) + abs(finalLoc.y)
};

let main = => {
  print(process(input));
};

let x = 1;"

  let fixOut = Formatter.formatWithMode(source, Formatter.RealFix)

  assertEquals(canonicalNonWs(target), canonicalNonWs(fixOut))
})

test("formatter modes mode handles incomplete top level statement", () => {
  let source = "
let x = 
"
  let realOut = Formatter.formatWithMode(source, Formatter.Real)
  let virtualOut = Formatter.formatWithMode(source, Formatter.Virtual)
  let fixOut = Formatter.formatWithMode(source, Formatter.RealFix)

  assertEquals(canonicalNonWs(source), canonicalNonWs(realOut))
  assertEquals(canonicalNonWs(source), canonicalNonWs(fixOut))

  let expectedVirtual = "
let x = ?;
"
  assertEquals(canonicalNonWs(expectedVirtual), canonicalNonWs(virtualOut))
})

test("formatter modes mode handles incomplete top level statement2", () => {
  let source = "
let x = x
"
  let realOut = Formatter.formatWithMode(source, Formatter.Real)
  let virtualOut = Formatter.formatWithMode(source, Formatter.Virtual)
  let fixOut = Formatter.formatWithMode(source, Formatter.RealFix)

  assertEquals(canonicalNonWs(source), canonicalNonWs(realOut))

  let expected = "
let x = x;
"
  assertEquals(canonicalNonWs(expected), canonicalNonWs(fixOut))
  assertEquals(canonicalNonWs(expected), canonicalNonWs(virtualOut))
})

test("fix mode inserts decidable semicolons", () => {
  let source = "
let main = => {
  let x = 1
  let y = 2
}
"
  let realOut = Formatter.formatWithMode(source, Formatter.Real)
  let fixOut = Formatter.formatWithMode(source, Formatter.RealFix)

  assertEquals(canonicalNonWs(source), canonicalNonWs(realOut))

  let expectedFix = "
let main = => {
  let x = 1;
  let y = 2
};
"
  assertEquals(canonicalNonWs(expectedFix), canonicalNonWs(fixOut))
})

test("formatter edge case", () => {
  let source =
    "
let input = \"L1, R3, R1, L5, L2, L5\";

export type GenericError =
  | Error;

// and a comment
"
  let realOut = Formatter.formatWithMode(source, Formatter.Real)
  let fixOut = Formatter.formatWithMode(source, Formatter.RealFix)
  let virtualOut = Formatter.formatWithMode(source, Formatter.Virtual)

  assertEquals(canonicalNonWs(source), canonicalNonWs(realOut))
  assertEquals(canonicalNonWs(source), canonicalNonWs(fixOut))
  assertEquals(canonicalNonWs(source), canonicalNonWs(virtualOut))
})

let results = runTests()
printResultsAndExit(results)
