module FormatTest

from "../submodules/graintest/lib/test.gr" include Test
use Test.*

from "../src/util.gr" include Util
from "../src/frontend/formatter.gr" include Formatter
from "string" include String

setSourceFile("./tests/format_test.gr")

let canonicalNonWs = (text: String) => {
  let noSpace = String.replaceAll(" ", "", text)
  let noTab = String.replaceAll("\t", "", noSpace)
  let noLf = String.replaceAll("\n", "", noTab)
  String.replaceAll("\r", "", noLf)
}

test("formatting is stable on a small program", () => {
  let source =
    "
let x = (y) => { match(y) { y => { 1 } } };
"
  let formatted1 = Formatter.format(source)
  let formatted2 = Formatter.format(formatted1)
  assertEquals(formatted1, formatted2)
})

test("formatting roundtrips util.testStr", () => {
  let formatted1 = Formatter.format(Util.testStr)
  let formatted2 = Formatter.format(formatted1)
  assertEquals(formatted1, formatted2)
})

test("real formatter preserves non-whitespace tokens on util.testStr", () => {
  let formatted = Formatter.format(Util.testStr)
  assertEquals(canonicalNonWs(Util.testStr), canonicalNonWs(formatted))
})

test("formatter real handles incomplete example", () => {
  let source =
    "
let main = => {
  let x =
"

  let realOut = Formatter.formatWithMode(source, Formatter.Real)
  assertEquals(canonicalNonWs(source), canonicalNonWs(realOut))

  //step2
  let source =
    "
let incompl
"

  let realOut = Formatter.formatWithMode(source, Formatter.Real)
  assertEquals(canonicalNonWs(source), canonicalNonWs(realOut))
})

test("preserve trivia", () => {
  let source =
    "
let main = => {
  let x =

// comment
"

  let realOut = Formatter.formatWithMode(source, Formatter.Real)
  assertEquals(canonicalNonWs(source), canonicalNonWs(realOut))


  //step2
  let source =
    "
let incompl

// comment
"

  let realOut = Formatter.formatWithMode(source, Formatter.Real)
  assertEquals(canonicalNonWs(source), canonicalNonWs(realOut))
})


test("formatter real handles opaque trivia", () => {
  let source =
    "
let main = => {
  let x =

just some random disruption

}
lorem
//comment
"

  let realOut = Formatter.formatWithMode(source, Formatter.Real)
  assertEquals(canonicalNonWs(source), canonicalNonWs(realOut))

  //step2
  let source =
    "
let incompl

just some random disruption
} <- cuz why not Uppercase trivia
"

  let realOut = Formatter.formatWithMode(source, Formatter.Real)
  assertEquals(canonicalNonWs(source), canonicalNonWs(realOut))
})



test("formatter modes handle missing semicolon and brace", () => {
  let source =
    "
let main = => {
  let x = 
"
  let realOut = Formatter.formatWithMode(source, Formatter.Real)
  let virtualOut = Formatter.formatWithMode(source, Formatter.Virtual)
  let fixOut = Formatter.formatWithMode(source, Formatter.Fix)

  assertEquals(canonicalNonWs(source), canonicalNonWs(realOut))
  assertEquals(canonicalNonWs(source), canonicalNonWs(fixOut))

  let expectedVirtual =
    "
let main = => {
  let x = ?
};
"
  assertEquals(canonicalNonWs(expectedVirtual), canonicalNonWs(virtualOut))
})

test("formatter modes handle missing semicolon and brace", () => {
  let source =
    "
let main = => {
"
  let realOut = Formatter.formatWithMode(source, Formatter.Real)
  let virtualOut = Formatter.formatWithMode(source, Formatter.Virtual)
  let fixOut = Formatter.formatWithMode(source, Formatter.Fix)

  assertEquals(canonicalNonWs(source), canonicalNonWs(realOut))
  assertEquals(canonicalNonWs(source), canonicalNonWs(fixOut))

  let expectedVirtual =
    "
let main = => {
};
"
  assertEquals(canonicalNonWs(expectedVirtual), canonicalNonWs(virtualOut))
})

test("formatter modes mode handles incomplete top level statement", () => {
  let source =
    "
let x = 
"
  let realOut = Formatter.formatWithMode(source, Formatter.Real)
  let virtualOut = Formatter.formatWithMode(source, Formatter.Virtual)
  let fixOut = Formatter.formatWithMode(source, Formatter.Fix)

  assertEquals(canonicalNonWs(source), canonicalNonWs(realOut))
  assertEquals(canonicalNonWs(source), canonicalNonWs(fixOut))

  let expectedVirtual =
    "
let x = ?;
"
  assertEquals(canonicalNonWs(expectedVirtual), canonicalNonWs(virtualOut))
})

test("formatter modes mode handles incomplete top level statement2", () => {
  let source =
    "
let x = x
"
  let realOut = Formatter.formatWithMode(source, Formatter.Real)
  let virtualOut = Formatter.formatWithMode(source, Formatter.Virtual)
  let fixOut = Formatter.formatWithMode(source, Formatter.Fix)

  assertEquals(canonicalNonWs(source), canonicalNonWs(realOut))

  let expected =
    "
let x = x;
"
  assertEquals(canonicalNonWs(expected), canonicalNonWs(fixOut))
  assertEquals(canonicalNonWs(expected), canonicalNonWs(virtualOut))
})


test("fix mode inserts decidable semicolons", () => {
  let source =
    "
let main = => {
  let x = 1
  let y = 2
}
"
  let realOut = Formatter.formatWithMode(source, Formatter.Real)
  let fixOut = Formatter.formatWithMode(source, Formatter.Fix)

  assertEquals(canonicalNonWs(source), canonicalNonWs(realOut))

  let expectedFix =
    "
let main = => {
  let x = 1;
  let y = 2
};
"
  assertEquals(canonicalNonWs(expectedFix), canonicalNonWs(fixOut))
})

test("formatter edge case", () => {
  let source =
    "
let input = \"L1, R3, R1, L5, L2, L5\";

export type GenericError =
  | Error;

// and a comment
"
  let realOut = Formatter.formatWithMode(source, Formatter.Real)
  let fixOut = Formatter.formatWithMode(source, Formatter.Fix)
  let virtualOut = Formatter.formatWithMode(source, Formatter.Virtual)

  assertEquals(canonicalNonWs(source), canonicalNonWs(realOut))
  assertEquals(canonicalNonWs(source), canonicalNonWs(fixOut))
  assertEquals(canonicalNonWs(source), canonicalNonWs(virtualOut))
})



let results = runTests()
printResultsAndExit(results)
