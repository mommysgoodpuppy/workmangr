module ModuleInferTest

from "../submodules/graintest/lib/test.gr" include Test
use Test.*

from "list" include List
from "map" include Map
from "string" include String

from "../src/core/module_infer.gr" include ModuleInfer
from "../src/core/error.gr" include Error
from "../src/core/types.gr" include Types
from "../src/module/module_system.gr" include ModuleSystem

setSourceFile("./tests/module_infer_test.gr")

let expectModule = (result: ModuleInfer.InferenceResult, moduleId: String) =>
  match (Map.get(moduleId, result.modules)) {
    Some(summary) => summary,
    None => fail("missing module summary: " ++ moduleId),
  }

test("module infer resolves alias imports from dependency exports", () => {
  let overrides = Map.make()
  Map.set(
    "coretypes.wm",
    "export type List<T> = Empty | Link<(T, List<T>)>;",
    overrides
  )
  Map.set(
    "entry.wm",
    "from \"./coretypes\" import * as Core;\nlet mk = (x) => { Core.Link((x, Core.Empty)) };",
    overrides
  )

  let result = ModuleInfer.inferEntry(
    "entry",
    options={ ...ModuleSystem.defaultOptions(), sourceOverrides: overrides }
  )
  let entry = expectModule(result, "entry.wm")
  let mkScheme = match (Map.get("mk", entry.valueExports)) {
    Some(scheme) => scheme,
    None => fail("missing mk binding"),
  }
  let hasNoTypeErrors = !List.some(
    (diag: Error.CompilerError) => diag.stage == Error.TypeInference,
    entry.diagnostics
  )
  let shapeOk = match (mkScheme.ty) {
    Types.TFun(Types.TVar(a), Types.TNominal("List", [Types.TVar(b)])) => a == b,
    _ => false,
  }

  all([assertTrue(shapeOk), assertTrue(hasNoTypeErrors)])
})

test("module infer uses implicit std prelude reexports for constructors", () => {
  let overrides = Map.make()
  Map.set(
    "entry.wm",
    "let mk = (x) => { Link((x, Empty)) };",
    overrides
  )
  Map.set(
    "stdroot/prelude.wm",
    "export from \"std/coretypes\" type List(..);",
    overrides
  )
  Map.set(
    "stdroot/coretypes.wm",
    "export type List<T> = Empty | Link<(T, List<T>)>;",
    overrides
  )

  let result = ModuleInfer.inferEntry(
    "entry",
    options={
      ...ModuleSystem.defaultOptions(),
      stdRoots: ["stdroot"],
      sourceOverrides: overrides,
    }
  )
  let entry = expectModule(result, "entry.wm")
  let mkScheme = match (Map.get("mk", entry.valueExports)) {
    Some(scheme) => scheme,
    None => fail("missing mk binding"),
  }
  let shapeOk = match (mkScheme.ty) {
    Types.TFun(Types.TVar(a), Types.TNominal("List", [Types.TVar(b)])) => a == b,
    _ => false,
  }

  assertTrue(shapeOk)
})

test("imported constructor shorthand keeps recursive length polymorphic", () => {
  let overrides = Map.make()
  Map.set(
    "coretypes.wm",
    "export type List<T> = Empty | Link<T, List<T>>;",
    overrides
  )
  Map.set(
    "entry.wm",
    "from \"./coretypes\" import { Empty, Link };\nexport let rec length = match(list) => {\n  Empty => { 0 },\n  Link(_, rest) => { length(rest) }\n};",
    overrides
  )

  let result = ModuleInfer.inferEntry(
    "entry",
    options={ ...ModuleSystem.defaultOptions(), sourceOverrides: overrides }
  )
  let entry = expectModule(result, "entry.wm")
  let lengthScheme = match (Map.get("length", entry.valueExports)) {
    Some(scheme) => scheme,
    None => fail("missing length binding"),
  }
  let shapeOk = match (lengthScheme.ty) {
    Types.TFun(Types.TNominal("List", [Types.TVar(a)]), Types.TNumber) =>
      Types.containsVar(lengthScheme.quantifiers, a),
    _ => false,
  }
  assertTrue(shapeOk)
})

test("named imports with alias resolve correct symbol", () => {
  let overrides = Map.make()
  Map.set(
    "coretypes.wm",
    "export type Ordering = LT | EQ | GT;\nexport let eq = EQ;",
    overrides
  )
  Map.set(
    "coreint.wm",
    "export let intEq = (left, right) => { true };",
    overrides
  )
  Map.set(
    "entry.wm",
    "from \"./coretypes\" import { EQ };\nfrom \"./coreint\" import { intEq as eq };\nlet ok = eq(1, 1);",
    overrides
  )

  let result = ModuleInfer.inferEntry(
    "entry",
    options={ ...ModuleSystem.defaultOptions(), sourceOverrides: overrides }
  )
  let entry = expectModule(result, "entry.wm")
  let okScheme = match (Map.get("ok", entry.valueExports)) {
    Some(scheme) => scheme,
    None => fail("missing ok binding"),
  }
  let hasTypeErrors = List.some(
    (diag: Error.CompilerError) => diag.stage == Error.TypeInference,
    entry.diagnostics
  )
  let typeOk = match (okScheme.ty) {
    Types.TBool => true,
    _ => false,
  }
  all([assertFalse(hasTypeErrors), assertTrue(typeOk)])
})

test("std core int module typechecks native arithmetic builtins", () => {
  let result = ModuleInfer.inferEntry(
    "tests/fixtures/workman_std/core/int",
    options={
      ...ModuleSystem.defaultOptions(),
      rootDir: ".",
      stdRoots: ["tests/fixtures/workman_std"],
    }
  )
  let entry = expectModule(result, "tests/fixtures/workman_std/core/int.wm")
  let hasNativeUnknown = List.some(
    (diag: Error.CompilerError) =>
      diag.stage == Error.TypeInference
        && (
          String.contains("unknown identifier nativeAdd", diag.message)
            || String.contains("unknown identifier nativeSub", diag.message)
            || String.contains("unknown identifier nativeMul", diag.message)
            || String.contains("unknown identifier nativeDiv", diag.message)
            || String.contains("unknown identifier nativeCmpInt", diag.message)
        ),
    entry.diagnostics
  )
  assertFalse(hasNativeUnknown)
})

let results = runTests()
printResultsAndExit(results)
