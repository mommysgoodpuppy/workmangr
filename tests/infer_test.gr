module InferTest

from "../submodules/graintest/lib/test.gr" include Test
use Test.*

from "../src/frontend/frontend.gr" include Frontend
from "../src/core/infer.gr" include Infer
from "../src/core/layer1/mod.gr" include Layer1
from "../src/core/layer2/mod.gr" include Layer2
from "../src/core/core_ast.gr" include CoreAst
from "../src/core/types.gr" include Types
from "map" include Map
from "list" include List
from "string" include String

setSourceFile("./tests/infer_test.gr")

let inferSource = (source: String) => {
  let program = Frontend.parseAndLower(source)
  Infer.inferProgram(program)
}

let inferSourceWithEnv = (source: String, env: Types.Env) => {
  let program = Frontend.parseAndLower(source)
  Infer.inferProgramWithEnv(program, env)
}

let assertFunScheme = (scheme: Types.Scheme) => {
  let quantCount = List.length(scheme.quantifiers)
  assertTrue(quantCount >= 1)

  match (scheme.ty) {
    Types.TFun(Types.TVar(arg), Types.TVar(result)) =>
      assertEquals(arg, result),
    _ => fail "expected function scheme",
  }
}

let expectTopBinding = (state: Infer.InferState, name: String) =>
  match (Map.get(name, state.topBindings)) {
    Some(scheme) => scheme,
    None => fail "missing binding: " ++ name,
  }

let assertFunctionShape = (scheme: Types.Scheme) =>
  match (scheme.ty) {
    Types.TFun(_, _) => assertTrue(true),
    _ => fail "expected function type",
  }

test("let generalization produces polymorphic scheme", () => {
let source =
    "
let id = (x) => { x };
let useNumber = (n) => { id(n) };
let useFunction = (f) => { id(f) };
"

  let state = inferSource(source)
  let scheme = expectTopBinding(state, "id")
  assertFunScheme(scheme)
  assertEquals(0, List.length(state.constraints))
})

test("tuple expressions infer tuple element types", () => {
  let source =
    "
let pair = (x) => { (x, x) };
"
  let state = inferSource(source)
  let scheme = expectTopBinding(state, "pair")

  match (scheme.ty) {
    Types.TFun(Types.TVar(arg), Types.TTuple([Types.TVar(a), Types.TVar(b)])) => {
      assertEquals(arg, a)
      assertEquals(arg, b)
      assertTrue(List.length(scheme.quantifiers) >= 1)
    },
    _ => fail "expected pair : 'a -> ('a, 'a)",
  }
})

test("let rec infers recursive function via placeholder", () => {
  let source =
    "
let rec loop = (n) => { loop(n) };
"
  let state = inferSource(source)
  let scheme = expectTopBinding(state, "loop")
  assertFunctionShape(scheme)
})

test("let rec and infers mutual recursion in one group", () => {
  let source =
    "
let rec isEven = (n) => { isOdd(n) } and isOdd = (n) => { isEven(n) };
"
  let state = inferSource(source)
  let evenScheme = expectTopBinding(state, "isEven")
  let oddScheme = expectTopBinding(state, "isOdd")
  assertFunctionShape(evenScheme)
  assertFunctionShape(oddScheme)
})

test("type decl registers constructor schemes for expression typing", () => {
  let source =
    "
type Option<T> = Some<T> | None;
let wrap = (x) => { Some(x) };
let none = None;
"
  let state = inferSource(source)
  let wrapScheme = expectTopBinding(state, "wrap")
  let noneScheme = expectTopBinding(state, "none")

  match (wrapScheme.ty) {
    Types.TFun(Types.TVar(a), Types.TNominal("Option", [Types.TVar(b)])) => {
      assertEquals(a, b)
      assertTrue(List.length(wrapScheme.quantifiers) >= 1)
    },
    _ => fail "expected wrap : 'a -> Option<'a>",
  }

  match (noneScheme.ty) {
    Types.TNominal("Option", [_]) =>
      assertTrue(List.length(noneScheme.quantifiers) >= 1),
    _ => fail "expected none : Option<'a>",
  }
})

test("constructor patterns typecheck in match clauses", () => {
  let source =
    "
type Option<T> = Some<T> | None;
let unwrapOr = (pair) => {
  match(pair) {
    (Some(v), fallback) => { v }
    (None, fallback) => { fallback }
  }
};
"
  let state = inferSource(source)
  let scheme = expectTopBinding(state, "unwrapOr")
  assertFunctionShape(scheme)
  assertEquals(0, List.length(state.constraints))
})

test("index:Int annotation accepts numeric literals in match params", () => {
  let source =
    "
let classify = match(index:Int) => {
  0 => { true }
  _ => { false }
};
"
  let state = inferSource(source)
  let hasHardMismatch = List.some(
    (entry: Infer.TypeMark) =>
      entry.reason == Infer.TypeMismatch
        && String.contains("cannot unify", entry.message),
    state.marks
  )
  assertFalse(hasHardMismatch)
})

test("literal patterns use their literal type", () => {
  let source =
    "
let choose = (x) => {
  match(x) {
    true => { 1 }
    false => { 0 }
  }
};
"
  let state = inferSource(source)
  let scheme = expectTopBinding(state, "choose")
  match (scheme.ty) {
    Types.TFun(Types.TBool, Types.TNumber) => assertTrue(true),
    _ => fail "expected choose : Bool -> Number",
  }
})

test("inferProgramWithEnv seeds cross-module schemes", () => {
  let source = "let make = (x) => { Some(x) };"
  let importedEnv = Map.make()
  let optionVar = Types.TVar(999)
  let someScheme: Types.Scheme = {
    quantifiers: [999],
    ty: Types.TFun(optionVar, Types.TNominal("Option", [optionVar])),
  }
  Map.set("Some", someScheme, importedEnv)

  let state = inferSourceWithEnv(source, importedEnv)
  let scheme = expectTopBinding(state, "make")
  assertFunctionShape(scheme)
})

test("inferProgramWithEnv resolves qualified module symbol names", () => {
  let source = "let first = (xs) => { List.at((xs, 0)) };"
  let importedEnv = Map.make()
  let tElem = Types.TVar(700)
  let tList = Types.TNominal("List", [tElem])
  let atScheme: Types.Scheme = {
    quantifiers: [700],
    ty: Types.TFun(Types.TTuple([tList, Types.TNumber]), tElem),
  }
  Map.set("List.at", atScheme, importedEnv)

  let state = inferSourceWithEnv(source, importedEnv)
  let scheme = expectTopBinding(state, "first")
  assertTrue(List.length(state.marks) == 0)
  assertFunctionShape(scheme)
})

test("layer1 then layer2 pipeline works explicitly", () => {
  let source =
    "
let id = (x) => { x };
let out = id(1);
"
  let program = Frontend.parseAndLower(source)
  let layer1State = Layer1.inferProgram(program)
  assertTrue(List.length(layer1State.constraints) > 0)

  let layer2State = Layer2.solve(layer1State)
  assertEquals(0, List.length(layer2State.constraints))
  let outScheme = expectTopBinding(layer2State, "out")
  assertEquals("Number", Types.typeToString(outScheme.ty))
})

test("literals map to primitive base types", () => {
  let source =
    "
let b = true;
let s = \"abc\";
"
  let state = inferSource(source)
  assertEquals("Bool", Types.typeToString(expectTopBinding(state, "b").ty))
  assertEquals("String", Types.typeToString(expectTopBinding(state, "s").ty))
})

test("if condition must be bool", () => {
  let source =
    "
let choose = (x) => { if (x) { 1 } else { 2 } };
"
  let state = inferSource(source)
  let scheme = expectTopBinding(state, "choose")
  match (scheme.ty) {
    Types.TFun(Types.TBool, Types.TNumber) => assertTrue(true),
    _ => fail "expected choose : Bool -> Number",
  }
})

test("temporary builtin infix arithmetic operators typecheck", () => {
  let source =
    "
let sum = 1 + 2;
let diff = 3 - 1;
let prod = 2 * 4;
"
  let state = inferSource(source)
  assertEquals("Number", Types.typeToString(expectTopBinding(state, "sum").ty))
  assertEquals("Number", Types.typeToString(expectTopBinding(state, "diff").ty))
  assertEquals("Number", Types.typeToString(expectTopBinding(state, "prod").ty))
})

test("temporary builtin comparison operators typecheck", () => {
  let source =
    "
let eq = 1 == 1;
let gt = 2 > 1;
"
  let state = inferSource(source)
  assertEquals("Bool", Types.typeToString(expectTopBinding(state, "eq").ty))
  assertEquals("Bool", Types.typeToString(expectTopBinding(state, "gt").ty))
})

test("nominal record literals and projection infer field types", () => {
  let source =
    "
record Location = { x: Number, y: Bool };
let r: Location = .{ x = 1, y = true };
let x = r.x;
"
  let state = inferSource(source)
  let xScheme = expectTopBinding(state, "x")
  assertEquals("Number", Types.typeToString(xScheme.ty))
  let hasProjectionErrors = List.some(
    (entry: Infer.TypeMark) => String.contains("record projection", entry.message),
    state.marks
  )
  assertFalse(hasProjectionErrors)
})

test("record literals require nominal context", () => {
  let source =
    "
let start = .{ x = 1, y = 2 };
"
  let state = inferSource(source)
  let hasNominalContextError = List.some(
    (entry: Infer.TypeMark) =>
      String.contains("record literal requires nominal type context", entry.message),
    state.marks
  )
  let startScheme = expectTopBinding(state, "start")
  all([
    assertTrue(hasNominalContextError),
    assertTrue(String.startsWith("?[", Types.typeToString(startScheme.ty))),
  ])
})

test("record literals infer unique nominal record and report missing/type errors", () => {
  let source =
    "
record Location = { x: Int, y: Int };
let start = .{ x = \"x\" };
"
  let state = inferSource(source)
  let startScheme = expectTopBinding(state, "start")
  let hasMissingY = List.some(
    (entry: Infer.TypeMark) => String.contains("missing record field y", entry.message),
    state.marks
  )
  let hasTypeMismatch = List.some(
    (entry: Infer.TypeMark) =>
      String.contains("cannot unify String with Int", entry.message)
        || String.contains("cannot unify Int with String", entry.message),
    state.marks
  )
  all([
    assertEquals("Location", Types.typeToString(startScheme.ty)),
    assertTrue(hasMissingY),
    assertTrue(hasTypeMismatch),
  ])
})

test("constructor-style nominal record construction supports punning", () => {
  let source =
    "
record Operation = { direction: Int, distance: Int };
let direction = 1;
let distance = 2;
let op = Operation{ direction, distance };
"
  let state = inferSource(source)
  let opScheme = expectTopBinding(state, "op")
  assertEquals("Operation", Types.typeToString(opScheme.ty))
})

test("constructor-style nominal record construction reports field errors", () => {
  let source =
    "
record Operation = { direction: Int, distance: Int };
let op = Operation{ direction = \"x\" };
"
  let state = inferSource(source)
  let opScheme = expectTopBinding(state, "op")
  let hasMissingDistance = List.some(
    (entry: Infer.TypeMark) => String.contains("missing record field distance", entry.message),
    state.marks
  )
  let hasTypeMismatch = List.some(
    (entry: Infer.TypeMark) =>
      String.contains("cannot unify String with Int", entry.message)
        || String.contains("cannot unify Int with String", entry.message),
    state.marks
  )
  all([
    assertEquals("Operation", Types.typeToString(opScheme.ty)),
    assertTrue(hasMissingDistance),
    assertTrue(hasTypeMismatch),
  ])
})

test("match clause guard parses and types as bool", () => {
  let source =
    "
let guarded = (x) => {
  match(x) {
    n when true => { n }
  }
};
"
  let state = inferSource(source)
  let scheme = expectTopBinding(state, "guarded")
  assertFunScheme(scheme)
})

test("type mismatch records mark and continues inference", () => {
  let source =
    "
let bad = (x) => { if (1) { x } else { x } };
"
  let state = inferSource(source)
  let scheme = expectTopBinding(state, "bad")
  assertFunctionShape(scheme)
  assertTrue(List.length(state.marks) > 0)
  let hasInconsistent = List.some(
    (entry: Infer.TypeMark) =>
      match (entry.mark) {
        CoreAst.Inconsistent => true,
        _ => false,
      },
    state.marks
  )
  assertTrue(hasInconsistent)
})

test("unknown identifier records free-var mark and continues", () => {
  let source =
    "
let bad = missingValue;
let keep = 1;
"
  let state = inferSource(source)
  let keepScheme = expectTopBinding(state, "keep")
  assertEquals("Number", Types.typeToString(keepScheme.ty))
  let hasUnknownIdentifier = List.some(
    (entry: Infer.TypeMark) => entry.reason == Infer.UnknownIdentifier,
    state.marks
  )
  let hasFreeVar = List.some(
    (entry: Infer.TypeMark) =>
      match (entry.mark) {
        CoreAst.FreeVar(_) => true,
        _ => false,
      },
    state.marks
  )
  all([assertTrue(hasUnknownIdentifier), assertTrue(hasFreeVar)])
})

test("conflicting hole obligations mark unfillable hole", () => {
  let source =
    "
let h = ?;
let _a = if (h) { 1 } else { 2 };
let _b = h(1);
"
  let state = inferSource(source)
  let hasUnfillable = List.some(
    (entry: Infer.TypeMark) =>
      entry.reason == Infer.UnfillableHole
        && match (entry.mark) {
          CoreAst.UnfillableHole => true,
          _ => false,
        },
    state.marks
  )
  assertTrue(hasUnfillable)
})

test("constructor pattern arity mismatch records mark and does not crash", () => {
  let source =
    "
type Option<T> = Some<T> | None;
let broken = (x) => {
  match(x) {
    None(v) => { v }
    _ => { 0 }
  }
};
let keep = 1;
"
  let state = inferSource(source)
  let keepScheme = expectTopBinding(state, "keep")
  assertEquals("Number", Types.typeToString(keepScheme.ty))
  let hasPatternArityMark = List.some(
    (entry: Infer.TypeMark) =>
      entry.reason == Infer.TypeMismatch
        && match (entry.mark) {
          CoreAst.PatternError => true,
          _ => false,
        },
    state.marks
  )
  assertTrue(hasPatternArityMark)
})

test("unknown constructor pattern with payload does not crash", () => {
  let source =
    "
let broken = (x) => {
  match(x) {
    Some(v) => { v }
    _ => { 0 }
  }
};
let keep = 1;
"
  let state = inferSource(source)
  let keepScheme = expectTopBinding(state, "keep")
  assertEquals("Number", Types.typeToString(keepScheme.ty))
  let hasUnknownOrPatternMark = List.some(
    (entry: Infer.TypeMark) =>
      entry.reason == Infer.UnknownIdentifier
        || match (entry.mark) {
          CoreAst.PatternError => true,
          _ => false,
        },
    state.marks
  )
  assertTrue(hasUnknownOrPatternMark)
})

test("let tuple pattern destructuring binds names in scope", () => {
  let source =
    "
let first = (pair) => {
  let (xs, ys) = pair;
  xs
};
"
  let state = inferSource(source)
  let scheme = expectTopBinding(state, "first")
  match (scheme.ty) {
    Types.TFun(Types.TTuple([Types.TVar(a), Types.TVar(_b)]), Types.TVar(result)) =>
      assertEquals(a, result),
    _ => fail "expected first : ('a, 'b) -> 'a",
  }
  let hasUnknownIdentifier = List.some(
    (entry: Infer.TypeMark) =>
      entry.reason == Infer.UnknownIdentifier
        && match (entry.mark) {
          CoreAst.FreeVar(name) => name.text == "xs" || name.text == "ys",
          _ => false,
        },
    state.marks
  )
  assertFalse(hasUnknownIdentifier)
})

test("length over List<T> remains polymorphic with constructor shorthand payload", () => {
  let source =
    "
type List<T> = Empty | Link<T, List<T>>;
let rec length = match(list) => {
  Empty => { 0 },
  Link(_, rest) => { length(rest) }
};
"
  let state = inferSource(source)
  let scheme = expectTopBinding(state, "length")
  match (scheme.ty) {
    Types.TFun(Types.TNominal("List", [Types.TVar(elem)]), Types.TNumber) =>
      assertTrue(List.length(scheme.quantifiers) >= 1 && Types.containsVar(scheme.quantifiers, elem)),
    _ => fail "expected length : List<'a> -> Number",
  }
})

test("local let rec binding resolves self-reference in expression scope", () => {
  let source =
    "
let outer = (x) => {
  let rec helper = (n) => { helper(n) };
  helper(x)
};
"
  let state = inferSource(source)
  let hasUnknownHelper = List.some(
    (entry: Infer.TypeMark) =>
      entry.reason == Infer.UnknownIdentifier
        && entry.message == "Type error: unknown identifier helper",
    state.marks
  )
  assertFalse(hasUnknownHelper)
})

test("layered pipeline matches direct infer result", () => {
  let source =
    "
type Option<T> = Some<T> | None;
let id = (x) => { x };
let out = id(1);
let fromSome = (o) => {
  match(o) {
    Some(v) => { v }
    None => { 0 }
  }
};
"
  let program = Frontend.parseAndLower(source)
  let direct = Infer.inferProgram(program)
  let layered = Layer2.solve(Layer1.inferProgram(program))

  let directOut = expectTopBinding(direct, "out")
  let layeredOut = expectTopBinding(layered, "out")
  assertEquals(Types.typeToString(directOut.ty), Types.typeToString(layeredOut.ty))

  let directFromSome = expectTopBinding(direct, "fromSome")
  let layeredFromSome = expectTopBinding(layered, "fromSome")
  assertEquals(
    Types.typeToString(directFromSome.ty),
    Types.typeToString(layeredFromSome.ty)
  )
})

let results = runTests()
printResultsAndExit(results)
