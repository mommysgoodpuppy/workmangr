module Api

from "array" include Array
from "list" include List
from "map" include Map
from "string" include String
from "wasi/process" include Process
from "fs" include Fs
from "path" include Path

from "../core/ast.gr" include Ast
from "../core/analysis.gr" include Analysis
from "../core/types.gr" include Types
from "../core/source.gr" include Source
from "../core/error.gr" include Error
from "../frontend/lexer.gr" include Lexer
from "../frontend/lower.gr" include Lower
from "../frontend/parser.gr" include Parser
from "../frontend/lower.gr" include Lower
from "../frontend/frontend.gr" include Frontend
from "../frontend/formatter.gr" include Formatter
from "./nodestore.gr" include NodeStore as NS
from "./indexer.gr" include Indexer

let escapeJson = (s: String) => {
  // Must escape backslashes FIRST to avoid double-escaping
  let step1 = String.replaceAll("\\", "\\\\", s)
  let step2 = String.replaceAll("\"", "\\\"", step1)
  let step3 = String.replaceAll("\n", "\\n", step2)
  let step4 = String.replaceAll("\r", "\\r", step3)
  String.replaceAll("\t", "\\t", step4)
}

let tokenToJson = (tok: Lexer.Token) => {
  // Get the actual token kind name from the lexer
  let kindName = match (tok.kind) {
    Lexer.Wildcard => "Wildcard",
    Lexer.LitName(_) => "LitName",
    Lexer.ConstructorTok(_) => "ConstructorTok",
    Lexer.LitNum(_) => "LitNum",
    Lexer.LitString(_) => "LitString",
    Lexer.LitChar(_) => "LitChar",
    Lexer.LitBool(_) => "LitBool",
    Lexer.KwVar => "KwVar",
    Lexer.KwAllErrors => "KwAllErrors",
    Lexer.LParen => "LParen",
    Lexer.RParen => "RParen",
    Lexer.LBrace => "LBrace",
    Lexer.RBrace => "RBrace",
    Lexer.FatArrow => "FatArrow",
    Lexer.Question => "Question",
    Lexer.Pipe => "Pipe",
    Lexer.DPipe => "DPipe",
    Lexer.SemiColon => "SemiColon",
    Lexer.Comma => "Comma",
    Lexer.Colon => "Colon",
    Lexer.PipeArrow => "PipeArrow",
    Lexer.Slash => "Slash",
    Lexer.DSlash => "DSlash",
    Lexer.LineComment(_) => "LineComment",
    Lexer.Arrow => "Arrow",
    Lexer.Period => "Period",
    Lexer.DotBrace => "DotBrace",
    Lexer.DPeriod => "DPeriod",
    Lexer.Eq => "Eq",
    Lexer.EqEq => "EqEq",
    Lexer.Plus => "Plus",
    Lexer.DPlus => "DPlus",
    Lexer.Dash => "Dash",
    Lexer.DDash => "DDash",
    Lexer.Directive => "Directive",
    Lexer.EOF => "EOF",
  }
  let kindStr = Lexer.tokenKindToString(tok.kind)
  let spanJson = "{\"line\":" ++ toString(tok.span.line) ++ 
                 ",\"col\":" ++ toString(tok.span.col) ++ 
                 ",\"start\":" ++ toString(tok.span.start) ++ 
                 ",\"end\":" ++ toString(tok.span.end) ++ "}"
  let mateJson = match (tok.mate) {
    None => "null",
    Some(m) => toString(m),
  }
  "{\"kind\":\"" ++ escapeJson(kindName) ++ "\"," ++
  "\"text\":\"" ++ escapeJson(kindStr) ++ "\"," ++
  "\"span\":" ++ spanJson ++ "," ++
  "\"mate\":" ++ mateJson ++ "}"
}

let expectedTopItemKindToString = (kind: Ast.ExpectedTopItemKind) => {
  match (kind) {
    Ast.TopItemAny => "AnyTopItem",
    Ast.TopItemDeclGroup => "DeclGroup",
    Ast.TopItemImport => "Import",
    Ast.TopItemReexport => "Reexport",
    Ast.TopItemExport => "Export",
    Ast.TopItemDirective => "Directive",
    Ast.TopItemTrivia => "Trivia",
    Ast.TopItemRecovery => "Recovery",
  }
}

let expectedKindToString = (kind: Ast.ExpectedKind) => {
  match (kind) {
    Ast.ExpectTopItem(tk) => "TopItem(" ++ expectedTopItemKindToString(tk) ++ ")",
    Ast.ExpectExpr => "Expr",
    Ast.ExpectPattern => "Pattern",
    Ast.ExpectTypeExpr => "TypeExpr",
    Ast.ExpectToken => "Token",
    Ast.ExpectBlock => "Block",
  }
}

let rec joinStrings = (sep: String, items: List<String>) => {
  match (items) {
    [] => "",
    [single] => single,
    [first, ...rest] => first ++ sep ++ joinStrings(sep, rest)
  }
}

let tokensToJson = (tokens: List<Lexer.Token>) => {
  let items = List.map(tokenToJson, tokens)
  "[" ++ joinStrings(",", items) ++ "]"
}

let rec exprToJson = (expr: Ast.Expr, depth: Number) => {
  if (depth > 8) {
    "{\"kind\":\"MaxDepth\",\"id\":" ++ toString(expr.node.id) ++ "}"
  } else {
    let kindName = match (expr.kind) {
      Ast.Lit(Ast.Int(n)) => "Lit(Int(" ++ toString(n) ++ "))",
      Ast.Lit(Ast.Bool(b)) => "Lit(Bool(" ++ toString(b) ++ "))",
      Ast.Lit(Ast.Str(s)) => "Lit(Str)",
      Ast.Lit(Ast.Char(_)) => "Lit(Char)",
      Ast.Lit(Ast.Unit) => "Lit(Unit)",
      Ast.Lit(Ast.Byte(_)) => "Lit(Byte)",
      Ast.Ident(name) => "Ident(" ++ escapeJson(name.text) ++ ")",
      Ast.Fn(_) => "Fn",
      Ast.Match(_) => "Match",
      Ast.Apply(_, _) => "Apply",
      Ast.InfixChain(_) => "InfixChain",
      Ast.Postfix(_) => "Postfix",
      Ast.Block(_) => "Block",
      Ast.Paren(_) => "Paren",
      Ast.Tuple(_) => "Tuple",
      Ast.RecordLit(_) => "RecordLit",
      Ast.Hole(_) => "Hole",
      Ast.If(_, _, _) => "If",
      Ast.Let(_) => "Let",
      Ast.Assign(_) => "Assign"
    }
    
    let childrenJson = match (expr.kind) {
      Ast.Block(block) => {
        // Serialize all items in the block
        let itemJsons = List.map((item) => {
          match (item) {
            Ast.ExprItem(e) => exprToJson(e, depth + 1),
            _ => "{\"kind\":\"OtherItem\"}"
          }
        }, block.items)
        ",\"children\":[" ++ joinStrings(",", itemJsons) ++ "]"
      },
      Ast.Fn(fnExpr) => {
        let clauseBodies = List.filterMap(
          (item: Ast.FnItem) =>
            match (item.kind) {
              Ast.Clause(clause) => Some(
                exprToJson(
                  { node: clause.body.node, kind: Ast.Block(clause.body), attach: clause.attach },
                  depth + 1,
                ),
              ),
              _ => None,
            },
          fnExpr.items
        )
        ",\"children\":[" ++ joinStrings(",", clauseBodies) ++ "]"
      },
      Ast.Match(m) => {
        let scrutineeJson = match (m.scrutinee) {
          None => [],
          Some(s) => [exprToJson(s, depth + 1)],
        }
        let clauseBodies = List.filterMap(
          (item: Ast.FnItem) =>
            match (item.kind) {
              Ast.Clause(clause) => Some(
                exprToJson(
                  { node: clause.body.node, kind: Ast.Block(clause.body), attach: clause.attach },
                  depth + 1,
                ),
              ),
              _ => None,
            },
          m.bundle.items
        )
        let allChildren = List.append(scrutineeJson, clauseBodies)
        ",\"children\":[" ++ joinStrings(",", allChildren) ++ "]"
      },
      Ast.Apply(callee, arg) => {
        let calleeJson = exprToJson(callee, depth + 1)
        let argJson = exprToJson(arg, depth + 1)
        ",\"children\":[" ++ calleeJson ++ "," ++ argJson ++ "]"
      },
      Ast.Assign(asg) => {
        let targetJson = exprToJson(asg.target, depth + 1)
        let valueJson = exprToJson(asg.value, depth + 1)
        ",\"children\":[" ++ targetJson ++ "," ++ valueJson ++ "]"
      },
      Ast.Let(binding) => {
        let valueJson = exprToJson(binding.value, depth + 1)
        ",\"children\":[" ++ valueJson ++ "]"
      },
      Ast.Paren(inner) => ",\"children\":[" ++ exprToJson(inner, depth + 1) ++ "]",
      Ast.Tuple(exprs) => {
        let tupleExprs = List.map((e) => exprToJson(e, depth + 1), exprs)
        ",\"children\":[" ++ joinStrings(",", tupleExprs) ++ "]"
      },
      Ast.InfixChain(chain) => {
        let firstJson = exprToJson(chain.first, depth + 1)
        let restJsons = List.map(((_, e)) => exprToJson(e, depth + 1), chain.rest)
        let allExprs = [firstJson, ...restJsons]
        ",\"children\":[" ++ joinStrings(",", allExprs) ++ "]"
      },
      Ast.If(cond, thenE, elseE) => {
        let condJson = exprToJson(cond, depth + 1)
        let thenJson = exprToJson(thenE, depth + 1)
        let elseJson = match (elseE) {
          Some(e) => exprToJson(e, depth + 1),
          None => "null"
        }
        ",\"children\":[" ++ condJson ++ "," ++ thenJson ++ "," ++ elseJson ++ "]"
      },
      _ => ""
    }
    
    "{\"id\":" ++ toString(expr.node.id) ++ 
    ",\"kind\":\"" ++ escapeJson(kindName) ++ "\"" ++ 
    ",\"span\":{\"start\":" ++ toString(expr.node.span.start) ++ 
    ",\"end\":" ++ toString(expr.node.span.end) ++ "}" ++
    childrenJson ++ "}"
  }
}

let topItemToJson = (item: Ast.TopItem) => {
  match (item) {
    Ast.DeclGroup(dg) => {
      let kindStr = match (dg.kind) {
        Ast.LetGroup(_) => "LetGroup",
        Ast.TypeGroup(_) => "TypeGroup",
        Ast.RecordGroup(_) => "RecordGroup",
        Ast.OpGroup => "OpGroup",
        Ast.RuleGroup(_) => "RuleGroup"
      }
      
      // Serialize declarations with their bindings and expressions
      let declsJson = match (dg.kind) {
        Ast.LetGroup(_) => {
          let declStrs = List.map((decl) => {
            match (decl) {
              Ast.LetDecl(ld) => {
                let bindingStrs = List.map((b: Ast.LetBinding) => {
                  let valueJson = exprToJson(b.value, 0)
                  "{\"kind\":\"LetBinding\",\"id\":" ++ toString(b.node.id) ++ 
                  ",\"span\":{\"start\":" ++ toString(b.node.span.start) ++ 
                  ",\"end\":" ++ toString(b.node.span.end) ++ "},\"value\":" ++ valueJson ++ "}"
                }, ld.bindings)
                "{\"kind\":\"LetDecl\",\"bindings\":[" ++ joinStrings(",", bindingStrs) ++ "]}"
              },
              _ => "{}"
            }
          }, dg.decls)
          ",\"decls\":[" ++ joinStrings(",", declStrs) ++ "]"
        },
        Ast.TypeGroup(_) | Ast.RecordGroup(_) => {
          let declStrs = List.map((decl) => {
            match (decl) {
              Ast.TypeDecl(td) => 
                "{\"kind\":\"TypeDecl\",\"id\":" ++ toString(td.node.id) ++ 
                ",\"span\":{\"start\":" ++ toString(td.node.span.start) ++ 
                ",\"end\":" ++ toString(td.node.span.end) ++ 
                "},\"name\":\"" ++ escapeJson(td.name.text) ++ "\"}",
              Ast.RecordDecl(rd) => 
                "{\"kind\":\"RecordDecl\",\"id\":" ++ toString(rd.node.id) ++ 
                ",\"span\":{\"start\":" ++ toString(rd.node.span.start) ++ 
                ",\"end\":" ++ toString(rd.node.span.end) ++ 
                "},\"name\":\"" ++ escapeJson(rd.name.text) ++ "\"}",
              _ => "{}"
            }
          }, dg.decls)
          ",\"decls\":[" ++ joinStrings(",", declStrs) ++ "]"
        },
        _ => ""
      }
      
      "{\"type\":\"DeclGroup\",\"kind\":\"" ++ kindStr ++ "\"" ++ declsJson ++ "}"
    },
    Ast.Recovery(recovery) => {
      let (kindStr, text) = match (recovery.kind) {
        Ast.UnknownTopLevel(raw) => ("UnknownTopLevel", raw),
        Ast.InvalidTopLevel(raw) => ("InvalidTopLevel", raw),
      }
      "{\"type\":\"Recovery\",\"kind\":\"" ++ kindStr ++ "\",\"text\":\""
      ++ escapeJson(text) ++ "\",\"expected\":\""
      ++ expectedKindToString(recovery.expected) ++ "\"}"
    },
    _ => "{\"type\":\"Other\"}"
  }
}

let programToJson = (program: Ast.Program) => {
  let items = List.map(topItemToJson, program.items)
  let itemsJson = "[" ++ joinStrings(",", items) ++ "]"
  "{\"core\":" ++ (if (program.core) { "true" } else { "false" }) ++ 
  ",\"items\":" ++ itemsJson ++ "}"
}

let nodeTypesToJson = (nodeTypes: Map.Map<Number, Types.Type>) => {
  let pairs = Map.toList(nodeTypes)
  let items = List.map(
    ((id, ty)) => {
      let typeStr = Types.typeToString(ty)
      "{\"id\":" ++ toString(id) ++ ",\"type\":\"" ++ escapeJson(typeStr) ++ "\"}"
    },
    pairs
  )
  "[" ++ joinStrings(",", items) ++ "]"
}

let topBindingsToJson = (bindings: Map.Map<String, Types.Scheme>) => {
  let pairs = Map.toList(bindings)
  let items = List.map(
    ((name, _scheme)) => {
      "{\"name\":\"" ++ escapeJson(name) ++ "\",\"type\":\"<inferred>\"}"
    },
    pairs
  )
  "[" ++ joinStrings(",", items) ++ "]"
}

let virtualArtifactToJson = (artifact: Formatter.VirtualArtifact) => {
  "{\"kind\":\"" ++ escapeJson(artifact.kind) ++ "\"," ++
  "\"text\":\"" ++ escapeJson(artifact.text) ++ "\"," ++
  "\"start\":" ++ toString(artifact.start) ++ "," ++
  "\"end\":" ++ toString(artifact.end) ++ "," ++
  "\"reason\":\"" ++ escapeJson(artifact.reason) ++ "\"}"
}

let virtualArtifactsToJson = (artifacts: List<Formatter.VirtualArtifact>) =>
  "[" ++ joinStrings(",", List.map(virtualArtifactToJson, artifacts)) ++ "]"

let parserRecoveryToJson = (recovery: Parser.MissingSemicolonRecovery) => {
  "{\"kind\":\"missingSemicolon\"," ++
  "\"text\":\"" ++ escapeJson(recovery.text) ++ "\"," ++
  "\"start\":" ++ toString(recovery.start) ++ "," ++
  "\"end\":" ++ toString(recovery.end) ++ "," ++
  "\"line\":" ++ toString(recovery.line) ++ "," ++
  "\"col\":" ++ toString(recovery.col) ++ "," ++
  "\"reason\":\"" ++ escapeJson(recovery.reason) ++ "\"}"
}

let errorClueToJson = (clue: Error.ErrorClue) =>
  match (clue) {
    Error.Expected(text) =>
      "{\"kind\":\"Expected\",\"text\":\"" ++ escapeJson(text) ++ "\"}",
    Error.Received(text) =>
      "{\"kind\":\"Received\",\"text\":\"" ++ escapeJson(text) ++ "\"}",
    Error.Incomplete(text) =>
      "{\"kind\":\"Incomplete\",\"text\":\"" ++ escapeJson(text) ++ "\"}",
    Error.Note(text) =>
      "{\"kind\":\"Note\",\"text\":\"" ++ escapeJson(text) ++ "\"}",
    Error.Hint(text) =>
      "{\"kind\":\"Hint\",\"text\":\"" ++ escapeJson(text) ++ "\"}",
  }

let errorStageToString = (stage: Error.Stage) =>
  match (stage) {
    Error.Lexing => "Lexing",
    Error.Parsing => "Parsing",
    Error.Lowering => "Lowering",
    Error.TypeInference => "TypeInference",
  }

let compilerErrorToJson = (err: Error.CompilerError) => {
  let clues = "[" ++ joinStrings(",", List.map(errorClueToJson, err.clues)) ++ "]"
  "{\"stage\":\"" ++ errorStageToString(err.stage) ++ "\"," ++
  "\"message\":\"" ++ escapeJson(err.message) ++ "\"," ++
  "\"span\":{\"line\":" ++ toString(err.span.line) ++
  ",\"col\":" ++ toString(err.span.col) ++
  ",\"start\":" ++ toString(err.span.start) ++
  ",\"end\":" ++ toString(err.span.end) ++ "}," ++
  "\"clues\":" ++ clues ++ "}"
}

let topLevelRecoveryToJson = (item: Ast.TopItem) =>
  match (item) {
    Ast.Recovery(recovery) => {
      let (kind, text) = match (recovery.kind) {
        Ast.UnknownTopLevel(raw) => ("UnknownTopLevel", raw),
        Ast.InvalidTopLevel(raw) => ("InvalidTopLevel", raw),
      }
      Some(
        "{\"kind\":\"" ++ kind ++ "\"," ++
        "\"text\":\"" ++ escapeJson(text) ++ "\"," ++
        "\"expected\":\"" ++ expectedKindToString(recovery.expected) ++ "\"," ++
        "\"span\":{\"line\":" ++ toString(recovery.node.span.line) ++
        ",\"col\":" ++ toString(recovery.node.span.col) ++
        ",\"start\":" ++ toString(recovery.node.span.start) ++
        ",\"end\":" ++ toString(recovery.node.span.end) ++ "}}",
      )
    },
    _ => None,
  }

let recoveryBundleToJson = (
  parseResult: Parser.ParseResult,
  diagnostics: List<Error.CompilerError>,
) => {
  let semis = "[" ++
    joinStrings(",", List.map(parserRecoveryToJson, parseResult.missingSemicolons)) ++ "]"
  let topLevel = "[" ++
    joinStrings(
      ",",
      List.filterMap(topLevelRecoveryToJson, parseResult.program.items),
    ) ++ "]"
  let diag = "[" ++ joinStrings(",", List.map(compilerErrorToJson, diagnostics)) ++ "]"
  "{\"missingSemicolons\":" ++ semis ++
  ",\"topLevel\":" ++ topLevel ++
  ",\"diagnostics\":" ++ diag ++ "}"
}

// Global store for the last compilation (for querying nodes by ID)
let mut lastStore: Option<NS.NodeStore> = None

provide let compileToJson = (source: String) => {
  Error.clearErrors()
  Error.setPanicMode(false)

  // Tokenize
  let tokens = Lexer.lex(source)
  let tokensJson = "[" ++ joinStrings(",", List.map(tokenToJson, tokens)) ++ "]"
  
  // Parse
  let parseResult = Parser.parseResult(source)
  let parsed = parseResult.program
  
  // Index the parsed (surface) AST into a NodeStore
  let surfaceStore = Indexer.indexProgram(parsed)
  let surfaceStoreJson = NS.storeToJson(surfaceStore)
  
  // Lower
  let lowered = Lower.lowerProgram(parsed)
  let formattedResult = Formatter.formatResultWithMode(source, Formatter.Real)
  let virtualResult = Formatter.formatResultWithMode(source, Formatter.Virtual)
  
  // Index the lowered AST into a NodeStore
  let loweredStore = Indexer.indexProgram(lowered)
  lastStore = Some(loweredStore)
  let loweredStoreJson = NS.storeToJson(loweredStore)
  let recoveryJson = recoveryBundleToJson(parseResult, Error.getErrors())
  
  "{\"tokens\":" ++ tokensJson ++
  ",\"surfaceNodeStore\":" ++ surfaceStoreJson ++
  ",\"loweredNodeStore\":" ++ loweredStoreJson ++
  ",\"recovery\":" ++ recoveryJson ++
  ",\"formatted\":\"" ++ escapeJson(formattedResult.text) ++ "\"" ++
  ",\"formattedVirtual\":\"" ++ escapeJson(virtualResult.text) ++ "\"" ++
  ",\"formattedVirtualArtifacts\":" ++ virtualArtifactsToJson(virtualResult.virtualArtifacts) ++ "}"
}

// Query a node by ID from the last compilation
provide let getNodeJson = (id: Number) => {
  match (lastStore) {
    None => "{\"error\":\"No compilation available\"}",
    Some(store) => {
      match (NS.getNode(store, id)) {
        None => "{\"error\":\"Node not found\"}",
        Some(node) => NS.nodeInfoToJson(node)
      }
    }
  }
}

let main = () => {
  match (Process.argv()) {
    Err(_) => print("{\"success\":false,\"error\":\"Failed to read argv\"}"),
    Ok(args) => {
      let argCount = Array.length(args)
      if (argCount < 2) {
        print("{\"success\":false,\"error\":\"Usage: grain --include-dirs src src/api/api.gr -- <file.wm>\"}")
      } else {
        let filePath = Array.get(1, args)
        match (Fs.Utf8.readFile(Path.fromString(filePath))) {
          Err(_) => print("{\"success\":false,\"error\":\"Failed to read file: " ++ escapeJson(filePath) ++ "\"}"),
          Ok(source) => print(compileToJson(source))
        }
      }
    }
  }
}

main()
