module Api

from "array" include Array
from "list" include List
from "map" include Map
from "string" include String
from "wasi/process" include Process
from "fs" include Fs
from "path" include Path

from "../core/surface_ast.gr" include SurfaceAst
from "../core/analysis.gr" include Analysis
from "../core/types.gr" include Types
from "../core/source.gr" include Source
from "../core/error.gr" include Error
from "../frontend/lexer.gr" include Lexer
from "../frontend/lower.gr" include Lower
from "../frontend/parser.gr" include Parser
from "../frontend/lower.gr" include Lower
from "../frontend/frontend.gr" include Frontend
from "./core_indexer.gr" include CoreIndexer
from "../frontend/formatter.gr" include Formatter
from "./nodestore.gr" include NodeStore as NS
from "./indexer.gr" include Indexer

let escapeJson = (s: String) => {
  // Must escape backslashes FIRST to avoid double-escaping
  let step1 = String.replaceAll("\\", "\\\\", s)
  let step2 = String.replaceAll("\"", "\\\"", step1)
  let step3 = String.replaceAll("\n", "\\n", step2)
  let step4 = String.replaceAll("\r", "\\r", step3)
  String.replaceAll("\t", "\\t", step4)
}

let tokenToJson = (tok: Lexer.Token) => {
  // Get the actual token kind name from the lexer
  let kindName = match (tok.kind) {
    Lexer.Wildcard => "Wildcard",
    Lexer.LitName(_) => "LitName",
    Lexer.ConstructorTok(_) => "ConstructorTok",
    Lexer.LitNum(_) => "LitNum",
    Lexer.LitString(_) => "LitString",
    Lexer.LitChar(_) => "LitChar",
    Lexer.LitBool(_) => "LitBool",
    Lexer.KwVar => "KwVar",
    Lexer.KwAllErrors => "KwAllErrors",
    Lexer.LParen => "LParen",
    Lexer.RParen => "RParen",
    Lexer.LBrace => "LBrace",
    Lexer.RBrace => "RBrace",
    Lexer.FatArrow => "FatArrow",
    Lexer.Question => "Question",
    Lexer.Pipe => "Pipe",
    Lexer.DPipe => "DPipe",
    Lexer.SemiColon => "SemiColon",
    Lexer.Comma => "Comma",
    Lexer.Colon => "Colon",
    Lexer.PipeArrow => "PipeArrow",
    Lexer.Slash => "Slash",
    Lexer.DSlash => "DSlash",
    Lexer.LineComment(_) => "LineComment",
    Lexer.Opaque(_) => "Opaque",
    Lexer.Arrow => "Arrow",
    Lexer.Period => "Period",
    Lexer.DotBrace => "DotBrace",
    Lexer.DPeriod => "DPeriod",
    Lexer.Eq => "Eq",
    Lexer.EqEq => "EqEq",
    Lexer.Plus => "Plus",
    Lexer.DPlus => "DPlus",
    Lexer.Dash => "Dash",
    Lexer.DDash => "DDash",
    Lexer.Directive => "Directive",
    Lexer.EOF => "EOF",
  }
  let kindStr = Lexer.tokenKindToString(tok.kind)
  let spanJson = "{\"line\":" ++ toString(tok.span.line) ++ 
                 ",\"col\":" ++ toString(tok.span.col) ++ 
                 ",\"start\":" ++ toString(tok.span.start) ++ 
                 ",\"end\":" ++ toString(tok.span.end) ++ "}"
  let mateJson = match (tok.mate) {
    None => "null",
    Some(m) => toString(m),
  }
  "{\"kind\":\"" ++ escapeJson(kindName) ++ "\"," ++
  "\"text\":\"" ++ escapeJson(kindStr) ++ "\"," ++
  "\"span\":" ++ spanJson ++ "," ++
  "\"mate\":" ++ mateJson ++ "}"
}

let expectedTopItemKindToString = (kind: SurfaceAst.ExpectedTopItemKind) => {
  match (kind) {
    SurfaceAst.TopItemAny => "AnyTopItem",
    SurfaceAst.TopItemDeclGroup => "DeclGroup",
    SurfaceAst.TopItemImport => "Import",
    SurfaceAst.TopItemReexport => "Reexport",
    SurfaceAst.TopItemExport => "Export",
    SurfaceAst.TopItemDirective => "Directive",
    SurfaceAst.TopItemTrivia => "Trivia",
    SurfaceAst.TopItemMark => "Mark",
  }
}

let expectedKindToString = (kind: SurfaceAst.ExpectedKind) => {
  match (kind) {
    SurfaceAst.ExpectTopItem(tk) => "TopItem(" ++ expectedTopItemKindToString(tk) ++ ")",
    SurfaceAst.ExpectExpr => "Expr",
    SurfaceAst.ExpectPattern => "Pattern",
    SurfaceAst.ExpectTypeExpr => "TypeExpr",
    SurfaceAst.ExpectToken => "Token",
    SurfaceAst.ExpectBlock => "Block",
  }
}

let rec joinStrings = (sep: String, items: List<String>) => {
  match (items) {
    [] => "",
    [single] => single,
    [first, ...rest] => first ++ sep ++ joinStrings(sep, rest)
  }
}

let tokensToJson = (tokens: List<Lexer.Token>) => {
  let items = List.map(tokenToJson, tokens)
  "[" ++ joinStrings(",", items) ++ "]"
}

let rec exprToJson = (expr: SurfaceAst.Expr, depth: Number) => {
  if (depth > 8) {
    "{\"kind\":\"MaxDepth\",\"id\":" ++ toString(expr.node.id) ++ "}"
  } else {
    let kindName = match (expr.kind) {
      SurfaceAst.Lit(SurfaceAst.Int(n)) => "Lit(Int(" ++ toString(n) ++ "))",
      SurfaceAst.Lit(SurfaceAst.Bool(b)) => "Lit(Bool(" ++ toString(b) ++ "))",
      SurfaceAst.Lit(SurfaceAst.Str(s)) => "Lit(Str)",
      SurfaceAst.Lit(SurfaceAst.Char(_)) => "Lit(Char)",
      SurfaceAst.Lit(SurfaceAst.Unit) => "Lit(Unit)",
      SurfaceAst.Lit(SurfaceAst.Byte(_)) => "Lit(Byte)",
      SurfaceAst.Ident(name) => "Ident(" ++ escapeJson(name.text) ++ ")",
      SurfaceAst.Fn(_) => "Fn",
      SurfaceAst.Match(_) => "Match",
      SurfaceAst.Apply(_, _) => "Apply",
      SurfaceAst.InfixChain(_) => "InfixChain",
      SurfaceAst.Postfix(_) => "Postfix",
      SurfaceAst.Block(_) => "Block",
      SurfaceAst.Paren(_) => "Paren",
      SurfaceAst.Tuple(_) => "Tuple",
      SurfaceAst.RecordLit(_) => "RecordLit",
      SurfaceAst.Seq(_) => "Seq",
      SurfaceAst.Hole(_) => "Hole",
      SurfaceAst.If(_, _, _) => "If",
      SurfaceAst.Let(_, _) => "Let",
      SurfaceAst.Assign(_) => "Assign"
    }
    
    let childrenJson = match (expr.kind) {
      SurfaceAst.Block(block) => {
        let bodyJson = exprToJson(block.body, depth + 1)
        ",\"children\":[" ++ bodyJson ++ "]"
      },
      SurfaceAst.Fn(fnExpr) => {
        let clauseBodies = List.filterMap(
          (item: SurfaceAst.FnItem) =>
            match (item.kind) {
              SurfaceAst.Clause(clause) => Some(
                exprToJson(
                  { node: clause.body.node, kind: SurfaceAst.Block(clause.body), attach: clause.attach },
                  depth + 1,
                ),
              ),
              _ => None,
            },
          fnExpr.items
        )
        ",\"children\":[" ++ joinStrings(",", clauseBodies) ++ "]"
      },
      SurfaceAst.Match(m) => {
        let scrutineeJson = match (m.scrutinee) {
          None => [],
          Some(s) => [exprToJson(s, depth + 1)],
        }
        let clauseBodies = List.filterMap(
          (item: SurfaceAst.FnItem) =>
            match (item.kind) {
              SurfaceAst.Clause(clause) => Some(
                exprToJson(
                  { node: clause.body.node, kind: SurfaceAst.Block(clause.body), attach: clause.attach },
                  depth + 1,
                ),
              ),
              _ => None,
            },
          m.bundle.items
        )
        let allChildren = List.append(scrutineeJson, clauseBodies)
        ",\"children\":[" ++ joinStrings(",", allChildren) ++ "]"
      },
      SurfaceAst.Apply(callee, arg) => {
        let calleeJson = exprToJson(callee, depth + 1)
        let argJson = exprToJson(arg, depth + 1)
        ",\"children\":[" ++ calleeJson ++ "," ++ argJson ++ "]"
      },
      SurfaceAst.Assign(asg) => {
        let targetJson = exprToJson(asg.target, depth + 1)
        let valueJson = exprToJson(asg.value, depth + 1)
        ",\"children\":[" ++ targetJson ++ "," ++ valueJson ++ "]"
      },
      SurfaceAst.Let(binding, body) => {
        let valueJson = exprToJson(binding.value, depth + 1)
        let bodyJson = exprToJson(body, depth + 1)
        ",\"children\":[" ++ valueJson ++ "," ++ bodyJson ++ "]"
      },
      SurfaceAst.Paren(inner) => ",\"children\":[" ++ exprToJson(inner, depth + 1) ++ "]",
      SurfaceAst.Tuple(exprs) => {
        let tupleExprs = List.map((e) => exprToJson(e, depth + 1), exprs)
        ",\"children\":[" ++ joinStrings(",", tupleExprs) ++ "]"
      },
      SurfaceAst.Seq(exprs) => {
        let seqExprs = List.map((e) => exprToJson(e, depth + 1), exprs)
        ",\"children\":[" ++ joinStrings(",", seqExprs) ++ "]"
      },
      SurfaceAst.InfixChain(chain) => {
        let firstJson = exprToJson(chain.first, depth + 1)
        let restJsons = List.map(((_, e)) => exprToJson(e, depth + 1), chain.rest)
        let allExprs = [firstJson, ...restJsons]
        ",\"children\":[" ++ joinStrings(",", allExprs) ++ "]"
      },
      SurfaceAst.If(cond, thenE, elseE) => {
        let condJson = exprToJson(cond, depth + 1)
        let thenJson = exprToJson(thenE, depth + 1)
        let elseJson = match (elseE) {
          Some(e) => exprToJson(e, depth + 1),
          None => "null"
        }
        ",\"children\":[" ++ condJson ++ "," ++ thenJson ++ "," ++ elseJson ++ "]"
      },
      _ => ""
    }
    
    "{\"id\":" ++ toString(expr.node.id) ++ 
    ",\"kind\":\"" ++ escapeJson(kindName) ++ "\"" ++ 
    ",\"span\":{\"start\":" ++ toString(expr.node.span.start) ++ 
    ",\"end\":" ++ toString(expr.node.span.end) ++ "}" ++
    childrenJson ++ "}"
  }
}

let topItemToJson = (item: SurfaceAst.TopItem) => {
  match (item) {
    SurfaceAst.DeclGroup(dg) => {
      let kindStr = match (dg.kind) {
        SurfaceAst.LetGroup(_) => "LetGroup",
        SurfaceAst.TypeGroup(_) => "TypeGroup",
        SurfaceAst.RecordGroup(_) => "RecordGroup",
        SurfaceAst.OpGroup => "OpGroup",
        SurfaceAst.RuleGroup(_) => "RuleGroup"
      }
      
      // Serialize declarations with their bindings and expressions
      let declsJson = match (dg.kind) {
        SurfaceAst.LetGroup(_) => {
          let declStrs = List.map((decl) => {
            match (decl) {
              SurfaceAst.LetDecl(ld) => {
                let bindingStrs = List.map((b: SurfaceAst.LetBinding) => {
                  let valueJson = exprToJson(b.value, 0)
                  "{\"kind\":\"LetBinding\",\"id\":" ++ toString(b.node.id) ++ 
                  ",\"span\":{\"start\":" ++ toString(b.node.span.start) ++ 
                  ",\"end\":" ++ toString(b.node.span.end) ++ "},\"value\":" ++ valueJson ++ "}"
                }, ld.bindings)
                "{\"kind\":\"LetDecl\",\"bindings\":[" ++ joinStrings(",", bindingStrs) ++ "]}"
              },
              _ => "{}"
            }
          }, dg.decls)
          ",\"decls\":[" ++ joinStrings(",", declStrs) ++ "]"
        },
        SurfaceAst.TypeGroup(_) | SurfaceAst.RecordGroup(_) => {
          let declStrs = List.map((decl) => {
            match (decl) {
              SurfaceAst.TypeDecl(td) => 
                "{\"kind\":\"TypeDecl\",\"id\":" ++ toString(td.node.id) ++ 
                ",\"span\":{\"start\":" ++ toString(td.node.span.start) ++ 
                ",\"end\":" ++ toString(td.node.span.end) ++ 
                "},\"name\":\"" ++ escapeJson(td.name.text) ++ "\"}",
              SurfaceAst.RecordDecl(rd) => 
                "{\"kind\":\"RecordDecl\",\"id\":" ++ toString(rd.node.id) ++ 
                ",\"span\":{\"start\":" ++ toString(rd.node.span.start) ++ 
                ",\"end\":" ++ toString(rd.node.span.end) ++ 
                "},\"name\":\"" ++ escapeJson(rd.name.text) ++ "\"}",
              _ => "{}"
            }
          }, dg.decls)
          ",\"decls\":[" ++ joinStrings(",", declStrs) ++ "]"
        },
        _ => ""
      }
      
      "{\"type\":\"DeclGroup\",\"kind\":\"" ++ kindStr ++ "\"" ++ declsJson ++ "}"
    },
    SurfaceAst.Mark(mark) => {
      let (kindStr, text) = match (mark.kind) {
        SurfaceAst.UnknownTopLevel(raw) => ("UnknownTopLevel", raw),
        SurfaceAst.InvalidTopLevel(raw) => ("InvalidTopLevel", raw),
        SurfaceAst.MissingSemicolon => ("MissingSemicolon", ""),
        SurfaceAst.MissingRBrace => ("MissingRBrace", ""),
      }
      "{\"type\":\"Mark\",\"kind\":\"" ++ kindStr ++ "\",\"text\":\""
      ++ escapeJson(text) ++ "\",\"expected\":\""
      ++ expectedKindToString(mark.expected) ++ "\"}"
    },
    _ => "{\"type\":\"Other\"}"
  }
}

let programToJson = (program: SurfaceAst.Program) => {
  let items = List.map(topItemToJson, program.items)
  let itemsJson = "[" ++ joinStrings(",", items) ++ "]"
  "{\"core\":" ++ (if (program.core) { "true" } else { "false" }) ++ 
  ",\"items\":" ++ itemsJson ++ "}"
}

let nodeTypesToJson = (nodeTypes: Map.Map<Number, Types.Type>) => {
  let pairs = Map.toList(nodeTypes)
  let items = List.map(
    ((id, ty)) => {
      let typeStr = Types.typeToString(ty)
      "{\"id\":" ++ toString(id) ++ ",\"type\":\"" ++ escapeJson(typeStr) ++ "\"}"
    },
    pairs
  )
  "[" ++ joinStrings(",", items) ++ "]"
}

let topBindingsToJson = (bindings: Map.Map<String, Types.Scheme>) => {
  let pairs = Map.toList(bindings)
  let items = List.map(
    ((name, _scheme)) => {
      "{\"name\":\"" ++ escapeJson(name) ++ "\",\"type\":\"<inferred>\"}"
    },
    pairs
  )
  "[" ++ joinStrings(",", items) ++ "]"
}

let virtualArtifactToJson = (artifact: Formatter.VirtualArtifact) => {
  "{\"kind\":\"" ++ escapeJson(artifact.kind) ++ "\"," ++
  "\"text\":\"" ++ escapeJson(artifact.text) ++ "\"," ++
  "\"start\":" ++ toString(artifact.start) ++ "," ++
  "\"end\":" ++ toString(artifact.end) ++ "," ++
  "\"reason\":\"" ++ escapeJson(artifact.reason) ++ "\"}"
}

let virtualArtifactsToJson = (artifacts: List<Formatter.VirtualArtifact>) =>
  "[" ++ joinStrings(",", List.map(virtualArtifactToJson, artifacts)) ++ "]"

let errorClueToJson = (clue: Error.ErrorClue) =>
  match (clue) {
    Error.Expected(text) =>
      "{\"kind\":\"Expected\",\"text\":\"" ++ escapeJson(text) ++ "\"}",
    Error.Received(text) =>
      "{\"kind\":\"Received\",\"text\":\"" ++ escapeJson(text) ++ "\"}",
    Error.Incomplete(text) =>
      "{\"kind\":\"Incomplete\",\"text\":\"" ++ escapeJson(text) ++ "\"}",
    Error.Note(text) =>
      "{\"kind\":\"Note\",\"text\":\"" ++ escapeJson(text) ++ "\"}",
    Error.Hint(text) =>
      "{\"kind\":\"Hint\",\"text\":\"" ++ escapeJson(text) ++ "\"}",
  }

let errorStageToString = (stage: Error.Stage) =>
  match (stage) {
    Error.Lexing => "Lexing",
    Error.Parsing => "Parsing",
    Error.Lowering => "Lowering",
    Error.TypeInference => "TypeInference",
  }

let compilerErrorToJson = (err: Error.CompilerError) => {
  let clues = "[" ++ joinStrings(",", List.map(errorClueToJson, err.clues)) ++ "]"
  "{\"stage\":\"" ++ errorStageToString(err.stage) ++ "\"," ++
  "\"message\":\"" ++ escapeJson(err.message) ++ "\"," ++
  "\"span\":{\"line\":" ++ toString(err.span.line) ++
  ",\"col\":" ++ toString(err.span.col) ++
  ",\"start\":" ++ toString(err.span.start) ++
  ",\"end\":" ++ toString(err.span.end) ++ "}," ++
  "\"clues\":" ++ clues ++ "}"
}

let markToJson = (mark: SurfaceAst.Mark) => {
  let (kind, text) = match (mark.kind) {
    SurfaceAst.UnknownTopLevel(raw) => ("UnknownTopLevel", raw),
    SurfaceAst.InvalidTopLevel(raw) => ("InvalidTopLevel", raw),
    SurfaceAst.MissingSemicolon => ("MissingSemicolon", ""),
    SurfaceAst.MissingRBrace => ("MissingRBrace", ""),
    SurfaceAst.MissingToken(raw) => ("MissingToken", raw),
    SurfaceAst.MissingExpr(raw) => ("MissingExpr", raw),
    SurfaceAst.MissingPattern(raw) => ("MissingPattern", raw),
    SurfaceAst.MissingTypeExpr(raw) => ("MissingTypeExpr", raw),
    SurfaceAst.MissingBlock(raw) => ("MissingBlock", raw),
    SurfaceAst.FormattingMismatch(raw) => ("FormattingMismatch", raw),
  }
  "{\"kind\":\"" ++ kind ++ "\"," ++
  "\"text\":\"" ++ escapeJson(text) ++ "\"," ++
  "\"expected\":\"" ++ expectedKindToString(mark.expected) ++ "\"," ++
  "\"span\":{\"line\":" ++ toString(mark.node.span.line) ++
  ",\"col\":" ++ toString(mark.node.span.col) ++
  ",\"start\":" ++ toString(mark.node.span.start) ++
  ",\"end\":" ++ toString(mark.node.span.end) ++ "}}"
}

let markedErrorToJson = (entry: Error.MarkedError) => {
  "{\"mark\":" ++ markToJson(entry.mark) ++
  ",\"diagnostic\":" ++ compilerErrorToJson(entry.error) ++ "}"
}

let topLevelMarkToJson = (item: SurfaceAst.TopItem) =>
  match (item) {
    SurfaceAst.Mark(mark) => {
      let (kind, text) = match (mark.kind) {
        SurfaceAst.UnknownTopLevel(raw) => ("UnknownTopLevel", raw),
        SurfaceAst.InvalidTopLevel(raw) => ("InvalidTopLevel", raw),
      }
      Some(
        "{\"kind\":\"" ++ kind ++ "\"," ++
        "\"text\":\"" ++ escapeJson(text) ++ "\"," ++
        "\"expected\":\"" ++ expectedKindToString(mark.expected) ++ "\"," ++
        "\"span\":{\"line\":" ++ toString(mark.node.span.line) ++
        ",\"col\":" ++ toString(mark.node.span.col) ++
        ",\"start\":" ++ toString(mark.node.span.start) ++
        ",\"end\":" ++ toString(mark.node.span.end) ++ "}}",
      )
    },
    _ => None,
  }

let markBundleToJson = (
  parseResult: Parser.ParseResult,
  diagnostics: List<Error.CompilerError>,
  marked: List<Error.MarkedError>,
) => {
  let topLevel = "[" ++
    joinStrings(
      ",",
      List.filterMap(topLevelMarkToJson, parseResult.program.items),
    ) ++ "]"
  let diag = "[" ++ joinStrings(",", List.map(compilerErrorToJson, diagnostics)) ++ "]"
  let markedJson = "[" ++ joinStrings(",", List.map(markedErrorToJson, marked)) ++ "]"
  "{\"topLevel\":" ++ topLevel ++
  ",\"diagnostics\":" ++ diag ++
  ",\"entries\":" ++ markedJson ++ "}"
}

// Global store for the last compilation (for querying nodes by ID)
let mut lastStore: Option<NS.NodeStore> = None

provide let compileToJson = (source: String) => {
  Error.clearErrors()
  Error.setPanicMode(false)

  // Tokenize
  let tokens = Lexer.lex(source)
  let tokensJson = "[" ++ joinStrings(",", List.map(tokenToJson, tokens)) ++ "]"
  
  // Parse
  let parseResult = Parser.parseResult(source)
  let parsed = parseResult.program
  
  // Index the parsed (surface) AST into a NodeStore
  let surfaceStore = Indexer.indexProgram(parsed)
  let surfaceStoreJson = NS.storeToJson(surfaceStore)
  
  // Lower
  let lowered = Lower.lowerProgram(parsed)
  let diagnostics = Error.getErrors()
  let markedDiagnostics = Error.getMarkedErrors()
  Error.clearErrors()
  let formattedResult = Formatter.formatResultWithProgramMode(
    parsed,
    source,
    Formatter.Real,
  )
  let virtualResult = Formatter.formatResultWithProgramMode(
    parsed,
    source,
    Formatter.Virtual,
  )
  let fixResult = Formatter.formatResultWithProgramMode(parsed, source, Formatter.Fix)
  let formattedTokens =
    "[" ++ joinStrings(",", List.map(tokenToJson, Lexer.lex(formattedResult.text))) ++ "]"
  let virtualTokens =
    "[" ++ joinStrings(",", List.map(tokenToJson, Lexer.lex(virtualResult.text))) ++ "]"
  let fixTokens =
    "[" ++ joinStrings(",", List.map(tokenToJson, Lexer.lex(fixResult.text))) ++ "]"
  
  // Index the lowered AST into a NodeStore
  let loweredStore = CoreIndexer.indexProgram(lowered)
  lastStore = Some(loweredStore)
  let loweredStoreJson = NS.storeToJson(loweredStore)
  let marksJson = markBundleToJson(parseResult, diagnostics, markedDiagnostics)
  
  "{\"tokens\":" ++ tokensJson ++
  ",\"surfaceNodeStore\":" ++ surfaceStoreJson ++
  ",\"loweredNodeStore\":" ++ loweredStoreJson ++
  ",\"marks\":" ++ marksJson ++
  ",\"formatted\":\"" ++ escapeJson(formattedResult.text) ++ "\"" ++
  ",\"formattedTokens\":" ++ formattedTokens ++
  ",\"formattedVirtual\":\"" ++ escapeJson(virtualResult.text) ++ "\"" ++
  ",\"formattedVirtualTokens\":" ++ virtualTokens ++
  ",\"formattedFix\":\"" ++ escapeJson(fixResult.text) ++ "\"" ++
  ",\"formattedFixTokens\":" ++ fixTokens ++
  ",\"formattedVirtualArtifacts\":" ++ virtualArtifactsToJson(virtualResult.virtualArtifacts) ++ "}"
}

// Query a node by ID from the last compilation
provide let getNodeJson = (id: Number) => {
  match (lastStore) {
    None => "{\"error\":\"No compilation available\"}",
    Some(store) => {
      match (NS.getNode(store, id)) {
        None => "{\"error\":\"Node not found\"}",
        Some(node) => NS.nodeInfoToJson(node)
      }
    }
  }
}

let main = () => {
  match (Process.argv()) {
    Err(_) => print("{\"success\":false,\"error\":\"Failed to read argv\"}"),
    Ok(args) => {
      let argCount = Array.length(args)
      if (argCount < 2) {
        print("{\"success\":false,\"error\":\"Usage: grain --include-dirs src src/api/api.gr -- <file.wm>\"}")
      } else {
        let filePath = Array.get(1, args)
        match (Fs.Utf8.readFile(Path.fromString(filePath))) {
          Err(_) => print("{\"success\":false,\"error\":\"Failed to read file: " ++ escapeJson(filePath) ++ "\"}"),
          Ok(source) => print(compileToJson(source))
        }
      }
    }
  }
}

main()
