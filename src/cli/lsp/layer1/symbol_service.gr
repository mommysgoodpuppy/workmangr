module SymbolService

from "list" include List
from "map" include Map
from "string" include String

from "../../../core/source.gr" include Source
from "../../../core/surface_ast.gr" include SurfaceAst
from "../../../module/module_system.gr" include ModuleSystem
from "../../../frontend/lexer.gr" include Lexer

provide record Definition {
  modulePath: String,
  span: Source.Span,
}

provide record HoverDecl {
  span: Source.Span,
  label: String,
}

let tokenNameAtOffset = (source: String, offset: Number) => {
  let tokens = Lexer.lex(source)
  let rec loopStrict = (remaining: List<Lexer.Token>) =>
    match (remaining) {
      [] => None,
      [tok, ...rest] =>
        if (offset >= tok.span.start && offset < tok.span.end) {
          match (tok.kind) {
            Lexer.LitName(name) => Some(name),
            Lexer.ConstructorTok(name) => Some(name),
            _ => None,
          }
        } else {
          loopStrict(rest)
        },
    }
  match (loopStrict(tokens)) {
    Some(name) => Some(name),
    None => {
      let rec loopBoundary = (remaining: List<Lexer.Token>) =>
        match (remaining) {
          [] => None,
          [tok, ...rest] =>
            if (tok.span.end > tok.span.start && offset == tok.span.end) {
              match (tok.kind) {
                Lexer.LitName(name) => Some(name),
                Lexer.ConstructorTok(name) => Some(name),
                _ => loopBoundary(rest),
              }
            } else {
              loopBoundary(rest)
            },
        }
      loopBoundary(tokens)
    },
  }
}

let tokenAtOffsetWithIndex = (source: String, offset: Number) => {
  let tokens = Lexer.lex(source)
  let rec loopStrict = (remaining: List<Lexer.Token>, idx: Number) =>
    match (remaining) {
      [] => None,
      [tok, ...rest] =>
        if (offset >= tok.span.start && offset < tok.span.end) {
          Some((idx, tok, tokens))
        } else {
          loopStrict(rest, idx + 1)
        },
    }
  match (loopStrict(tokens, 0)) {
    Some(found) => Some(found),
    None => {
      let rec loopBoundary = (remaining: List<Lexer.Token>, idx: Number) =>
        match (remaining) {
          [] => None,
          [tok, ...rest] =>
            if (tok.span.end > tok.span.start && offset == tok.span.end) {
              match (tok.kind) {
                Lexer.LitName(_) | Lexer.ConstructorTok(_) =>
                  Some((idx, tok, tokens)),
                _ => loopBoundary(rest, idx + 1),
              }
            } else {
              loopBoundary(rest, idx + 1)
            },
        }
      loopBoundary(tokens, 0)
    },
  }
}

let rec nth = (items: List<String>, index: Number) =>
  match (items) {
    [] => None,
    [head, ...rest] =>
      if (index <= 0) {
        Some(head)
      } else {
        nth(rest, index - 1)
      },
  }

let explicitImportCount = (program: SurfaceAst.Program) => {
  let rec loop = (items: List<SurfaceAst.TopItem>, count: Number) =>
    match (items) {
      [] => count,
      [item, ...rest] =>
        match (item) {
          SurfaceAst.Import(_) => loop(rest, count + 1),
          _ => loop(rest, count),
        },
    }
  loop(program.items, 0)
}

let rec nthToken = (items: List<Lexer.Token>, index: Number) =>
  match (items) {
    [] => None,
    [head, ...rest] =>
      if (index <= 0) {
        Some(head)
      } else {
        nthToken(rest, index - 1)
      },
  }

let tokenName = (tok: Lexer.Token) =>
  match (tok.kind) {
    Lexer.LitName(name) => Some(name),
    Lexer.ConstructorTok(name) => Some(name),
    _ => None,
  }

let qualifiedNameAtOffset = (source: String, offset: Number) => {
  match (tokenAtOffsetWithIndex(source, offset)) {
    None => None,
    Some((idx, tok, tokens)) => {
      let currentName = tokenName(tok)
      let prev1 = nthToken(tokens, idx - 1)
      let prev2 = nthToken(tokens, idx - 2)
      let next1 = nthToken(tokens, idx + 1)
      let next2 = nthToken(tokens, idx + 2)
      match (currentName) {
        Some(name) =>
          match ((prev1, prev2)) {
            (Some(dotTok), Some(qualifierTok)) =>
              match ((dotTok.kind, tokenName(qualifierTok))) {
                (Lexer.Period, Some(qualifier)) => Some((qualifier, name)),
                _ =>
                  match ((next1, next2)) {
                    (Some(dotTok2), Some(memberTok)) =>
                      match ((dotTok2.kind, tokenName(memberTok))) {
                        (Lexer.Period, Some(member)) => Some((name, member)),
                        _ => None,
                      },
                    _ => None,
                  },
              },
            _ =>
              match ((next1, next2)) {
                (Some(dotTok), Some(memberTok)) =>
                  match ((dotTok.kind, tokenName(memberTok))) {
                    (Lexer.Period, Some(member)) => Some((name, member)),
                    _ => None,
                  },
                _ => None,
              },
          },
        None => None,
      }
    },
  }
}

let rec findInPattern = (
  pattern: SurfaceAst.Pattern,
  name: String,
  modulePath: String,
) => {
  match (pattern.kind) {
    SurfaceAst.Var(n) when n.text == name => Some({ modulePath, span: n.node.span }: Definition),
    SurfaceAst.Pin(n) when n.text == name => Some({ modulePath, span: n.node.span }: Definition),
    SurfaceAst.Tuple(items) => {
      let rec loop = (remaining: List<SurfaceAst.Pattern>) =>
        match (remaining) {
          [] => None,
          [head, ...rest] => match (findInPattern(head, name, modulePath)) {
            Some(found) => Some(found),
            None => loop(rest),
          },
        }
      loop(items)
    },
    SurfaceAst.List(items, restOpt) => {
      let rec loop = (remaining: List<SurfaceAst.Pattern>) =>
        match (remaining) {
          [] => None,
          [head, ...rest] => match (findInPattern(head, name, modulePath)) {
            Some(found) => Some(found),
            None => loop(rest),
          },
        }
      match (loop(items)) {
        Some(found) => Some(found),
        None => match (restOpt) {
          Some(restPat) => findInPattern(restPat, name, modulePath),
          None => None,
        },
      }
    },
    _ => None,
  }
}

let findDefinitionInDecl = (
  decl: SurfaceAst.Decl,
  name: String,
  modulePath: String,
) => {
  match (decl) {
    SurfaceAst.LetDecl(ld) => {
      let rec loop = (remaining: List<SurfaceAst.LetBinding>) =>
        match (remaining) {
          [] => None,
          [binding, ...rest] => match (findInPattern(binding.name, name, modulePath)) {
            Some(found) => Some(found),
            None => loop(rest),
          },
        }
      loop(ld.bindings)
    },
    SurfaceAst.TypeDecl(td) => {
      if (td.name.text == name) {
        Some({ modulePath, span: td.name.node.span }: Definition)
      } else {
        match (td.body) {
          SurfaceAst.Alias(_) => None,
          SurfaceAst.Variant(cases, _) => {
            let rec loop = (remaining: List<(SurfaceAst.Name, Option<SurfaceAst.TypeExpr>, Option<SurfaceAst.Annotation>)>) =>
              match (remaining) {
                [] => None,
                [(ctor, _payload, _annotation), ...rest] =>
                  if (ctor.text == name) {
                    Some({ modulePath, span: ctor.node.span }: Definition)
                  } else {
                    loop(rest)
                  },
              }
            loop(cases)
          },
        }
      }
    },
    SurfaceAst.RecordDecl(rd) =>
      if (rd.name.text == name) {
        Some({ modulePath, span: rd.name.node.span }: Definition)
      } else {
        None
      },
    _ => None,
  }
}

let findDefinitionInProgram = (
  modulePath: String,
  program: SurfaceAst.Program,
  name: String,
) => {
  let rec loopTop = (items: List<SurfaceAst.TopItem>) =>
    match (items) {
      [] => None,
      [item, ...rest] =>
        match (item) {
          SurfaceAst.DeclGroup(group) => {
            let rec loopDecls = (decls: List<SurfaceAst.Decl>) =>
              match (decls) {
                [] => None,
                [decl, ...declRest] => match (findDefinitionInDecl(decl, name, modulePath)) {
                  Some(found) => Some(found),
                  None => loopDecls(declRest),
                },
              }
            match (loopDecls(group.decls)) {
              Some(found) => Some(found),
              None => loopTop(rest),
            }
          },
          _ => loopTop(rest),
        },
    }
  loopTop(program.items)
}

let findImportAliasTarget = (
  node: ModuleSystem.ModuleNode,
  aliasName: String,
) => {
  let explicitCount = explicitImportCount(node.program)
  let importCount = List.length(node.imports)
  let pathIndexOffset = if (importCount > explicitCount) {
    importCount - explicitCount
  } else {
    0
  }
  let rec loopTop = (
    items: List<SurfaceAst.TopItem>,
    importIndex: Number,
  ) =>
    match (items) {
      [] => None,
      [item, ...rest] =>
        match (item) {
          SurfaceAst.Import(importDecl) => {
            let next = importIndex + 1
            match (importDecl.alias) {
              Some(alias) when alias.text == aliasName =>
                match (nth(node.imports, importIndex + pathIndexOffset)) {
                  Some(modulePath) => Some({ modulePath, span: alias.node.span }: Definition),
                  None => None,
                },
              _ => loopTop(rest, next),
            }
          },
          _ => loopTop(rest, importIndex),
        },
    }
  loopTop(node.program.items, 0)
}

let findImportAliasModulePath = (
  node: ModuleSystem.ModuleNode,
  aliasName: String,
) => match (findImportAliasTarget(node, aliasName)) {
  Some(found) => Some(found.modulePath),
  None => None,
}

provide let findDefinitionAtOffset = (
  graph: ModuleSystem.ModuleGraph,
  currentModulePath: String,
  source: String,
  offset: Number,
) => {
  match (tokenNameAtOffset(source, offset)) {
    None => None,
    Some(name) => {
      let currentNodeOpt = Map.get(currentModulePath, graph.nodes)
      match (currentNodeOpt) {
        Some(currentNode) => {
          match (qualifiedNameAtOffset(source, offset)) {
            Some((qualifier, memberName)) =>
              match (findImportAliasModulePath(currentNode, qualifier)) {
                Some(targetModule) =>
                  match (Map.get(targetModule, graph.nodes)) {
                    Some(targetNode) =>
                      findDefinitionInProgram(targetNode.id, targetNode.program, memberName),
                    None => None,
                  },
                None => None,
              },
            None =>
              match (findImportAliasTarget(currentNode, name)) {
                Some(found) => Some(found),
                None =>
                  match (findDefinitionInProgram(currentNode.id, currentNode.program, name)) {
                    Some(found) => Some(found),
                    None => {
                      let rec loop = (moduleIds: List<String>) =>
                        match (moduleIds) {
                          [] => None,
                          [moduleId, ...rest] => {
                            if (moduleId == currentNode.id) {
                              loop(rest)
                            } else {
                              match (Map.get(moduleId, graph.nodes)) {
                                Some(node) => match (findDefinitionInProgram(node.id, node.program, name)) {
                                  Some(found) => Some(found),
                                  None => loop(rest),
                                },
                                None => loop(rest),
                              }
                            }
                          },
                        }
                      loop(graph.topo)
                    },
                  },
              },
          }
        },
        None => None,
      }
    },
  }
}

provide let findDefinitionNearOffset = (
  graph: ModuleSystem.ModuleGraph,
  currentModulePath: String,
  source: String,
  offset: Number,
) => {
  let sourceLen = String.length(source)
  let clamp = (value: Number) => {
    if (value < 0) {
      0
    } else if (value > sourceLen) {
      sourceLen
    } else {
      value
    }
  }
  let candidates = [
    clamp(offset),
    clamp(offset - 1),
    clamp(offset + 1),
    clamp(offset - 2),
    clamp(offset + 2),
  ]
  let rec loop = (remaining: List<Number>) =>
    match (remaining) {
      [] => None,
      [candidate, ...rest] =>
        match (findDefinitionAtOffset(graph, currentModulePath, source, candidate)) {
          Some(found) => Some(found),
          None => loop(rest),
        },
    }
  loop(candidates)
}

let declHoverAtOffsetInDecl = (decl: SurfaceAst.Decl, offset: Number) =>
  match (decl) {
    SurfaceAst.TypeDecl(td) => {
      if (offset >= td.name.node.span.start && offset < td.name.node.span.end) {
        Some({ span: td.name.node.span, label: "type " ++ td.name.text }: HoverDecl)
      } else {
        match (td.body) {
          SurfaceAst.Alias(_) => None,
          SurfaceAst.Variant(cases, _) => {
            let rec loop = (remaining: List<(SurfaceAst.Name, Option<SurfaceAst.TypeExpr>, Option<SurfaceAst.Annotation>)>) =>
              match (remaining) {
                [] => None,
                [(ctor, payload, _annotation), ...rest] => {
                  if (offset >= ctor.node.span.start && offset < ctor.node.span.end) {
                    let label = match (payload) {
                      Some(_) => "constructor " ++ ctor.text ++ " : payload -> " ++ td.name.text,
                      None => "constructor " ++ ctor.text ++ " : " ++ td.name.text,
                    }
                    Some({ span: ctor.node.span, label }: HoverDecl)
                  } else {
                    loop(rest)
                  }
                },
              }
            loop(cases)
          },
        }
      }
    },
    _ => None,
  }

provide let hoverDeclAtOffset = (program: SurfaceAst.Program, offset: Number) => {
  let rec loopTop = (items: List<SurfaceAst.TopItem>) =>
    match (items) {
      [] => None,
      [item, ...rest] =>
        match (item) {
          SurfaceAst.DeclGroup(group) => {
            let rec loopDecls = (decls: List<SurfaceAst.Decl>) =>
              match (decls) {
                [] => None,
                [decl, ...declRest] => match (declHoverAtOffsetInDecl(decl, offset)) {
                  Some(found) => Some(found),
                  None => loopDecls(declRest),
                },
              }
            match (loopDecls(group.decls)) {
              Some(found) => Some(found),
              None => loopTop(rest),
            }
          },
          _ => loopTop(rest),
        },
    }
  loopTop(program.items)
}
