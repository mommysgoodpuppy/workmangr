module Inlay

from "array" include Array
from "list" include List
from "map" include Map
from "number" include Number
from "string" include String
from "wasi/time" include Time
from "int64" include Int64
from "float64" include Float64

from "../../core/source.gr" include Source
from "../../core/error.gr" include Error
from "../../core/surface_ast.gr" include SurfaceAst
from "../../core/core_ast.gr" include CoreAst
from "../../core/infer.gr" include Infer
from "../../core/types.gr" include Types
from "../../frontend/parser.gr" include Parser
from "../../frontend/lower.gr" include Lower
from "../../frontend/formatter.gr" include Formatter
from "../../frontend/lexer.gr" include Lexer
from "./layer1/type_display.gr" include TypeDisplay

record Position {
  line: Number,
  character: Number,
}

record InsertChunk {
  anchorOffset: Number,
  virtOffset: Number,
  text: String,
  trailing: Bool,
}

let isWhitespaceOnly = (text: String) => {
  let len = String.length(text)
  let rec loop = (i: Number) => {
    if (i >= len) {
      true
    } else {
      let ch = String.charAt(i, text)
      if (ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r') {
        loop(i + 1)
      } else {
        false
      }
    }
  }
  loop(0)
}

let extractSemicolons = (text: String) => {
  let len = String.length(text)
  let mut i = 0
  let mut out: List<String> = []
  while (i < len) {
    let ch = String.charAt(i, text)
    if (ch == ';') {
      out = [";", ...out]
    }
    i += 1
  }
  Array.join("", Array.fromList(List.reverse(out)))
}

let markInsertionText = (mark: SurfaceAst.Mark) => {
  match (mark.kind) {
    SurfaceAst.MissingExpr(_) => Some("?"),
    SurfaceAst.MissingTypeExpr(_) => Some("?"),
    SurfaceAst.MissingPattern(_) => Some("_"),
    SurfaceAst.MissingSemicolon => Some(";"),
    SurfaceAst.MissingRBrace => Some("}"),
    SurfaceAst.MissingToken(text) => {
      if (text == "identifier") {
        Some("_")
      } else if (text == "=" || text == ":" || text == "=>" || text == "}") {
        Some(text)
      } else {
        None
      }
    },
    _ => None,
  }
}

let tokenIsIgnorable = (tok: Lexer.Token) => match (tok.kind) {
  Lexer.LineComment(_) => true,
  Lexer.Opaque(_) => true,
  Lexer.EOF => true,
  _ => false,
}

let commentSpans = (source: String) => {
  let tokens = Lexer.lex(source)
  List.filterMap((tok: Lexer.Token) => match (tok.kind) {
    Lexer.LineComment(_) => Some((tok.span.start, tok.span.end)),
    _ => None,
  }, tokens)
}

let insideComment = (offset: Number, spans: List<(Number, Number)>) => {
  let rec check = (items) => match (items) {
    [] => false,
    [(s, e), ...rest] => {
      if (offset >= s && offset < e) {
        true
      } else {
        check(rest)
      }
    },
  }
  check(spans)
}

let tokensEqual = (a: Lexer.Token, b: Lexer.Token) => a.kind == b.kind

let lastNonEmptyLineEndOffset = (source: String) => {
  let len = String.length(source)
  let mut idx = 0
  let mut lineStart = 0
  let mut hasContent = false
  let mut lastEnd = 0
  while (idx < len) {
    let ch = String.charAt(idx, source)
    if (ch == '\n') {
      if (hasContent) {
        lastEnd = idx
      }
      lineStart = idx + 1
      hasContent = false
    } else if (ch != ' ' && ch != '\t' && ch != '\r') {
      hasContent = true
    }
    idx += 1
  }
  if (hasContent) {
    len
  } else if (lineStart > 0) {
    lineStart - 1
  } else {
    0
  }
}

let lastNewlineIndex = (text: String) => {
  let len = String.length(text)
  let mut i = 0
  let mut last = -1
  while (i < len) {
    if (String.charAt(i, text) == '\n') {
      last = i
    }
    i += 1
  }
  last
}

let countNewlines = (text: String) => {
  let len = String.length(text)
  let mut i = 0
  let mut count = 0
  while (i < len) {
    if (String.charAt(i, text) == '\n') {
      count += 1
    }
    i += 1
  }
  count
}

let containsSemicolonOrRBrace = (text: String) => {
  let len = String.length(text)
  let mut i = 0
  let mut found = false
  while (i < len && !found) {
    let ch = String.charAt(i, text)
    if (ch == ';' || ch == '}') {
      found = true
    } else {
      i += 1
    }
  }
  found
}

let splitInlineAndTrailing = (text: String) => {
  match (String.indexOf("\n", text)) {
    None => (text, ""),
    Some(idx) => {
      let inlinePart = String.slice(0, end=idx, text)
      let len = String.length(text)
      let lastNl = lastNewlineIndex(text)
      let trailingPart = if (lastNl >= 0 && lastNl + 1 < len) {
        String.slice(lastNl + 1, end=len, text)
      } else {
        ""
      }
      (inlinePart, trailingPart)
    },
  }
}

let splitChunkTexts = (texts: List<String>) => {
  let rec loop = (
    items: List<String>,
    inlineAcc: List<String>,
    trailingAcc: List<String>,
  ) =>
    match (items) {
      [] => (List.reverse(inlineAcc), List.reverse(trailingAcc)),
      [t, ...rest] => {
        let (inlinePart, trailingPart) = splitInlineAndTrailing(t)
        let nextInline = if (String.length(inlinePart) > 0) {
          [inlinePart, ...inlineAcc]
        } else {
          inlineAcc
        }
        let nextTrailing = if (
          String.length(trailingPart) > 0
          && containsSemicolonOrRBrace(trailingPart)
        ) {
          [trailingPart, ...trailingAcc]
        } else {
          trailingAcc
        }
        loop(rest, nextInline, nextTrailing)
      },
    }
  loop(texts, [], [])
}

let joinNonEmpty = (parts: List<String>) =>
  Array.join(
    "",
    Array.fromList(List.filter(s => String.length(s) > 0, parts))
  )

let chunksHaveNonWhitespace = (chunks: List<InsertChunk>) => {
  let rec loop = (items: List<InsertChunk>) =>
    match (items) {
      [] => false,
      [chunk, ...rest] => if (!isWhitespaceOnly(chunk.text)) {
        true
      } else {
        loop(rest)
      },
    }
  loop(chunks)
}

let nowNs = () =>
  match (Time.monotonicTime()) {
    Ok(t) => t,
    Err(_) => 0L,
  }

let nsToMs = (startNs: Int64, endNs: Int64) =>
  Float64.fromNumber((Int64.toNumber(endNs) - Int64.toNumber(startNs)) / 1000000)

let maybeLogTiming = (
  timingPrefix: Option<String>,
  phase: String,
  startNs: Int64,
  endNs: Int64,
) =>
  match (timingPrefix) {
    Some(prefix) =>
      print(
        "[InlayTiming] "
          ++ prefix
          ++ "/"
          ++ phase
          ++ ": "
          ++ toString(nsToMs(startNs, endNs))
          ++ "ms"
      ),
    None => void,
  }

let offsetToPosition = (source: String, offset: Number) => {
  let lc = Source.offsetToLineCol(source, offset)
  { line: lc.line - 1, character: lc.col }
}

let escapeJsonText = (s: String) => {
  let step1 = String.replaceAll("\\", "\\\\", s)
  let step2 = String.replaceAll("\"", "\\\"", step1)
  let step3 = String.replaceAll("\n", "\\n", step2)
  let step4 = String.replaceAll("\r", "\\r", step3)
  String.replaceAll("\t", "\\t", step4)
}

let spanToEndPosition = (span: Source.Span) => {
  let line0 = if (span.line > 0) {
    span.line - 1
  } else {
    0
  }
  let startCol0 = if (span.col > 0) {
    span.col - 1
  } else {
    0
  }
  let width = if (span.end > span.start) {
    span.end - span.start
  } else {
    0
  }
  { line: line0, character: startCol0 + width }
}

let inRangeByOffset = (
  span: Source.Span,
  rangeStart: Number,
  rangeEnd: Number,
) => {
  let pos = if (span.end > span.start) {
    span.end
  } else {
    span.start
  }
  pos >= rangeStart && pos <= rangeEnd
}

let lookupNameTypeHint = (
  infer: Infer.InferState,
  name: CoreAst.Name,
) => match (Map.get(name.node.id, infer.nodeTypes)) {
  Some(ty) => {
    let rendered = TypeDisplay.render(Types.applySubstType(infer.subst, ty))
    Some((name.node.span, ": " ++ rendered))
  },
  None => None,
}

let rec typeInlaysFromExpr = (
  expr: CoreAst.Expr,
  infer: Infer.InferState,
  rangeStart: Number,
  rangeEnd: Number,
) => match (expr.kind) {
  CoreAst.Let(binding, body) => {
    let fromBinding = if (binding.annotation == None) {
      match (binding.name.kind) {
        CoreAst.Var(name) | CoreAst.Pin(name) =>
          match (lookupNameTypeHint(infer, name)) {
            Some((span, label)) when inRangeByOffset(span, rangeStart, rangeEnd) =>
              [
                "{\"position\":{\"line\":"
                  ++ toString(spanToEndPosition(span).line)
                  ++ ",\"character\":"
                  ++ toString(spanToEndPosition(span).character)
                  ++ "},\"label\":\""
                  ++ escapeJsonText(label)
                  ++ "\",\"kind\":1,\"paddingLeft\":true,\"paddingRight\":false}",
              ],
            _ => [],
          },
        _ => [],
      }
    } else {
      []
    }
    List.append(
      fromBinding,
      List.append(
        typeInlaysFromExpr(binding.value, infer, rangeStart, rangeEnd),
        typeInlaysFromExpr(body, infer, rangeStart, rangeEnd)
      )
    )
  },
  CoreAst.Apply(callee, arg) =>
    List.append(
      typeInlaysFromExpr(callee, infer, rangeStart, rangeEnd),
      typeInlaysFromExpr(arg, infer, rangeStart, rangeEnd)
    ),
  CoreAst.Fn(fnExpr) =>
    List.flatten(
      List.map((item: CoreAst.FnItem) => match (item.kind) {
        CoreAst.Clause(clause) =>
          List.append(
            typeInlaysFromExpr(clause.body, infer, rangeStart, rangeEnd),
            match (clause.guard) {
              Some(guardExpr) => typeInlaysFromExpr(guardExpr, infer, rangeStart, rangeEnd),
              None => [],
            }
          ),
        _ => [],
      }, fnExpr.items)
    ),
  CoreAst.If(cond, thenExpr, elseOpt) =>
    List.append(
      typeInlaysFromExpr(cond, infer, rangeStart, rangeEnd),
      List.append(
        typeInlaysFromExpr(thenExpr, infer, rangeStart, rangeEnd),
        match (elseOpt) {
          Some(elseExpr) => typeInlaysFromExpr(elseExpr, infer, rangeStart, rangeEnd),
          None => [],
        }
      )
    ),
  CoreAst.Tuple(items) =>
    List.flatten(List.map(item => typeInlaysFromExpr(item, infer, rangeStart, rangeEnd), items)),
  CoreAst.RecordLit(items) =>
    List.flatten(
      List.map((item: CoreAst.RecordItem) => match (item) {
        CoreAst.Field(_, valueExpr) => typeInlaysFromExpr(valueExpr, infer, rangeStart, rangeEnd),
        CoreAst.Spread(valueExpr) => typeInlaysFromExpr(valueExpr, infer, rangeStart, rangeEnd),
      }, items)
    ),
  CoreAst.Mark(_, inner) => typeInlaysFromExpr(inner, infer, rangeStart, rangeEnd),
  _ => []
}

let typeInlaysFromLoweredProgram = (
  program: CoreAst.Program,
  infer: Infer.InferState,
  rangeStart: Number,
  rangeEnd: Number,
) => {
  List.flatten(List.map((item: CoreAst.TopItem) => match (item) {
    CoreAst.DeclGroup(group) =>
      List.flatten(List.map((decl: CoreAst.Decl) => match (decl) {
        CoreAst.LetDecl(letDecl) =>
          List.flatten(List.map((binding: CoreAst.LetBinding) => {
            let bindingHint = if (binding.annotation == None) {
              match (binding.name.kind) {
                CoreAst.Var(name) | CoreAst.Pin(name) =>
                  match (lookupNameTypeHint(infer, name)) {
                    Some((span, label)) when inRangeByOffset(span, rangeStart, rangeEnd) =>
                      [
                        "{\"position\":{\"line\":"
                          ++ toString(spanToEndPosition(span).line)
                          ++ ",\"character\":"
                          ++ toString(spanToEndPosition(span).character)
                          ++ "},\"label\":\""
                          ++ escapeJsonText(label)
                          ++ "\",\"kind\":1,\"paddingLeft\":true,\"paddingRight\":false}",
                      ],
                    _ => [],
                  },
                _ => [],
              }
            } else {
              []
            }
            List.append(
              bindingHint,
              typeInlaysFromExpr(binding.value, infer, rangeStart, rangeEnd)
            )
          }, letDecl.bindings)),
        _ => [],
      }, group.decls)),
    _ => [],
  }, program.items))
}

provide let typeInlayHintsFromLoweredProgram = (
  program: CoreAst.Program,
  infer: Infer.InferState,
  rangeStart: Number,
  rangeEnd: Number,
) => {
  let hints = typeInlaysFromLoweredProgram(program, infer, rangeStart, rangeEnd)
  "[" ++ Array.join(",", Array.fromList(hints)) ++ "]"
}

let applyInsertionsToSource = (source: String, inserts: List<InsertChunk>) => {
  let grouped = Map.make()
  let rec add = (items: List<InsertChunk>) => match (items) {
    [] => void,
    [chunk, ...rest] => {
      let offset = chunk.anchorOffset
      let existing = match (Map.get(offset, grouped)) {
        Some(list) => list,
        None => [],
      }
      Map.set(offset, [chunk.text, ...existing], grouped)
      add(rest)
    },
  }
  add(inserts)
  let len = String.length(source)
  let mut i = 0
  let mut out: List<String> = []
  while (i <= len) {
    let insertsAt = match (Map.get(i, grouped)) {
      Some(list) => List.reverse(list),
      None => [],
    }
    List.forEach((text: String) => {
      out = [text, ...out]
    }, insertsAt)
    if (i < len) {
      out = [toString(String.charAt(i, source)), ...out]
    }
    i += 1
  }
  Array.join("", Array.fromList(List.reverse(out)))
}

let virtualInsertionsFromDiff = (source: String, virtualText: String) => {
  let srcTokens = List.filter(t => !tokenIsIgnorable(t), Lexer.lex(source))
  let virtTokens = List.filter(
    t => !tokenIsIgnorable(t),
    Lexer.lex(virtualText)
  )
  let srcArr = Array.fromList(srcTokens)
  let virtArr = Array.fromList(virtTokens)
  let n = Array.length(srcArr)
  let m = Array.length(virtArr)
  let cols = m + 1
  let dp = Array.make((n + 1) * (m + 1), 0)
  let idx = (i: Number, j: Number) => i * cols + j
  let mut i = n - 1
  while (i >= 0) {
    let mut j = m - 1
    while (j >= 0) {
      let a = Array.get(i, srcArr)
      let b = Array.get(j, virtArr)
      let value = if (tokensEqual(a, b)) {
        1 + Array.get(idx(i + 1, j + 1), dp)
      } else {
        let down = Array.get(idx(i + 1, j), dp)
        let right = Array.get(idx(i, j + 1), dp)
        if (down >= right) {
          down
        } else {
          right
        }
      }
      Array.set(idx(i, j), value, dp)
      j -= 1
    }
    i -= 1
  }

  let mut matches: List<(Number, Number, Number, Number)> = []
  let mut si = 0
  let mut vi = 0
  while (si < n && vi < m) {
    let a = Array.get(si, srcArr)
    let b = Array.get(vi, virtArr)
    if (tokensEqual(a, b)) {
      matches = [
        (a.span.start, a.span.end, b.span.start, b.span.end),
        ...matches
      ]
      si += 1
      vi += 1
    } else {
      let nextRight = Array.get(idx(si, vi + 1), dp)
      let nextDown = Array.get(idx(si + 1, vi), dp)
      if (nextRight >= nextDown) {
        vi += 1
      } else {
        si += 1
      }
    }
  }

  let orderedMatches = List.reverse(matches)
  let trailingAnchor = lastNonEmptyLineEndOffset(source)
  let srcLen = String.length(source)
  let virtLen = String.length(virtualText)

  let emitGapInsertions = (
    srcStart: Number,
    srcEnd: Number,
    virtStart: Number,
    virtEnd: Number,
  ) => {
    if (virtEnd <= virtStart) {
      []
    } else {
      let sourceGap = if (srcEnd > srcStart) {
        String.slice(srcStart, end=srcEnd, source)
      } else {
        ""
      }
      let virtGap = String.slice(virtStart, end=virtEnd, virtualText)
      let srcGapLen = String.length(sourceGap)
      let virtGapLen = String.length(virtGap)
      let mut si = 0
      let mut vi = 0
      let mut out: List<InsertChunk> = []
      while (si < srcGapLen && vi < virtGapLen) {
        let sc = String.charAt(si, sourceGap)
        let vc = String.charAt(vi, virtGap)
        if (sc == vc) {
          si += 1
          vi += 1
        } else {
          let start = vi
          let mut vj = vi
          while (vj < virtGapLen && String.charAt(vj, virtGap) != sc) {
            vj += 1
          }
          let text = if (vj > start) {
            String.slice(start, end=vj, virtGap)
          } else {
            ""
          }
          if (String.length(text) > 0) {
            let anchor = srcStart + si
            let trailingFlag = anchor >= trailingAnchor
            out = [
              {
                anchorOffset: anchor,
                virtOffset: virtStart + start,
                text,
                trailing: trailingFlag,
              },
              ...out
            ]
          }
          vi = vj
          if (vj >= virtGapLen) {
            vi = virtGapLen
          }
        }
      }
      if (vi < virtGapLen) {
        let text = String.slice(vi, end=virtGapLen, virtGap)
        if (String.length(text) > 0) {
          let anchor = srcStart + si
          let trailingFlag = anchor >= trailingAnchor
          out = [
            {
              anchorOffset: anchor,
              virtOffset: virtStart + vi,
              text,
              trailing: trailingFlag,
            },
            ...out
          ]
        }
      }
      List.reverse(out)
    }
  }

  let mut inserts: List<InsertChunk> = []
  let mut prevSrcEnd = 0
  let mut prevVirtEnd = 0
  let rec walkMatches = (items: List<(Number, Number, Number, Number)>) =>
    match (items) {
      [] => {
        let tailSrcEnd = if (srcLen > trailingAnchor) {
          trailingAnchor
        } else {
          srcLen
        }
        inserts = List.append(
          inserts,
          emitGapInsertions(prevSrcEnd, tailSrcEnd, prevVirtEnd, virtLen)
        )
      },
      [(srcStart, srcEnd, virtStart, virtEnd), ...rest] => {
        inserts = List.append(
          inserts,
          emitGapInsertions(prevSrcEnd, srcStart, prevVirtEnd, virtStart)
        )
        prevSrcEnd = srcEnd
        prevVirtEnd = virtEnd
        walkMatches(rest)
      },
    }
  walkMatches(orderedMatches)
  inserts
}

let virtualInsertionsFromScan = (source: String, virtualText: String) => {
  let srcTokens = List.filter(t => !tokenIsIgnorable(t), Lexer.lex(source))
  let virtTokens = List.filter(
    t => !tokenIsIgnorable(t),
    Lexer.lex(virtualText)
  )
  let srcArr = Array.fromList(srcTokens)
  let virtArr = Array.fromList(virtTokens)
  let n = Array.length(srcArr)
  let m = Array.length(virtArr)
  let trailingAnchor = lastNonEmptyLineEndOffset(source)
  let virtLen = String.length(virtualText)
  if (n == 0) {
    if (virtLen == 0) {
      []
    } else {
      [
        {
          anchorOffset: trailingAnchor,
          virtOffset: 0,
          text: virtualText,
          trailing: true,
        },
      ]
    }
  } else {
    let mut inserts: List<InsertChunk> = []
    let mut si = 0
    let mut vi = 0
    let mut prevVirtEnd = 0
    while (si < n && vi < m) {
      let srcTok = Array.get(si, srcArr)
      let mut vj = vi
      let mut found = false
      while (vj < m) {
        let virtTok = Array.get(vj, virtArr)
        if (tokensEqual(srcTok, virtTok)) {
          found = true
          break
        }
        vj += 1
      }
      if (!found) {
        break
      } else {
        let matchTok = Array.get(vj, virtArr)
        if (matchTok.span.start > prevVirtEnd) {
          let text = String.slice(
            prevVirtEnd,
            end=matchTok.span.start,
            virtualText
          )
          if (String.length(text) > 0) {
            inserts = [
              {
                anchorOffset: srcTok.span.start,
                virtOffset: prevVirtEnd,
                text,
                trailing: false,
              },
              ...inserts
            ]
          }
        }
        prevVirtEnd = matchTok.span.end
        vi = vj + 1
        si += 1
      }
    }
    if (prevVirtEnd < virtLen) {
      let text = String.slice(prevVirtEnd, end=virtLen, virtualText)
      if (String.length(text) > 0) {
        inserts = [
          {
            anchorOffset: trailingAnchor,
            virtOffset: prevVirtEnd,
            text,
            trailing: true,
          },
          ...inserts
        ]
      }
    }
    List.reverse(inserts)
  }
}

provide let whitespaceTargetFromVirtual = (source: String, virtualText: String) => {
  let inserts = virtualInsertionsFromScan(source, virtualText)
  let whitespaceInserts = List.filter(
    (chunk: InsertChunk) => isWhitespaceOnly(chunk.text),
    inserts
  )
  applyInsertionsToSource(source, whitespaceInserts)
}

provide let formatTargetWithSemicolons = (
  source: String,
  virtualText: String,
  fixText: String,
) => {
  let whitespaceInserts = List.filter(
    (chunk: InsertChunk) => isWhitespaceOnly(chunk.text),
    virtualInsertionsFromScan(source, virtualText)
  )
  let semicolonInserts = List.filterMap(
    (chunk: InsertChunk) => {
      let semis = extractSemicolons(chunk.text)
      if (String.length(semis) > 0) {
        Some({
          anchorOffset: chunk.anchorOffset,
          virtOffset: chunk.virtOffset,
          text: semis,
          trailing: chunk.trailing,
        })
      } else {
        None
      }
    },
    virtualInsertionsFromScan(source, fixText)
  )
  applyInsertionsToSource(
    source,
    List.append(whitespaceInserts, semicolonInserts)
  )
}

let inlayHintsForSourceWithTiming = (
  source: String,
  rangeStart: Number,
  rangeEnd: Number,
  debug: (String) => Void,
  escapeJson: (String) => String,
  debugEnabled: Bool,
  timingPrefix: Option<String>,
) => {
  let allowWhitespaceInlays = false
  let totalStart = nowNs()
  debug("[LSP] inlayHintsForSource")
  debug("[LSP] source len=" ++ toString(String.length(source)))
  let parseStart = nowNs()
  Error.clearErrors()
  Error.setPanicMode(false)
  let parsed = Parser.parseResult(source)
  let parseEnd = nowNs()
  maybeLogTiming(timingPrefix, "parse", parseStart, parseEnd)

  let formatStart = nowNs()
  let virtualResult = Formatter.formatResultWithMode(source, Formatter.Virtual)
  let formatEnd = nowNs()
  maybeLogTiming(timingPrefix, "format_virtual", formatStart, formatEnd)
  let virtText = virtualResult.text
  debug("[LSP] virtual text:")
  debug(virtText)

  let diffStart = nowNs()
  let useScanMatcher = String.length(source) > 1600
  let diffInserts = if (useScanMatcher) {
    virtualInsertionsFromScan(source, virtText)
  } else {
    virtualInsertionsFromDiff(source, virtText)
  }
  let diffEnd = nowNs()
  maybeLogTiming(
    timingPrefix,
    if (useScanMatcher) {
      "scan_match"
    } else {
      "diff_match"
    },
    diffStart,
    diffEnd
  )
  debug("[LSP] diff inserts:")
  let rec dumpInserts = (items: List<InsertChunk>) => match (items) {
    [] => void,
    [chunk, ...rest] => {
      debug(
        "  offset="
          ++ toString(chunk.anchorOffset)
          ++ " trailing="
          ++ (if (chunk.trailing) {
            "true"
          } else {
            "false"
          })
          ++ " text=\""
          ++ chunk.text
          ++ "\""
      )
      dumpInserts(rest)
    },
  }
  dumpInserts(diffInserts)

  let grouped = Map.make()
  let groupedTrailing = Map.make()
  let anchorSeen = Map.make()
  let anchorSampleText = Map.make()
  let mut anchorOrder: List<Number> = []
  let trailingAnchor = lastNonEmptyLineEndOffset(source)
  debug("[LSP] trailingAnchor=" ++ toString(trailingAnchor))
  let mut debugInlays: List<(Number, Number, String)> = []
  let applyInlaysPreview = (
    source: String,
    inlays: List<(Number, Number, String)>,
  ) => {
    let previewSource = String.replaceAll("\r", "", source)
    let linesList = String.split("\n", previewSource)
    let maxLineFromInlays = List.reduce((acc, item) => {
      let (line, _col, _text) = item
      if (line > acc) {
        line
      } else {
        acc
      }
    }, 0, inlays)
    let rec pad = (items, target, acc) => {
      match (items) {
        [] => {
          let mut remaining = target - List.length(acc) + 1
          let mut result = acc
          while (remaining > 0) {
            result = ["", ...result]
            remaining -= 1
          }
          List.reverse(result)
        },
        [h, ...t] => pad(t, target, [h, ...acc]),
      }
    }
    let padded = pad(Array.toList(linesList), maxLineFromInlays, [])
    let lines = Array.fromList(padded)
    let lineMap = Map.make()
    let rec add = items => match (items) {
      [] => void,
      [(line, col, text), ...rest] => {
        let existing = match (Map.get(line, lineMap)) {
          Some(list) => list,
          None => [],
        }
        Map.set(line, [(col, text), ...existing], lineMap)
        add(rest)
      },
    }
    add(inlays)
    let sortColsDesc = (items: List<(Number, String)>) => {
      let rec insert = (item, sorted) => match (sorted) {
        [] => [item],
        [head, ...tail] => {
          let (c1, _t1) = item
          let (c2, _t2) = head
          if (c1 < c2) {
            [head, ...insert(item, tail)]
          } else {
            [item, head, ...tail]
          }
        },
      }
      let rec loop = (xs, acc) => match (xs) {
        [] => acc,
        [x, ...rest] => loop(rest, insert(x, acc)),
      }
      loop(items, [])
    }
    let mut i = 0
    let total = Array.length(lines)
    while (i < total) {
      let lineText = Array.get(i, lines)
      let items = match (Map.get(i, lineMap)) {
        Some(list) => sortColsDesc(list),
        None => [],
      }
      let rec applyLine = (text: String, xs) => match (xs) {
        [] => text,
        [(col, insertText), ...rest] => {
          let maxCol = String.length(text)
          let safeCol = if (col < 0) {
            0
          } else if (col > maxCol) {
            maxCol
          } else {
            col
          }
          let left = if (safeCol > 0) {
            String.slice(0, end=safeCol, text)
          } else {
            ""
          }
          let right = if (safeCol < maxCol) {
            String.slice(safeCol, end=maxCol, text)
          } else {
            ""
          }
          applyLine(left ++ insertText ++ right, rest)
        },
      }
      let updated = applyLine(lineText, items)
      if (debugEnabled && List.length(items) > 0) {
        debug(
          "[LSP] preview line "
            ++ toString(i)
            ++ " len="
            ++ toString(String.length(lineText))
            ++ " inserts="
            ++ toString(items)
        )
      }
      Array.set(i, updated, lines)
      i += 1
    }
    Array.join("\n", lines)
  }
  let rec group = (items: List<InsertChunk>) => match (items) {
    [] => void,
    [chunk, ...rest] => {
      let offset = chunk.anchorOffset
      let already = match (Map.get(offset, anchorSeen)) {
        Some(_) => true,
        None => false,
      }
      if (!already) {
        Map.set(offset, true, anchorSeen)
        anchorOrder = [offset, ...anchorOrder]
        Map.set(offset, chunk.text, anchorSampleText)
      }
      if (chunk.trailing) {
        let existing = match (Map.get(offset, groupedTrailing)) {
          Some(list) => list,
          None => [],
        }
        Map.set(offset, [chunk, ...existing], groupedTrailing)
      } else {
        let existing = match (Map.get(offset, grouped)) {
          Some(list) => list,
          None => [],
        }
        Map.set(offset, [chunk, ...existing], grouped)
      }
      group(rest)
    },
  }
  let filterCommentsStart = nowNs()
  let cSpans = commentSpans(source)
  let diffInserts = List.filter(
    (chunk: InsertChunk) => !insideComment(chunk.anchorOffset, cSpans),
    diffInserts
  )
  let filterCommentsEnd = nowNs()
  maybeLogTiming(
    timingPrefix,
    "comment_spans_and_filter",
    filterCommentsStart,
    filterCommentsEnd
  )

  let groupStart = nowNs()
  group(diffInserts)
  let groupEnd = nowNs()
  maybeLogTiming(timingPrefix, "group", groupStart, groupEnd)

  let orderedAnchors = List.reverse(anchorOrder)
  let rec render = (anchors: List<Number>, acc: List<String>) =>
    match (anchors) {
      [] => List.reverse(acc),
      [offset, ...rest] => {
        let inlineChunks = match (Map.get(offset, grouped)) {
          Some(list) => List.reverse(list),
          None => [],
        }
        let trailingChunks = match (Map.get(offset, groupedTrailing)) {
          Some(list) => List.reverse(list),
          None => [],
        }
        let hasSignal = allowWhitespaceInlays
          || chunksHaveNonWhitespace(inlineChunks)
          || chunksHaveNonWhitespace(trailingChunks)
        if (!hasSignal) {
          render(rest, acc)
        } else {
        debug("[LSP] anchor=" ++ toString(offset))
        debug("  inlineChunks=" ++ toString(inlineChunks))
        debug("  trailingChunks=" ++ toString(trailingChunks))
        let inlineTexts = List.map((c: InsertChunk) => c.text, inlineChunks)
        let trailingTexts = List.map((c: InsertChunk) => c.text, trailingChunks)
        let (inlineCore, trailingCore) = splitChunkTexts(inlineTexts)
        let (inlineFromTrailing, trailingFromTrailing) = splitChunkTexts(
          trailingTexts
        )
        let inlineText = joinNonEmpty(List.append(inlineCore, inlineFromTrailing))
        let trailingText = joinNonEmpty(
          List.append(trailingCore, trailingFromTrailing)
        )
        debug("  inlineText=\"" ++ inlineText ++ "\"")
        debug("  trailingText=\"" ++ trailingText ++ "\"")
        let basePos = offsetToPosition(source, offset)
        let acc1 = if (
          offset >= rangeStart
          && offset <= rangeEnd
          && String.length(inlineText) > 0
          && (allowWhitespaceInlays || !isWhitespaceOnly(inlineText))
        ) {
          let inlinePos = basePos
          debug(
            "[LSP] inline inlay at line "
              ++ toString(inlinePos.line)
              ++ " char "
              ++ toString(inlinePos.character)
              ++ " text=\""
              ++ inlineText
              ++ "\""
          )
          debugInlays = [
            (inlinePos.line, inlinePos.character, inlineText),
            ...debugInlays
          ]
          let hint = "{\"position\":{\"line\":"
            ++ toString(inlinePos.line)
            ++ ",\"character\":"
            ++ toString(inlinePos.character)
            ++ "},\"label\":\""
            ++ escapeJson(inlineText)
            ++ "\",\"kind\":1"
            ++ ",\"paddingLeft\":false,\"paddingRight\":false}"
          [hint, ...acc]
        } else {
          acc
        }
        let sampleText = match (Map.get(offset, anchorSampleText)) {
          Some(text) => text,
          None => "",
        }
        let acc2 = if (
          String.length(trailingText) > 0
          && (allowWhitespaceInlays || !isWhitespaceOnly(trailingText))
        ) {
          let lastNl = lastNewlineIndex(sampleText)
          let pos = if (lastNl >= 0) {
            let nlCount = countNewlines(
              String.slice(0, end=lastNl + 1, sampleText)
            )
            {
              line: basePos.line + nlCount,
              character: 0,
            }
          } else {
            basePos
          }
          debug(
            "[LSP] trailing inlay at line "
              ++ toString(pos.line)
              ++ " char "
              ++ toString(pos.character)
              ++ " text=\""
              ++ trailingText
              ++ "\""
          )
          debugInlays = [
            (pos.line, pos.character, trailingText),
            ...debugInlays
          ]
          let hint = "{\"position\":{\"line\":"
            ++ toString(pos.line)
            ++ ",\"character\":"
            ++ toString(pos.character)
            ++ "},\"label\":\""
            ++ escapeJson(trailingText)
            ++ "\",\"kind\":1"
            ++ ",\"paddingLeft\":false,\"paddingRight\":false}"
          [hint, ...acc1]
        } else {
          acc1
        }
        render(rest, acc2)
        }
      },
    }

  let renderStart = nowNs()
  let hints = render(orderedAnchors, [])
  let renderEnd = nowNs()
  maybeLogTiming(timingPrefix, "render_hints", renderStart, renderEnd)
  if (debugEnabled) {
    let previewStart = nowNs()
    let preview = applyInlaysPreview(source, debugInlays)
    let previewEnd = nowNs()
    maybeLogTiming(timingPrefix, "debug_preview", previewStart, previewEnd)
    debug("[LSP] preview:")
    debug(preview)
  }
  let result = "[" ++ Array.join(",", Array.fromList(hints)) ++ "]"
  let totalEnd = nowNs()
  maybeLogTiming(timingPrefix, "total", totalStart, totalEnd)
  result
}

provide let inlayHintsForSource = (
  source: String,
  rangeStart: Number,
  rangeEnd: Number,
  debug: (String) => Void,
  escapeJson: (String) => String,
  debugEnabled: Bool,
) => {
  // TODO(remove): legacy single-file inference path kept for inlay unit tests.
  // LSP uses module-summary-backed type inlays via formatInlayHintsForSource + typeInlayHintsFromLoweredProgram.
  let formatJson = inlayHintsForSourceWithTiming(
    source,
    rangeStart,
    rangeEnd,
    debug,
    escapeJson,
    debugEnabled,
    None
  )
  Error.clearErrors()
  Error.setPanicMode(false)
  let parsed = Parser.parseResult(source)
  let lowered = Lower.lowerProgram(parsed.program)
  let infer = Infer.inferProgram(lowered)
  let typeJson = typeInlayHintsFromLoweredProgram(lowered, infer, rangeStart, rangeEnd)
  if (formatJson == "[]") {
    typeJson
  } else if (typeJson == "[]") {
    formatJson
  } else {
    let leftInner = String.slice(1, end=String.length(formatJson) - 1, formatJson)
    let rightInner = String.slice(1, end=String.length(typeJson) - 1, typeJson)
    "[" ++ leftInner ++ "," ++ rightInner ++ "]"
  }
}

provide let formatInlayHintsForSource = (
  source: String,
  rangeStart: Number,
  rangeEnd: Number,
  debug: (String) => Void,
  escapeJson: (String) => String,
  debugEnabled: Bool,
) =>
  inlayHintsForSourceWithTiming(
    source,
    rangeStart,
    rangeEnd,
    debug,
    escapeJson,
    debugEnabled,
    None
  )

provide let inlayHintsForSourceProfile = (
  source: String,
  rangeStart: Number,
  rangeEnd: Number,
  debug: (String) => Void,
  escapeJson: (String) => String,
  debugEnabled: Bool,
  timingPrefix: String,
) =>
  inlayHintsForSourceWithTiming(
    source,
    rangeStart,
    rangeEnd,
    debug,
    escapeJson,
    debugEnabled,
    Some(timingPrefix)
  )
