module LSP

from "array" include Array
from "bytes" include Bytes
from "list" include List
from "map" include Map
from "number" include Number
from "string" include String
from "uint8" include Uint8
from "wasi/file" include File
from "wasi/process" include Process
from "json" include Json

from "../../core/source.gr" include Source
from "../../core/error.gr" include Error
from "../../module/module_system.gr" include ModuleSystem
from "./format.gr" include Format
from "./inlay.gr" include Inlay

let escapeJson = (s: String) => {
  let step1 = String.replaceAll("\\", "\\\\", s)
  let step2 = String.replaceAll("\"", "\\\"", step1)
  let step3 = String.replaceAll("\n", "\\n", step2)
  let step4 = String.replaceAll("\r", "\\r", step3)
  String.replaceAll("\t", "\\t", step4)
}

let logErr = (text: String) => {
  let _ = File.fdWrite(File.stderr, Bytes.fromString(text ++ "\n"))
  void
}

let hasArg = (flag: String) => {
  match (Process.argv()) {
    Err(_) => false,
    Ok(args) => {
      Array.reduce((found, arg) => {
        if (found) {
          true
        } else {
          arg == flag
        }
      }, false, args)
    },
  }
}

let isInlayWorker = hasArg("--inlay-worker")
let _ = logErr("[LSP] isInlayWorker=" ++ (if (isInlayWorker) {
  "true"
} else {
  "false"
}))

let mut debugEnabled = true
let mut workspaceRootPath: Option<String> = None
let v0StdRoot = "c:/GIT/workman/std"
let mut inlayDebugEnabled = false
let mut formatDebugEnabled = false
let mut shouldExit = false
let inlayMaxSourceChars = 120000
let formatMaxSourceChars = 200000
let docVersions = Map.make()
let inlayCache: Map.Map<String, String> = Map.make()
let mut inlayCachedVersion: Map.Map<String, Number> = Map.make()
let cachedGraphNodes: Map.Map<String, ModuleSystem.ModuleNode> = Map.make()

let debug = (text: String) => {
  if (debugEnabled) {
    logErr(text)
  } else {
    void
  }
}

let debugInlay = (text: String) => {
  if (inlayDebugEnabled) {
    logErr(text)
  } else {
    void
  }
}

let debugFormat = (text: String) => {
  if (formatDebugEnabled) {
    logErr(text)
  } else {
    void
  }
}

let documentVersion = (uri: String) => match (Map.get(uri, docVersions)) {
  Some(v) => v,
  None => 0,
}

let computeInlayHints = (uri: String, source: String, version: Number) => {
  let sourceLen = String.length(source)
  if (sourceLen > inlayMaxSourceChars) {
    logErr(
      "[LSP inlay] skip uri="
        ++ uri
        ++ " sourceLen="
        ++ toString(sourceLen)
        ++ " exceeds max"
    )
    "[]"
  } else {
    logErr(
      "[LSP inlay] compute start uri="
        ++ uri
        ++ " v"
        ++ toString(version)
        ++ " sourceLen="
        ++ toString(sourceLen)
    )
    let hintsJson = Inlay.inlayHintsForSource(
      source,
      0,
      sourceLen,
      debugInlay,
      escapeJson,
      inlayDebugEnabled
    )
    Map.set(uri, hintsJson, inlayCache)
    Map.set(uri, version, inlayCachedVersion)
    logErr("[LSP inlay] compute done uri=" ++ uri ++ " v" ++ toString(version))
    hintsJson
  }
}

let warmInlayCache = (uri: String, source: String, version: Number) => {
  match (Map.get(uri, inlayCachedVersion)) {
    Some(v) when v == version => {
      logErr(
        "[LSP inlay] warm cache hit uri=" ++ uri ++ " v" ++ toString(version)
      )
    },
    _ => {
      logErr("[LSP inlay] warm start uri=" ++ uri ++ " v" ++ toString(version))
      let _ = computeInlayHints(uri, source, version)
      logErr("[LSP inlay] warm done uri=" ++ uri ++ " v" ++ toString(version))
    },
  }
}

let invalidateInlayCache = (uri: String) => {
  Map.remove(uri, inlayCache)
  Map.remove(uri, inlayCachedVersion)
}

let writeStdout = (text: String) => {
  let _ = File.fdWrite(File.stdout, Bytes.fromString(text))
  void
}

let sendResponse = (idText: String, resultJson: String) => {
  let body = "{\"jsonrpc\":\"2.0\",\"id\":"
    ++ idText
    ++ ",\"result\":"
    ++ resultJson
    ++ "}"
  let bodyBytes = Bytes.fromString(body)
  let header = "Content-Length: "
    ++ toString(Bytes.length(bodyBytes))
    ++ "\r\n\r\n"
  writeStdout(header ++ body)
}

let sendNotification = (method: String, paramsJson: String) => {
  let body = "{\"jsonrpc\":\"2.0\",\"method\":\""
    ++ escapeJson(method)
    ++ "\",\"params\":"
    ++ paramsJson
    ++ "}"
  let bodyBytes = Bytes.fromString(body)
  let header = "Content-Length: "
    ++ toString(Bytes.length(bodyBytes))
    ++ "\r\n\r\n"
  writeStdout(header ++ body)
}

let jsonToIdText = (idJson: Json.Json) => match (idJson) {
  Json.JsonNumber(n) => toString(n),
  Json.JsonString(s) => "\"" ++ escapeJson(s) ++ "\"",
  _ => "null",
}

let jsonGet = (key: String, json: Json.Json) => match (json) {
  Json.JsonObject(entries) => {
    let rec find = items => match (items) {
      [] => None,
      [(k, v), ...rest] => if (k == key) {
        Some(v)
      } else {
        find(rest)
      },
    }
    find(entries)
  },
  _ => None,
}

let jsonGetString = (key: String, json: Json.Json) =>
  match (jsonGet(key, json)) {
    Some(Json.JsonString(s)) => Some(s),
    _ => None,
  }

let jsonGetNumber = (key: String, json: Json.Json) =>
  match (jsonGet(key, json)) {
    Some(Json.JsonNumber(n)) => Some(n),
    _ => None,
  }

let jsonGetObject = (key: String, json: Json.Json) =>
  match (jsonGet(key, json)) {
    Some(Json.JsonObject(items)) => Some(Json.JsonObject(items)),
    _ => None,
  }

let jsonGetArray = (key: String, json: Json.Json) =>
  match (jsonGet(key, json)) {
    Some(Json.JsonArray(arr)) => Some(arr),
    _ => None,
  }

let positionToOffset = (source: String, line0: Number, col0: Number) => {
  let targetLine = line0 + 1
  let targetCol = col0
  let len = String.length(source)
  let rec loop = (idx: Number, line: Number, col: Number) => {
    if (idx >= len) {
      len
    } else if (line == targetLine && col == targetCol) {
      idx
    } else {
      let ch = String.charAt(idx, source)
      if (ch == '\n') {
        loop(idx + 1, line + 1, 0)
      } else {
        loop(idx + 1, line, col + 1)
      }
    }
  }
  loop(0, 1, 0)
}

let decodeUriPath = (uriPath: String) => {
  let step0 = String.replaceAll("%20", " ", uriPath)
  let step1 = String.replaceAll("%3A", ":", step0)
  String.replaceAll("%5C", "\\", step1)
}

let uriToPath = (uri: String) => {
  if (String.startsWith("file:///", uri)) {
    let raw = String.slice(String.length("file:///"), uri)
    let decoded = decodeUriPath(raw)
    let withDrive = if (
      String.length(decoded) > 1
      && String.charAt(1, decoded) == ':'
    ) {
      decoded
    } else if (String.length(decoded) > 2 && String.charAt(2, decoded) == ':') {
      String.slice(1, decoded)
    } else {
      decoded
    }
    String.replaceAll("\\", "/", withDrive)
  } else if (String.startsWith("file://", uri)) {
    let raw = String.slice(String.length("file://"), uri)
    String.replaceAll("\\", "/", decodeUriPath(raw))
  } else {
    String.replaceAll("\\", "/", uri)
  }
}

let isAbsolutePath = (path: String) => {
  String.startsWith("/", path)
    || String.length(path) > 1 && String.charAt(1, path) == ':'
}

let dirname = (path: String) => {
  let normalized = String.replaceAll("\\", "/", path)
  let mut i = String.length(normalized) - 1
  let mut cut = -1
  while (i >= 0 && cut < 0) {
    if (String.charAt(i, normalized) == '/') {
      cut = i
    }
    i -= 1
  }
  if (cut < 0) {
    "."
  } else if (cut == 0) {
    "/"
  } else {
    String.slice(0, end=cut, normalized)
  }
}

let toWorkspacePath = (path: String) => {
  match (workspaceRootPath) {
    Some(root) => {
      let rootWithSlash = if (String.endsWith("/", root)) {
        root
      } else {
        root ++ "/"
      }
      if (String.startsWith(rootWithSlash, path)) {
        String.slice(String.length(rootWithSlash), path)
      } else if (path == root) {
        "."
      } else {
        path
      }
    },
    None => path,
  }
}

let pathToUri = (path: String) => {
  let normalized = String.replaceAll("\\", "/", path)
  let step1 = String.replaceAll(" ", "%20", normalized)
  let encoded = String.replaceAll(":", "%3A", step1)
  if (String.length(normalized) > 1 && String.charAt(1, normalized) == ':') {
    "file:///" ++ encoded
  } else {
    "file://" ++ encoded
  }
}

let stageToString = (stage: Error.Stage) => match (stage) {
  _ => Error.stageName(stage),
}

let diagnosticToJson = (diag: Error.CompilerError) => {
  let line0 = if (diag.span.line > 0) {
    diag.span.line - 1
  } else {
    0
  }
  let col0 = if (diag.span.col > 0) {
    diag.span.col - 1
  } else {
    0
  }
  let endCol0 = if (diag.span.end > diag.span.start) {
    col0 + (diag.span.end - diag.span.start)
  } else {
    col0 + 1
  }
  let sourceTag = "workman/" ++ stageToString(diag.stage)
  "{\"range\":{\"start\":{\"line\":"
    ++ toString(line0)
    ++ ",\"character\":"
    ++ toString(col0)
    ++ "},\"end\":{\"line\":"
    ++ toString(line0)
    ++ ",\"character\":"
    ++ toString(endCol0)
    ++ "}},\"severity\":"
    ++ toString(Error.severityToNumber(diag.severity))
    ++ ",\"source\":\""
    ++ escapeJson(sourceTag)
    ++ "\",\"message\":\""
    ++ escapeJson(diag.message)
    ++ "\"}"
}

let joinStrings = (sep: String, parts: List<String>) => {
  let rec loop = (remaining: List<String>, out: String) => {
    match (remaining) {
      [] => out,
      [head, ...rest] => if (out == "") {
        loop(rest, head)
      } else {
        loop(rest, out ++ sep ++ head)
      },
    }
  }
  loop(parts, "")
}

let publishDiagnostics = (uri: String, diagnostics: List<Error.CompilerError>) => {
  if (List.length(diagnostics) > 0) {
    debug(
      "[LSP diag] publish uri="
        ++ uri
        ++ " count="
        ++ toString(List.length(diagnostics))
    )
  } else {
    void
  }
  let diagnosticsJson = "["
    ++ joinStrings(",", List.map(diagnosticToJson, diagnostics))
    ++ "]"
  let params = "{\"uri\":\""
    ++ escapeJson(uri)
    ++ "\",\"diagnostics\":"
    ++ diagnosticsJson
    ++ "}"
  sendNotification("textDocument/publishDiagnostics", params)
}

let docsToOverrides = (docs: Map.Map<String, String>) => {
  let overrides = Map.make()
  List.forEach(((uri, source)) => {
    let path = toWorkspacePath(uriToPath(uri))
    Map.set(path, source, overrides)
  }, Map.toList(docs))
  overrides
}

let pathUriLookup = (docs: Map.Map<String, String>) => {
  let lookup = Map.make()
  List.forEach(((uri, _)) => {
    let path = toWorkspacePath(uriToPath(uri))
    Map.set(path, uri, lookup)
  }, Map.toList(docs))
  lookup
}

let publishGraphDiagnostics = (
  entryUri: String,
  docs: Map.Map<String, String>,
  publishedUris: Map.Map<String, Bool>,
) => {
  let absEntryPath = uriToPath(entryUri)
  let rootDir = match (workspaceRootPath) {
    Some(root) => root,
    None => dirname(absEntryPath),
  }
  let entryPath = toWorkspacePath(uriToPath(entryUri))
  let overrides = docsToOverrides(docs)
  let uriLookup = pathUriLookup(docs)
  let graph = ModuleSystem.buildGraph(
    entryPath,
    options={
      rootDir,
      stdRoots: [v0StdRoot],
      sourceOverrides: overrides,
      debugLog: Some(debug),
      cachedNodes: cachedGraphNodes,
    }
  )
  List.forEach(((moduleId, node)) => {
    Map.set(moduleId, node, cachedGraphNodes)
  }, Map.toList(graph.nodes))
  debug(
    "[LSP diag] entry="
      ++ entryPath
      ++ " topo="
      ++ toString(List.length(graph.topo))
      ++ " cached="
      ++ toString(List.length(Map.toList(cachedGraphNodes)))
  )
  let nextPublished = Map.make()
  List.forEach(
    ((modulePath, diagnostics)) => {
      let uri = match (Map.get(modulePath, uriLookup)) {
        Some(mappedUri) => mappedUri,
        None => match (workspaceRootPath) {
          Some(root) when !isAbsolutePath(modulePath) =>
            pathToUri(root ++ "/" ++ modulePath),
          _ => pathToUri(modulePath),
        },
      }
      publishDiagnostics(uri, diagnostics)
      if (List.length(diagnostics) > 0) {
        List.forEach((diag: Error.CompilerError) => {
          debug(
            "[LSP diag] module=" ++ modulePath ++ " message=" ++ diag.message
          )
        }, diagnostics)
      } else {
        void
      }
      Map.set(uri, true, nextPublished)
    },
    Map.toList(graph.diagnosticsById)
  )

  List.forEach(((uri, _)) => {
    if (Map.get(uri, nextPublished) == None) {
      debug("[LSP diag] clearing stale diagnostics uri=" ++ uri)
      publishDiagnostics(uri, [])
    } else {
      void
    }
  }, Map.toList(publishedUris))

  nextPublished
}

let handleInitialize = (idText: String) => {
  let caps = "\"textDocumentSync\":{\"openClose\":true,\"change\":1}"
    ++ (if (isInlayWorker) {
      ",\"inlayHintProvider\":true"
    } else {
      {
        ""
      } ++ (if (!isInlayWorker) {
        ",\"documentFormattingProvider\":true"
      } else {
        ""
      })
    })
  let result = "{"
    ++ "\"capabilities\":{"
    ++ caps
    ++ "},"
    ++ "\"serverInfo\":{\"name\":\"workman-lsp\",\"version\":\"0.0.1\"}"
    ++ "}"
  sendResponse(idText, result)
}

let handleInlayHint = (
  idText: String,
  params: Json.Json,
  docs: Map.Map<String, String>,
) => {
  let uriOpt = match (jsonGetObject("textDocument", params)) {
    Some(obj) => jsonGetString("uri", obj),
    None => None,
  }
  match (uriOpt) {
    None => sendResponse(idText, "[]"),
    Some(uri) => {
      let version = documentVersion(uri)
      match (Map.get(uri, inlayCachedVersion)) {
        Some(v) when v == version => {
          match (Map.get(uri, inlayCache)) {
            Some(cached) => sendResponse(idText, cached),
            None => sendResponse(idText, "[]"),
          }
        },
        _ => {
          match (Map.get(uri, docs)) {
            None => sendResponse(idText, "[]"),
            Some(source) => {
              let hintsJson = computeInlayHints(uri, source, version)
              sendResponse(idText, hintsJson)
            },
          }
        },
      }
    },
  }
}

let handleFormatting = (
  idText: String,
  params: Json.Json,
  docs: Map.Map<String, String>,
) => {
  debug("[LSP format] request received")
  let uriOpt = match (jsonGetObject("textDocument", params)) {
    Some(obj) => jsonGetString("uri", obj),
    None => None,
  }
  match (uriOpt) {
    None => {
      debug("[LSP format] missing URI, returning empty")
      sendResponse(idText, "[]")
      debug("[LSP format] done status=missing_uri")
    },
    Some(uri) => {
      debug("[LSP format] start uri=" ++ uri)
      match (Map.get(uri, docs)) {
        None => {
          debug("[LSP format] document not open, returning empty uri=" ++ uri)
          sendResponse(idText, "[]")
          debug("[LSP format] done uri=" ++ uri ++ " status=document_not_open")
        },
        Some(source) => {
          let sourceLen = String.length(source)
          if (sourceLen > formatMaxSourceChars) {
            debug(
              "[LSP format] skipped uri="
                ++ uri
                ++ " reason=source_too_large chars="
                ++ toString(sourceLen)
                ++ " limit="
                ++ toString(formatMaxSourceChars)
            )
            sendResponse(idText, "[]")
            debug(
              "[LSP format] done uri="
                ++ uri
                ++ " status=skipped_source_too_large chars="
                ++ toString(sourceLen)
            )
          } else {
            debug("[LSP format] building edits uri=" ++ uri)
            let editsJson = Format.formattingEditsForSource(
              source,
              debugFormat,
              escapeJson
            )
            debug("[LSP format] sending response uri=" ++ uri)
            sendResponse(idText, editsJson)
            debug(
              "[LSP format] done uri="
                ++ uri
                ++ " status=ok edits_json_chars="
                ++ toString(String.length(editsJson))
            )
          }
        },
      }
    },
  }
}

let handleMessage = (
  msgJson: Json.Json,
  docs: Map.Map<String, String>,
  publishedUris: Map.Map<String, Bool>,
) => {
  let idOpt = jsonGet("id", msgJson)
  let methodOpt = jsonGetString("method", msgJson)
  match (methodOpt) {
    None => publishedUris,
    Some(method) => {
      debug("[LSP msg] method=" ++ method)
      if (method == "initialize") {
        match (jsonGetObject("params", msgJson)) {
          Some(params) => {
            workspaceRootPath = match (jsonGetString("rootUri", params)) {
              Some(rootUri) => Some(uriToPath(rootUri)),
              None => workspaceRootPath,
            }
            debug("[LSP init] workspaceRoot=" ++ match (workspaceRootPath) {
              Some(root) => root,
              None => "<none>",
            })
          },
          None => void,
        }
        match (idOpt) {
          Some(idJson) => handleInitialize(jsonToIdText(idJson)),
          None => void,
        }
        publishedUris
      } else if (method == "textDocument/didOpen") {
        debug("[LSP msg] handling didOpen")
        match (jsonGetObject("params", msgJson)) {
          Some(params) => {
            match (jsonGetObject("textDocument", params)) {
              Some(doc) => {
                match (jsonGetString("uri", doc)) {
                  Some(uri) => match (jsonGetString("text", doc)) {
                    Some(text) => {
                      Map.set(uri, text, docs)
                      let version = match (jsonGetNumber("version", doc)) {
                        Some(v) => v,
                        None => 1,
                      }
                      Map.set(uri, version, docVersions)
                      if (isInlayWorker) {
                        warmInlayCache(uri, text, version)
                      } else {
                        void
                      }
                      if (workspaceRootPath == None) {
                        workspaceRootPath = Some(dirname(uriToPath(uri)))
                      } else {
                        void
                      }
                      if (!isInlayWorker) {
                        publishGraphDiagnostics(uri, docs, publishedUris)
                      } else {
                        publishedUris
                      }
                    },
                    None => publishedUris,
                  },
                  None => publishedUris,
                }
              },
              None => publishedUris,
            }
          },
          None => publishedUris,
        }
      } else if (method == "textDocument/didChange") {
        match (jsonGetObject("params", msgJson)) {
          Some(params) => {
            let textDocOpt = jsonGetObject("textDocument", params)
            let uriOpt = match (textDocOpt) {
              Some(doc) => jsonGetString("uri", doc),
              None => None,
            }
            let versionOpt = match (textDocOpt) {
              Some(doc) => jsonGetNumber("version", doc),
              None => None,
            }
            let changesOpt = jsonGetArray("contentChanges", params)
            match (uriOpt) {
              Some(uri) => match (changesOpt) {
                Some(changes) => {
                  match (changes) {
                    [Json.JsonObject(first), ..._] => {
                      match (jsonGetString("text", Json.JsonObject(first))) {
                        Some(text) => {
                          Map.set(uri, text, docs)
                          let nextVersion = match (versionOpt) {
                            Some(v) => v,
                            None => match (Map.get(uri, docVersions)) {
                              Some(prev) => prev + 1,
                              None => 1,
                            },
                          }
                          Map.set(uri, nextVersion, docVersions)
                          if (isInlayWorker) {
                            invalidateInlayCache(uri)
                          } else {
                            void
                          }
                          if (workspaceRootPath == None) {
                            workspaceRootPath = Some(dirname(uriToPath(uri)))
                          } else {
                            void
                          }
                          if (!isInlayWorker) {
                            publishGraphDiagnostics(uri, docs, publishedUris)
                          } else {
                            publishedUris
                          }
                        },
                        None => publishedUris,
                      }
                    },
                    _ => publishedUris,
                  }
                },
                None => publishedUris,
              },
              None => publishedUris,
            }
          },
          None => publishedUris,
        }
      } else if (method == "textDocument/didClose") {
        debug("[LSP msg] handling didClose")
        match (jsonGetObject("params", msgJson)) {
          Some(params) => {
            match (jsonGetObject("textDocument", params)) {
              Some(doc) => {
                match (jsonGetString("uri", doc)) {
                  Some(uri) => {
                    Map.remove(uri, docs)
                    Map.remove(uri, docVersions)
                    if (isInlayWorker) {
                      invalidateInlayCache(uri)
                    } else {
                      void
                    }
                    publishDiagnostics(uri, [])
                    let next = Map.make()
                    List.forEach(((u, _)) => {
                      if (u == uri) {
                        void
                      } else {
                        Map.set(u, true, next)
                      }
                    }, Map.toList(publishedUris))
                    next
                  },
                  None => publishedUris,
                }
              },
              None => publishedUris,
            }
          },
          None => publishedUris,
        }
      } else if (method == "textDocument/inlayHint") {
        if (isInlayWorker) {
          match (idOpt) {
            Some(idJson) => match (jsonGetObject("params", msgJson)) {
              Some(params) =>
                handleInlayHint(jsonToIdText(idJson), params, docs),
              None => void,
            },
            None => void,
          }
        } else {
          match (idOpt) {
            Some(idJson) => sendResponse(jsonToIdText(idJson), "[]"),
            None => void,
          }
        }
        publishedUris
      } else if (method == "textDocument/formatting") {
        debug("[LSP msg] handling formatting")
        match (idOpt) {
          Some(idJson) => match (jsonGetObject("params", msgJson)) {
            Some(params) =>
              handleFormatting(jsonToIdText(idJson), params, docs),
            None => void,
          },
          None => void,
        }
        publishedUris
      } else if (method == "shutdown") {
        debug("[LSP msg] handling shutdown")
        match (idOpt) {
          Some(idJson) => sendResponse(jsonToIdText(idJson), "null"),
          None => void,
        }
        publishedUris
      } else if (method == "exit") {
        debug("[LSP msg] handling exit")
        shouldExit = true
        publishedUris
      } else {
        publishedUris
      }
    },
  }
}

let parseContentLength = (header: String) => {
  let lines = String.split("\r\n", header)
  let rec find = (idx: Number) => {
    if (idx >= Array.length(lines)) {
      None
    } else {
      let line = Array.get(idx, lines)
      if (String.startsWith("Content-Length:", line)) {
        let raw = String.slice(String.length("Content-Length:"), line)
        match (Number.parseInt(String.trim(raw), radix=10)) {
          Ok(n) => Some(n),
          Err(_) => None,
        }
      } else {
        find(idx + 1)
      }
    }
  }
  find(0)
}

let findHeaderEnd = (buffer: Bytes) => {
  let len = Bytes.length(buffer)
  let mut i = 0
  let mut found: Option<Number> = None
  while (i + 3 < len && found == None) {
    let b0 = Uint8.toNumber(Bytes.getUint8(i, buffer))
    let b1 = Uint8.toNumber(Bytes.getUint8(i + 1, buffer))
    let b2 = Uint8.toNumber(Bytes.getUint8(i + 2, buffer))
    let b3 = Uint8.toNumber(Bytes.getUint8(i + 3, buffer))
    if (b0 == 13 && b1 == 10 && b2 == 13 && b3 == 10) {
      found = Some(i)
    }
    i += 1
  }
  found
}

let tryExtractMessage = (buffer: Bytes) => {
  match (findHeaderEnd(buffer)) {
    None => (None, buffer),
    Some(headerEnd) => {
      let headerBytes = Bytes.slice(0, headerEnd, buffer)
      let header = Bytes.toString(headerBytes)
      let bodyStart = headerEnd + 4
      match (parseContentLength(header)) {
        None => (None, buffer),
        Some(len) => {
          let bufLen = Bytes.length(buffer)
          let totalNeeded = bodyStart + len
          if (bufLen < totalNeeded) {
            (None, buffer)
          } else {
            let bodyBytes = Bytes.slice(bodyStart, len, buffer)
            let restLen = bufLen - totalNeeded
            let rest = Bytes.slice(totalNeeded, restLen, buffer)
            (Some(Bytes.toString(bodyBytes)), rest)
          }
        },
      }
    },
  }
}

let readChunk = () => {
  match (File.fdRead(File.stdin, 4096)) {
    Ok((bytes, count)) => if (count <= 0) {
      None
    } else {
      let slice = Bytes.slice(0, count, bytes)
      Some(slice)
    },
    Err(_) => None,
  }
}

let rec loop = (
  buffer: Bytes,
  docs: Map.Map<String, String>,
  publishedUris: Map.Map<String, Bool>,
) => {
  if (shouldExit) {
    void
  } else {
    let (msgOpt, rest) = tryExtractMessage(buffer)
    match (msgOpt) {
      Some(msgText) => {
        match (Json.parse(msgText)) {
          Ok(msgJson) => {
            let nextPublished = handleMessage(msgJson, docs, publishedUris)
            loop(rest, docs, nextPublished)
          },
          Err(err) => {
            logErr("Failed to parse JSON: " ++ toString(err))
            loop(rest, docs, publishedUris)
          },
        }
      },
      None => {
        match (readChunk()) {
          None => void,
          Some(chunk) => loop(Bytes.concat(buffer, chunk), docs, publishedUris),
        }
      },
    }
  }
}

let main = () => {
  let docs = Map.make()
  let publishedUris = Map.make()
  loop(Bytes.empty, docs, publishedUris)
}

main()
