module LSP

from "array" include Array
from "bytes" include Bytes
from "list" include List
from "map" include Map
from "number" include Number
from "string" include String
from "wasi/file" include File
from "json" include Json

from "../../core/source.gr" include Source
from "./format.gr" include Format
from "./inlay.gr" include Inlay

let escapeJson = (s: String) => {
  let step1 = String.replaceAll("\\", "\\\\", s)
  let step2 = String.replaceAll("\"", "\\\"", step1)
  let step3 = String.replaceAll("\n", "\\n", step2)
  let step4 = String.replaceAll("\r", "\\r", step3)
  String.replaceAll("\t", "\\t", step4)
}

let logErr = (text: String) => {
  let _ = File.fdWrite(File.stderr, Bytes.fromString(text ++ "\n"))
  void
}

let mut debugEnabled = true

let debug = (text: String) => {
  if (debugEnabled) {
    logErr(text)
  } else {
    void
  }
}

let writeStdout = (text: String) => {
  let _ = File.fdWrite(File.stdout, Bytes.fromString(text))
  void
}

let sendResponse = (idText: String, resultJson: String) => {
  let body = "{\"jsonrpc\":\"2.0\",\"id\":"
    ++ idText
    ++ ",\"result\":"
    ++ resultJson
    ++ "}"
  let header = "Content-Length: " ++ toString(String.length(body)) ++ "\r\n\r\n"
  writeStdout(header ++ body)
}

let jsonToIdText = (idJson: Json.Json) => match (idJson) {
  Json.JsonNumber(n) => toString(n),
  Json.JsonString(s) => "\"" ++ escapeJson(s) ++ "\"",
  _ => "null",
}

let jsonGet = (key: String, json: Json.Json) => match (json) {
  Json.JsonObject(entries) => {
    let rec find = items => match (items) {
      [] => None,
      [(k, v), ...rest] => if (k == key) {
        Some(v)
      } else {
        find(rest)
      },
    }
    find(entries)
  },
  _ => None,
}

let jsonGetString = (key: String, json: Json.Json) =>
  match (jsonGet(key, json)) {
    Some(Json.JsonString(s)) => Some(s),
    _ => None,
  }

let jsonGetNumber = (key: String, json: Json.Json) =>
  match (jsonGet(key, json)) {
    Some(Json.JsonNumber(n)) => Some(n),
    _ => None,
  }

let jsonGetObject = (key: String, json: Json.Json) =>
  match (jsonGet(key, json)) {
    Some(Json.JsonObject(items)) => Some(Json.JsonObject(items)),
    _ => None,
  }

let jsonGetArray = (key: String, json: Json.Json) =>
  match (jsonGet(key, json)) {
    Some(Json.JsonArray(arr)) => Some(arr),
    _ => None,
  }

let positionToOffset = (source: String, line0: Number, col0: Number) => {
  let targetLine = line0 + 1
  let targetCol = col0
  let len = String.length(source)
  let rec loop = (idx: Number, line: Number, col: Number) => {
    if (idx >= len) {
      len
    } else if (line == targetLine && col == targetCol) {
      idx
    } else {
      let ch = String.charAt(idx, source)
      if (ch == '\n') {
        loop(idx + 1, line + 1, 0)
      } else {
        loop(idx + 1, line, col + 1)
      }
    }
  }
  loop(0, 1, 0)
}

let handleInitialize = (idText: String) => {
  let result = "{"
    ++ "\"capabilities\":{"
    ++ "\"textDocumentSync\":{\"openClose\":true,\"change\":1},"
    ++ "\"inlayHintProvider\":true,"
    ++ "\"documentFormattingProvider\":true"
    ++ "},"
    ++ "\"serverInfo\":{\"name\":\"workman-lsp\",\"version\":\"0.0.1\"}"
    ++ "}"
  sendResponse(idText, result)
}

let handleInlayHint = (
  idText: String,
  params: Json.Json,
  docs: Map.Map<String, String>,
) => {
  let uriOpt = match (jsonGetObject("textDocument", params)) {
    Some(obj) => jsonGetString("uri", obj),
    None => None,
  }
  match (uriOpt) {
    None => sendResponse(idText, "[]"),
    Some(uri) => {
      match (Map.get(uri, docs)) {
        None => sendResponse(idText, "[]"),
        Some(source) => {
          let rangeOpt = jsonGetObject("range", params)
          let rangeStart = match (rangeOpt) {
            Some(rangeObj) => {
              let startObj = jsonGetObject("start", rangeObj)
              match (startObj) {
                Some(s) => {
                  let line = match (jsonGetNumber("line", s)) {
                    Some(n) => n,
                    None => 0,
                  }
                  let ch = match (jsonGetNumber("character", s)) {
                    Some(n) => n,
                    None => 0,
                  }
                  positionToOffset(source, line, ch)
                },
                None => 0,
              }
            },
            None => 0,
          }
          let rangeEnd = match (rangeOpt) {
            Some(rangeObj) => {
              let endObj = jsonGetObject("end", rangeObj)
              match (endObj) {
                Some(e) => {
                  let line = match (jsonGetNumber("line", e)) {
                    Some(n) => n,
                    None => 0,
                  }
                  let ch = match (jsonGetNumber("character", e)) {
                    Some(n) => n,
                    None => 0,
                  }
                  positionToOffset(source, line, ch)
                },
                None => String.length(source),
              }
            },
            None => String.length(source),
          }
          let hintsJson = Inlay.inlayHintsForSource(
            source,
            rangeStart,
            rangeEnd,
            debug,
            escapeJson,
            debugEnabled
          )
          sendResponse(idText, hintsJson)
        },
      }
    },
  }
}

let handleFormatting = (
  idText: String,
  params: Json.Json,
  docs: Map.Map<String, String>,
) => {
  let uriOpt = match (jsonGetObject("textDocument", params)) {
    Some(obj) => jsonGetString("uri", obj),
    None => None,
  }
  match (uriOpt) {
    None => sendResponse(idText, "[]"),
    Some(uri) => {
      match (Map.get(uri, docs)) {
        None => sendResponse(idText, "[]"),
        Some(source) => {
          let editsJson = Format.formattingEditsForSource(
            source,
            debug,
            escapeJson
          )
          sendResponse(idText, editsJson)
        },
      }
    },
  }
}

let handleMessage = (msgJson: Json.Json, docs: Map.Map<String, String>) => {
  let idOpt = jsonGet("id", msgJson)
  let methodOpt = jsonGetString("method", msgJson)
  match (methodOpt) {
    None => void,
    Some(method) => {
      if (method == "initialize") {
        match (idOpt) {
          Some(idJson) => handleInitialize(jsonToIdText(idJson)),
          None => void,
        }
      } else if (method == "textDocument/didOpen") {
        match (jsonGetObject("params", msgJson)) {
          Some(params) => {
            match (jsonGetObject("textDocument", params)) {
              Some(doc) => {
                match (jsonGetString("uri", doc)) {
                  Some(uri) => match (jsonGetString("text", doc)) {
                    Some(text) => {
                      Map.set(uri, text, docs)
                      void
                    },
                    None => void,
                  },
                  None => void,
                }
              },
              None => void,
            }
          },
          None => void,
        }
      } else if (method == "textDocument/didChange") {
        match (jsonGetObject("params", msgJson)) {
          Some(params) => {
            let uriOpt = match (jsonGetObject("textDocument", params)) {
              Some(doc) => jsonGetString("uri", doc),
              None => None,
            }
            let changesOpt = jsonGetArray("contentChanges", params)
            match (uriOpt) {
              Some(uri) => match (changesOpt) {
                Some(changes) => {
                  match (changes) {
                    [Json.JsonObject(first), ..._] => {
                      match (jsonGetString("text", Json.JsonObject(first))) {
                        Some(text) => Map.set(uri, text, docs),
                        None => void,
                      }
                    },
                    _ => void,
                  }
                },
                None => void,
              },
              None => void,
            }
          },
          None => void,
        }
      } else if (method == "textDocument/inlayHint") {
        match (idOpt) {
          Some(idJson) => match (jsonGetObject("params", msgJson)) {
            Some(params) => handleInlayHint(jsonToIdText(idJson), params, docs),
            None => void,
          },
          None => void,
        }
      } else if (method == "textDocument/formatting") {
        match (idOpt) {
          Some(idJson) => match (jsonGetObject("params", msgJson)) {
            Some(params) => handleFormatting(jsonToIdText(idJson), params, docs),
            None => void,
          },
          None => void,
        }
      } else if (method == "shutdown") {
        match (idOpt) {
          Some(idJson) => sendResponse(jsonToIdText(idJson), "null"),
          None => void,
        }
      } else if (method == "exit") {
        void
      } else {
        void
      }
    },
  }
}

let parseContentLength = (header: String) => {
  let lines = String.split("\r\n", header)
  let rec find = (idx: Number) => {
    if (idx >= Array.length(lines)) {
      None
    } else {
      let line = Array.get(idx, lines)
      if (String.startsWith("Content-Length:", line)) {
        let raw = String.slice(String.length("Content-Length:"), line)
        match (Number.parseInt(String.trim(raw), radix=10)) {
          Ok(n) => Some(n),
          Err(_) => None,
        }
      } else {
        find(idx + 1)
      }
    }
  }
  find(0)
}

let tryExtractMessage = (buffer: String) => {
  match (String.indexOf("\r\n\r\n", buffer)) {
    None => (None, buffer),
    Some(headerEnd) => {
      let header = String.slice(0, end=headerEnd, buffer)
      let bodyStart = headerEnd + 4
      match (parseContentLength(header)) {
        None => (None, buffer),
        Some(len) => {
          let totalNeeded = bodyStart + len
          if (String.length(buffer) < totalNeeded) {
            (None, buffer)
          } else {
            let body = String.slice(bodyStart, end=totalNeeded, buffer)
            let rest = String.slice(
              totalNeeded,
              end=String.length(buffer),
              buffer
            )
            (Some(body), rest)
          }
        },
      }
    },
  }
}

let readChunk = () => {
  match (File.fdRead(File.stdin, 4096)) {
    Ok((bytes, count)) => if (count <= 0) {
      None
    } else {
      let slice = Bytes.slice(0, count, bytes)
      Some(Bytes.toString(slice))
    },
    Err(_) => None,
  }
}

let rec loop = (buffer: String, docs: Map.Map<String, String>) => {
  let (msgOpt, rest) = tryExtractMessage(buffer)
  match (msgOpt) {
    Some(msgText) => {
      match (Json.parse(msgText)) {
        Ok(msgJson) => handleMessage(msgJson, docs),
        Err(err) => logErr("Failed to parse JSON: " ++ toString(err)),
      }
      loop(rest, docs)
    },
    None => {
      match (readChunk()) {
        None => void,
        Some(chunk) => loop(buffer ++ chunk, docs),
      }
    },
  }
}

let main = () => {
  let docs = Map.make()
  loop("", docs)
}

main()
