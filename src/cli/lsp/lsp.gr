module LSP

from "array" include Array
from "bytes" include Bytes
from "list" include List
from "map" include Map
from "number" include Number
from "string" include String
from "uint8" include Uint8
from "wasi/file" include File
from "json" include Json

from "../../core/source.gr" include Source
from "../../core/error.gr" include Error
from "../../module/module_system.gr" include ModuleSystem
from "./format.gr" include Format
from "./inlay.gr" include Inlay

let escapeJson = (s: String) => {
  let step1 = String.replaceAll("\\", "\\\\", s)
  let step2 = String.replaceAll("\"", "\\\"", step1)
  let step3 = String.replaceAll("\n", "\\n", step2)
  let step4 = String.replaceAll("\r", "\\r", step3)
  String.replaceAll("\t", "\\t", step4)
}

let logErr = (text: String) => {
  let _ = File.fdWrite(File.stderr, Bytes.fromString(text ++ "\n"))
  void
}

let mut debugEnabled = true
let mut workspaceRootPath: Option<String> = None
let v0StdRoot = "c:/GIT/workman/std"
let mut inlayDebugEnabled = false
let mut formatDebugEnabled = false
let mut shouldExit = false
let inlayMaxSourceChars = 120000
let formatMaxSourceChars = 200000
let docVersions = Map.make()
let inlayCache = Map.make()
let mut inlayCacheSize = 0
let inlayCacheMaxEntries = 256
let mut inlayCachedUri: Option<String> = None
let mut pendingInlayWarmUri: Option<String> = None
let mut pendingInlayWarmVersion = 0
let cachedGraphNodes: Map.Map<String, ModuleSystem.ModuleNode> = Map.make()

let debug = (text: String) => {
  if (debugEnabled) {
    logErr(text)
  } else {
    void
  }
}

let debugInlay = (text: String) => {
  if (inlayDebugEnabled) {
    logErr(text)
  } else {
    void
  }
}

let debugFormat = (text: String) => {
  if (formatDebugEnabled) {
    logErr(text)
  } else {
    void
  }
}

let documentVersion = (uri: String) =>
  match (Map.get(uri, docVersions)) {
    Some(v) => v,
    None => 0,
  }

let inlayCacheKey = (
  uri: String,
  version: Number,
  rangeStart: Number,
  rangeEnd: Number,
) =>
  uri
    ++ "|v="
    ++ toString(version)
    ++ "|s="
    ++ toString(rangeStart)
    ++ "|e="
    ++ toString(rangeEnd)

let clearInlayCacheForUri = (uri: String) => {
  let prefix = uri ++ "|"
  let mut removed = 0
  List.forEach(((key, _)) => {
    if (String.startsWith(prefix, key)) {
      Map.remove(key, inlayCache)
      removed += 1
    } else {
      void
    }
  }, Map.toList(inlayCache))
  if (removed > 0) {
    inlayCacheSize -= removed
    if (inlayCacheSize < 0) {
      inlayCacheSize = 0
    } else {
      void
    }
    debug(
      "[LSP inlay] cache invalidated uri="
        ++ uri
        ++ " removed="
        ++ toString(removed)
        ++ " remaining="
        ++ toString(inlayCacheSize)
    )
  } else {
    void
  }
}

let clearAllInlayCache = () => {
  List.forEach(((key, _)) => {
    Map.remove(key, inlayCache)
  }, Map.toList(inlayCache))
  inlayCacheSize = 0
  inlayCachedUri = None
  debug("[LSP inlay] cache cleared")
}

let ensureSingleUriInlayCache = (uri: String) => {
  match (inlayCachedUri) {
    Some(cachedUri) => {
      if (cachedUri == uri) {
        void
      } else {
        clearAllInlayCache()
        inlayCachedUri = Some(uri)
      }
    },
    None => inlayCachedUri = Some(uri),
  }
}

let warmInlayCacheOnOpen = (uri: String, source: String, version: Number) => {
  let sourceLen = String.length(source)
  if (sourceLen > inlayMaxSourceChars) {
    debug(
      "[LSP inlay] warm skipped uri="
        ++ uri
        ++ " reason=source_too_large chars="
        ++ toString(sourceLen)
        ++ " limit="
        ++ toString(inlayMaxSourceChars)
    )
  } else {
    ensureSingleUriInlayCache(uri)
    let fullStart = 0
    let fullEnd = sourceLen
    let fullKey = inlayCacheKey(uri, version, fullStart, fullEnd)
    match (Map.get(fullKey, inlayCache)) {
      Some(_) => void,
      None => {
        debug(
          "[LSP inlay] warming cache on open uri="
            ++ uri
            ++ " version="
            ++ toString(version)
        )
        let hintsJson = Inlay.inlayHintsForSource(
          source,
          fullStart,
          fullEnd,
          debugInlay,
          escapeJson,
          inlayDebugEnabled
        )
        if (inlayCacheSize >= inlayCacheMaxEntries) {
          clearAllInlayCache()
          ensureSingleUriInlayCache(uri)
        } else {
          void
        }
        Map.set(fullKey, hintsJson, inlayCache)
        inlayCacheSize += 1
        debug(
          "[LSP inlay] warm complete uri="
            ++ uri
            ++ " hint_json_chars="
            ++ toString(String.length(hintsJson))
        )
      },
    }
  }
}

let scheduleInlayWarmOnOpen = (uri: String, version: Number, sourceLen: Number) => {
  if (sourceLen > inlayMaxSourceChars) {
    debug(
      "[LSP inlay] warm skipped uri="
        ++ uri
        ++ " reason=source_too_large chars="
        ++ toString(sourceLen)
        ++ " limit="
        ++ toString(inlayMaxSourceChars)
    )
    pendingInlayWarmUri = None
  } else {
    pendingInlayWarmUri = Some(uri)
    pendingInlayWarmVersion = version
    debug(
      "[LSP inlay] warm scheduled on open uri="
        ++ uri
        ++ " version="
        ++ toString(version)
    )
  }
}

let clearPendingInlayWarmForUri = (uri: String) => {
  match (pendingInlayWarmUri) {
    Some(pendingUri) => {
      if (pendingUri == uri) {
        pendingInlayWarmUri = None
      } else {
        void
      }
    },
    None => void,
  }
}

let runPendingInlayWarm = (docs: Map.Map<String, String>) => {
  match (pendingInlayWarmUri) {
    None => false,
    Some(uri) => {
      let scheduledVersion = pendingInlayWarmVersion
      pendingInlayWarmUri = None
      match (Map.get(uri, docs)) {
        None => false,
        Some(source) => {
          let currentVersion = documentVersion(uri)
          if (currentVersion != scheduledVersion) {
            false
          } else {
            warmInlayCacheOnOpen(uri, source, currentVersion)
            true
          }
        },
      }
    },
  }
}

let writeStdout = (text: String) => {
  let _ = File.fdWrite(File.stdout, Bytes.fromString(text))
  void
}

let sendResponse = (idText: String, resultJson: String) => {
  let body = "{\"jsonrpc\":\"2.0\",\"id\":"
    ++ idText
    ++ ",\"result\":"
    ++ resultJson
    ++ "}"
  let bodyBytes = Bytes.fromString(body)
  let header = "Content-Length: " ++ toString(Bytes.length(bodyBytes)) ++ "\r\n\r\n"
  writeStdout(header ++ body)
}

let sendNotification = (method: String, paramsJson: String) => {
  let body = "{\"jsonrpc\":\"2.0\",\"method\":\""
    ++ escapeJson(method)
    ++ "\",\"params\":"
    ++ paramsJson
    ++ "}"
  let bodyBytes = Bytes.fromString(body)
  let header = "Content-Length: " ++ toString(Bytes.length(bodyBytes)) ++ "\r\n\r\n"
  writeStdout(header ++ body)
}

let jsonToIdText = (idJson: Json.Json) => match (idJson) {
  Json.JsonNumber(n) => toString(n),
  Json.JsonString(s) => "\"" ++ escapeJson(s) ++ "\"",
  _ => "null",
}

let jsonGet = (key: String, json: Json.Json) => match (json) {
  Json.JsonObject(entries) => {
    let rec find = items => match (items) {
      [] => None,
      [(k, v), ...rest] => if (k == key) {
        Some(v)
      } else {
        find(rest)
      },
    }
    find(entries)
  },
  _ => None,
}

let jsonGetString = (key: String, json: Json.Json) =>
  match (jsonGet(key, json)) {
    Some(Json.JsonString(s)) => Some(s),
    _ => None,
  }

let jsonGetNumber = (key: String, json: Json.Json) =>
  match (jsonGet(key, json)) {
    Some(Json.JsonNumber(n)) => Some(n),
    _ => None,
  }

let jsonGetObject = (key: String, json: Json.Json) =>
  match (jsonGet(key, json)) {
    Some(Json.JsonObject(items)) => Some(Json.JsonObject(items)),
    _ => None,
  }

let jsonGetArray = (key: String, json: Json.Json) =>
  match (jsonGet(key, json)) {
    Some(Json.JsonArray(arr)) => Some(arr),
    _ => None,
  }

let positionToOffset = (source: String, line0: Number, col0: Number) => {
  let targetLine = line0 + 1
  let targetCol = col0
  let len = String.length(source)
  let rec loop = (idx: Number, line: Number, col: Number) => {
    if (idx >= len) {
      len
    } else if (line == targetLine && col == targetCol) {
      idx
    } else {
      let ch = String.charAt(idx, source)
      if (ch == '\n') {
        loop(idx + 1, line + 1, 0)
      } else {
        loop(idx + 1, line, col + 1)
      }
    }
  }
  loop(0, 1, 0)
}

let decodeUriPath = (uriPath: String) => {
  let step0 = String.replaceAll("%20", " ", uriPath)
  let step1 = String.replaceAll("%3A", ":", step0)
  String.replaceAll("%5C", "\\", step1)
}

let uriToPath = (uri: String) => {
  if (String.startsWith("file:///", uri)) {
    let raw = String.slice(String.length("file:///"), uri)
    let decoded = decodeUriPath(raw)
    let withDrive = if (String.length(decoded) > 1 && String.charAt(1, decoded) == ':') {
      decoded
    } else if (String.length(decoded) > 2 && String.charAt(2, decoded) == ':') {
      String.slice(1, decoded)
    } else {
      decoded
    }
    String.replaceAll("\\", "/", withDrive)
  } else if (String.startsWith("file://", uri)) {
    let raw = String.slice(String.length("file://"), uri)
    String.replaceAll("\\", "/", decodeUriPath(raw))
  } else {
    String.replaceAll("\\", "/", uri)
  }
}

let isAbsolutePath = (path: String) => {
  String.startsWith("/", path)
    || (String.length(path) > 1 && String.charAt(1, path) == ':')
}

let dirname = (path: String) => {
  let normalized = String.replaceAll("\\", "/", path)
  let mut i = String.length(normalized) - 1
  let mut cut = -1
  while (i >= 0 && cut < 0) {
    if (String.charAt(i, normalized) == '/') {
      cut = i
    }
    i -= 1
  }
  if (cut < 0) {
    "."
  } else if (cut == 0) {
    "/"
  } else {
    String.slice(0, end=cut, normalized)
  }
}

let toWorkspacePath = (path: String) => {
  match (workspaceRootPath) {
    Some(root) => {
      let rootWithSlash = if (String.endsWith("/", root)) {
        root
      } else {
        root ++ "/"
      }
      if (String.startsWith(rootWithSlash, path)) {
        String.slice(String.length(rootWithSlash), path)
      } else if (path == root) {
        "."
      } else {
        path
      }
    },
    None => path,
  }
}

let pathToUri = (path: String) => {
  let normalized = String.replaceAll("\\", "/", path)
  let step1 = String.replaceAll(" ", "%20", normalized)
  let encoded = String.replaceAll(":", "%3A", step1)
  if (String.length(normalized) > 1 && String.charAt(1, normalized) == ':') {
    "file:///" ++ encoded
  } else {
    "file://" ++ encoded
  }
}

let stageToString = (stage: Error.Stage) => match (stage) {
  _ => Error.stageName(stage),
}

let diagnosticToJson = (diag: Error.CompilerError) => {
  let line0 = if (diag.span.line > 0) { diag.span.line - 1 } else { 0 }
  let col0 = if (diag.span.col > 0) { diag.span.col - 1 } else { 0 }
  let endCol0 = if (diag.span.end > diag.span.start) {
    col0 + (diag.span.end - diag.span.start)
  } else {
    col0 + 1
  }
  let sourceTag = "workman/" ++ stageToString(diag.stage)
  "{\"range\":{\"start\":{\"line\":"
    ++ toString(line0)
    ++ ",\"character\":"
    ++ toString(col0)
    ++ "},\"end\":{\"line\":"
    ++ toString(line0)
    ++ ",\"character\":"
    ++ toString(endCol0)
    ++ "}},\"severity\":1,\"source\":\""
    ++ escapeJson(sourceTag)
    ++ "\",\"message\":\""
    ++ escapeJson(diag.message)
    ++ "\"}"
}

let joinStrings = (sep: String, parts: List<String>) => {
  let rec loop = (remaining: List<String>, out: String) => {
    match (remaining) {
      [] => out,
      [head, ...rest] =>
        if (out == "") {
          loop(rest, head)
        } else {
          loop(rest, out ++ sep ++ head)
        },
    }
  }
  loop(parts, "")
}

let publishDiagnostics = (uri: String, diagnostics: List<Error.CompilerError>) => {
  if (List.length(diagnostics) > 0) {
    debug(
      "[LSP diag] publish uri="
        ++ uri
        ++ " count="
        ++ toString(List.length(diagnostics))
    )
  } else {
    void
  }
  let diagnosticsJson = "[" ++ joinStrings(",", List.map(diagnosticToJson, diagnostics)) ++ "]"
  let params = "{\"uri\":\""
    ++ escapeJson(uri)
    ++ "\",\"diagnostics\":"
    ++ diagnosticsJson
    ++ "}"
  sendNotification("textDocument/publishDiagnostics", params)
}

let docsToOverrides = (docs: Map.Map<String, String>) => {
  let overrides = Map.make()
  List.forEach(((uri, source)) => {
    let path = toWorkspacePath(uriToPath(uri))
    Map.set(path, source, overrides)
  }, Map.toList(docs))
  overrides
}

let pathUriLookup = (docs: Map.Map<String, String>) => {
  let lookup = Map.make()
  List.forEach(((uri, _)) => {
    let path = toWorkspacePath(uriToPath(uri))
    Map.set(path, uri, lookup)
  }, Map.toList(docs))
  lookup
}

let publishGraphDiagnostics = (
  entryUri: String,
  docs: Map.Map<String, String>,
  publishedUris: Map.Map<String, Bool>,
) => {
  let absEntryPath = uriToPath(entryUri)
  let rootDir = match (workspaceRootPath) {
    Some(root) => root,
    None => dirname(absEntryPath),
  }
  let entryPath = toWorkspacePath(uriToPath(entryUri))
  let overrides = docsToOverrides(docs)
  let uriLookup = pathUriLookup(docs)
  let graph = ModuleSystem.buildGraph(
    entryPath,
    options={
      rootDir,
      stdRoots: [v0StdRoot],
      sourceOverrides: overrides,
      debugLog: Some(debug),
      cachedNodes: cachedGraphNodes,
    }
  )
  List.forEach(((moduleId, node)) => {
    Map.set(moduleId, node, cachedGraphNodes)
  }, Map.toList(graph.nodes))
  debug(
    "[LSP diag] entry=" ++ entryPath
      ++ " topo=" ++ toString(List.length(graph.topo))
      ++ " cached=" ++ toString(List.length(Map.toList(cachedGraphNodes)))
  )
  let nextPublished = Map.make()
  List.forEach(((modulePath, diagnostics)) => {
    let uri = match (Map.get(modulePath, uriLookup)) {
      Some(mappedUri) => mappedUri,
      None => match (workspaceRootPath) {
        Some(root) when !isAbsolutePath(modulePath) => pathToUri(root ++ "/" ++ modulePath),
        _ => pathToUri(modulePath),
      },
    }
    publishDiagnostics(uri, diagnostics)
    if (List.length(diagnostics) > 0) {
      List.forEach((diag: Error.CompilerError) => {
        debug(
          "[LSP diag] module="
            ++ modulePath
            ++ " message="
            ++ diag.message
        )
      }, diagnostics)
    } else {
      void
    }
    Map.set(uri, true, nextPublished)
  }, Map.toList(graph.diagnosticsById))

  List.forEach(((uri, _)) => {
    if (Map.get(uri, nextPublished) == None) {
      debug("[LSP diag] clearing stale diagnostics uri=" ++ uri)
      publishDiagnostics(uri, [])
    } else {
      void
    }
  }, Map.toList(publishedUris))

  nextPublished
}

let handleInitialize = (idText: String) => {
  let result = "{"
    ++ "\"capabilities\":{"
    ++ "\"textDocumentSync\":{\"openClose\":true,\"change\":1},"
    ++ "\"inlayHintProvider\":true,"
    ++ "\"documentFormattingProvider\":true"
    ++ "},"
    ++ "\"serverInfo\":{\"name\":\"workman-lsp\",\"version\":\"0.0.1\"}"
    ++ "}"
  sendResponse(idText, result)
}

let handleInlayHint = (
  idText: String,
  params: Json.Json,
  docs: Map.Map<String, String>,
) => {
  let uriOpt = match (jsonGetObject("textDocument", params)) {
    Some(obj) => jsonGetString("uri", obj),
    None => None,
  }
  match (uriOpt) {
    None => {
      sendResponse(idText, "[]")
    },
    Some(uri) => {
      match (Map.get(uri, docs)) {
        None => {
          sendResponse(idText, "[]")
        },
        Some(source) => {
          let sourceLen = String.length(source)
          if (sourceLen > inlayMaxSourceChars) {
            sendResponse(idText, "[]")
          } else {
          let rangeOpt = jsonGetObject("range", params)
          let rangeStart = match (rangeOpt) {
            Some(rangeObj) => {
              let startObj = jsonGetObject("start", rangeObj)
              match (startObj) {
                Some(s) => {
                  let line = match (jsonGetNumber("line", s)) {
                    Some(n) => n,
                    None => 0,
                  }
                  let ch = match (jsonGetNumber("character", s)) {
                    Some(n) => n,
                    None => 0,
                  }
                  positionToOffset(source, line, ch)
                },
                None => 0,
              }
            },
            None => 0,
          }
          let rangeEnd = match (rangeOpt) {
            Some(rangeObj) => {
              let endObj = jsonGetObject("end", rangeObj)
              match (endObj) {
                Some(e) => {
                  let line = match (jsonGetNumber("line", e)) {
                    Some(n) => n,
                    None => 0,
                  }
                  let ch = match (jsonGetNumber("character", e)) {
                    Some(n) => n,
                    None => 0,
                  }
                  positionToOffset(source, line, ch)
                },
                None => String.length(source),
              }
            },
            None => String.length(source),
          }
          let version = documentVersion(uri)
          let fullStart = 0
          let fullEnd = String.length(source)
          let cacheKey = inlayCacheKey(uri, version, rangeStart, rangeEnd)
          let fullCacheKey = inlayCacheKey(uri, version, fullStart, fullEnd)
          match (Map.get(cacheKey, inlayCache)) {
            Some(cachedHints) => {
              sendResponse(idText, cachedHints)
            },
            None => {
              match (Map.get(fullCacheKey, inlayCache)) {
                Some(fullCachedHints) => {
                  sendResponse(idText, fullCachedHints)
                },
                None => {
                  ensureSingleUriInlayCache(uri)
                  debug("[LSP inlay] build uri=" ++ uri)
                  let hintsJson = Inlay.inlayHintsForSource(
                    source,
                    fullStart,
                    fullEnd,
                    debugInlay,
                    escapeJson,
                    inlayDebugEnabled
                  )
                  if (inlayCacheSize >= inlayCacheMaxEntries) {
                    debug(
                      "[LSP inlay] cache full size="
                        ++ toString(inlayCacheSize)
                        ++ " max="
                        ++ toString(inlayCacheMaxEntries)
                    )
                    clearAllInlayCache()
                  } else {
                    void
                  }
                  Map.set(fullCacheKey, hintsJson, inlayCache)
                  inlayCacheSize += 1
                  sendResponse(idText, hintsJson)
                },
              }
            },
          }
          }
        },
      }
    },
  }
}

let handleFormatting = (
  idText: String,
  params: Json.Json,
  docs: Map.Map<String, String>,
) => {
  debug("[LSP format] request received")
  let uriOpt = match (jsonGetObject("textDocument", params)) {
    Some(obj) => jsonGetString("uri", obj),
    None => None,
  }
  match (uriOpt) {
    None => {
      debug("[LSP format] missing URI, returning empty")
      sendResponse(idText, "[]")
      debug("[LSP format] done status=missing_uri")
    },
    Some(uri) => {
      debug("[LSP format] start uri=" ++ uri)
      match (Map.get(uri, docs)) {
        None => {
          debug("[LSP format] document not open, returning empty uri=" ++ uri)
          sendResponse(idText, "[]")
          debug("[LSP format] done uri=" ++ uri ++ " status=document_not_open")
        },
        Some(source) => {
          let sourceLen = String.length(source)
          if (sourceLen > formatMaxSourceChars) {
            debug(
              "[LSP format] skipped uri="
                ++ uri
                ++ " reason=source_too_large chars="
                ++ toString(sourceLen)
                ++ " limit="
                ++ toString(formatMaxSourceChars)
            )
            sendResponse(idText, "[]")
            debug(
              "[LSP format] done uri="
                ++ uri
                ++ " status=skipped_source_too_large chars="
                ++ toString(sourceLen)
            )
          } else {
          debug("[LSP format] building edits uri=" ++ uri)
          let editsJson = Format.formattingEditsForSource(
            source,
            debugFormat,
            escapeJson
          )
          debug("[LSP format] sending response uri=" ++ uri)
          sendResponse(idText, editsJson)
          debug(
            "[LSP format] done uri="
              ++ uri
              ++ " status=ok edits_json_chars="
              ++ toString(String.length(editsJson))
          )
          }
        },
      }
    },
  }
}

let handleMessage = (
  msgJson: Json.Json,
  docs: Map.Map<String, String>,
  publishedUris: Map.Map<String, Bool>,
) => {
  let idOpt = jsonGet("id", msgJson)
  let methodOpt = jsonGetString("method", msgJson)
  match (methodOpt) {
    None => publishedUris,
    Some(method) => {
      debug("[LSP msg] method=" ++ method)
      if (method == "initialize") {
        match (jsonGetObject("params", msgJson)) {
          Some(params) => {
            workspaceRootPath = match (jsonGetString("rootUri", params)) {
              Some(rootUri) => Some(uriToPath(rootUri)),
              None => workspaceRootPath,
            }
            debug(
              "[LSP init] workspaceRoot="
                ++ match (workspaceRootPath) {
                  Some(root) => root,
                  None => "<none>",
                }
            )
          },
          None => void,
        }
        match (idOpt) {
          Some(idJson) => handleInitialize(jsonToIdText(idJson)),
          None => void,
        }
        publishedUris
      } else if (method == "textDocument/didOpen") {
        debug("[LSP msg] handling didOpen")
        match (jsonGetObject("params", msgJson)) {
          Some(params) => {
            match (jsonGetObject("textDocument", params)) {
              Some(doc) => {
                match (jsonGetString("uri", doc)) {
                  Some(uri) => match (jsonGetString("text", doc)) {
                    Some(text) => {
                      Map.set(uri, text, docs)
                      let version = match (jsonGetNumber("version", doc)) {
                        Some(v) => v,
                        None => 1,
                      }
                      Map.set(uri, version, docVersions)
                      clearAllInlayCache()
                      scheduleInlayWarmOnOpen(uri, version, String.length(text))
                      if (workspaceRootPath == None) {
                        workspaceRootPath = Some(dirname(uriToPath(uri)))
                        debug(
                          "[LSP didOpen] inferred workspaceRoot="
                            ++ match (workspaceRootPath) {
                              Some(root) => root,
                              None => "<none>",
                            }
                        )
                      } else {
                        void
                      }
                      publishGraphDiagnostics(uri, docs, publishedUris)
                    },
                    None => publishedUris,
                  },
                  None => publishedUris,
                }
              },
              None => publishedUris,
            }
          },
          None => publishedUris,
        }
      } else if (method == "textDocument/didChange") {
        match (jsonGetObject("params", msgJson)) {
          Some(params) => {
            let textDocOpt = jsonGetObject("textDocument", params)
            let uriOpt = match (textDocOpt) {
              Some(doc) => jsonGetString("uri", doc),
              None => None,
            }
            let versionOpt = match (textDocOpt) {
              Some(doc) => jsonGetNumber("version", doc),
              None => None,
            }
            let changesOpt = jsonGetArray("contentChanges", params)
            match (uriOpt) {
              Some(uri) => match (changesOpt) {
                Some(changes) => {
                  match (changes) {
                    [Json.JsonObject(first), ..._] => {
                      match (jsonGetString("text", Json.JsonObject(first))) {
                        Some(text) => {
                          Map.set(uri, text, docs)
                          let nextVersion = match (versionOpt) {
                            Some(v) => v,
                            None => match (Map.get(uri, docVersions)) {
                              Some(prev) => prev + 1,
                              None => 1,
                            },
                          }
                          Map.set(uri, nextVersion, docVersions)
                          clearInlayCacheForUri(uri)
                          clearPendingInlayWarmForUri(uri)
                          match (inlayCachedUri) {
                            Some(cachedUri) => {
                              if (cachedUri == uri) {
                                inlayCachedUri = None
                              } else {
                                void
                              }
                            },
                            None => void,
                          }
                          if (workspaceRootPath == None) {
                            workspaceRootPath = Some(dirname(uriToPath(uri)))
                            debug(
                              "[LSP didChange] inferred workspaceRoot="
                                ++ match (workspaceRootPath) {
                                  Some(root) => root,
                                  None => "<none>",
                                }
                            )
                          } else {
                            void
                          }
                          publishGraphDiagnostics(uri, docs, publishedUris)
                        },
                        None => publishedUris,
                      }
                    },
                    _ => publishedUris,
                  }
                },
                None => publishedUris,
              },
              None => publishedUris,
            }
          },
          None => publishedUris,
        }
      } else if (method == "textDocument/didClose") {
        debug("[LSP msg] handling didClose")
        match (jsonGetObject("params", msgJson)) {
          Some(params) => {
            match (jsonGetObject("textDocument", params)) {
              Some(doc) => {
                match (jsonGetString("uri", doc)) {
                  Some(uri) => {
                    Map.remove(uri, docs)
                    Map.remove(uri, docVersions)
                    clearInlayCacheForUri(uri)
                    clearPendingInlayWarmForUri(uri)
                    match (inlayCachedUri) {
                      Some(cachedUri) => {
                        if (cachedUri == uri) {
                          inlayCachedUri = None
                        } else {
                          void
                        }
                      },
                      None => void,
                    }
                    publishDiagnostics(uri, [])
                    let next = Map.make()
                    List.forEach(((u, _)) => {
                      if (u == uri) {
                        void
                      } else {
                        Map.set(u, true, next)
                      }
                    }, Map.toList(publishedUris))
                    next
                  },
                  None => publishedUris,
                }
              },
              None => publishedUris,
            }
          },
          None => publishedUris,
        }
      } else if (method == "textDocument/inlayHint") {
        match (idOpt) {
          Some(idJson) => match (jsonGetObject("params", msgJson)) {
            Some(params) => handleInlayHint(jsonToIdText(idJson), params, docs),
            None => void,
          },
          None => void,
        }
        publishedUris
      } else if (method == "textDocument/formatting") {
        debug("[LSP msg] handling formatting")
        match (idOpt) {
          Some(idJson) => match (jsonGetObject("params", msgJson)) {
            Some(params) => handleFormatting(jsonToIdText(idJson), params, docs),
            None => void,
          },
          None => void,
        }
        publishedUris
      } else if (method == "shutdown") {
        debug("[LSP msg] handling shutdown")
        match (idOpt) {
          Some(idJson) => sendResponse(jsonToIdText(idJson), "null"),
          None => void,
        }
        publishedUris
      } else if (method == "exit") {
        debug("[LSP msg] handling exit")
        shouldExit = true
        publishedUris
      } else {
        publishedUris
      }
    },
  }
}

let parseContentLength = (header: String) => {
  let lines = String.split("\r\n", header)
  let rec find = (idx: Number) => {
    if (idx >= Array.length(lines)) {
      None
    } else {
      let line = Array.get(idx, lines)
      if (String.startsWith("Content-Length:", line)) {
        let raw = String.slice(String.length("Content-Length:"), line)
        match (Number.parseInt(String.trim(raw), radix=10)) {
          Ok(n) => Some(n),
          Err(_) => None,
        }
      } else {
        find(idx + 1)
      }
    }
  }
  find(0)
}

let findHeaderEnd = (buffer: Bytes) => {
  let len = Bytes.length(buffer)
  let mut i = 0
  let mut found: Option<Number> = None
  while (i + 3 < len && found == None) {
    let b0 = Uint8.toNumber(Bytes.getUint8(i, buffer))
    let b1 = Uint8.toNumber(Bytes.getUint8(i + 1, buffer))
    let b2 = Uint8.toNumber(Bytes.getUint8(i + 2, buffer))
    let b3 = Uint8.toNumber(Bytes.getUint8(i + 3, buffer))
    if (b0 == 13 && b1 == 10 && b2 == 13 && b3 == 10) {
      found = Some(i)
    }
    i += 1
  }
  found
}

let tryExtractMessage = (buffer: Bytes) => {
  match (findHeaderEnd(buffer)) {
    None => (None, buffer),
    Some(headerEnd) => {
      let headerBytes = Bytes.slice(0, headerEnd, buffer)
      let header = Bytes.toString(headerBytes)
      let bodyStart = headerEnd + 4
      match (parseContentLength(header)) {
        None => (None, buffer),
        Some(len) => {
          let bufLen = Bytes.length(buffer)
          let totalNeeded = bodyStart + len
          if (bufLen < totalNeeded) {
            (None, buffer)
          } else {
            let bodyBytes = Bytes.slice(bodyStart, len, buffer)
            let restLen = bufLen - totalNeeded
            let rest = Bytes.slice(totalNeeded, restLen, buffer)
            (Some(Bytes.toString(bodyBytes)), rest)
          }
        },
      }
    },
  }
}

let readChunk = () => {
  match (File.fdRead(File.stdin, 4096)) {
    Ok((bytes, count)) => if (count <= 0) {
      None
    } else {
      let slice = Bytes.slice(0, count, bytes)
      Some(slice)
    },
    Err(_) => None,
  }
}

let rec loop = (
  buffer: Bytes,
  docs: Map.Map<String, String>,
  publishedUris: Map.Map<String, Bool>,
) => {
  if (shouldExit) {
    void
  } else {
  let (msgOpt, rest) = tryExtractMessage(buffer)
  match (msgOpt) {
    Some(msgText) => {
      match (Json.parse(msgText)) {
        Ok(msgJson) => {
          let nextPublished = handleMessage(msgJson, docs, publishedUris)
          loop(rest, docs, nextPublished)
        },
        Err(err) => {
          logErr("Failed to parse JSON: " ++ toString(err))
          loop(rest, docs, publishedUris)
        },
      }
    },
    None => {
      if (Bytes.length(rest) == 0 && runPendingInlayWarm(docs)) {
        loop(rest, docs, publishedUris)
      } else {
        match (readChunk()) {
          None => void,
          Some(chunk) => loop(Bytes.concat(buffer, chunk), docs, publishedUris),
        }
      }
    },
  }
  }
}

let main = () => {
  let docs = Map.make()
  let publishedUris = Map.make()
  loop(Bytes.empty, docs, publishedUris)
}

main()
