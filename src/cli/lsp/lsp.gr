module LSP

from "array" include Array
from "bytes" include Bytes
from "list" include List
from "map" include Map
from "number" include Number
from "string" include String
from "wasi/file" include File
from "json" include Json

from "../../core/source.gr" include Source
from "../../core/error.gr" include Error
from "../../module/module_system.gr" include ModuleSystem
from "./format.gr" include Format
from "./inlay.gr" include Inlay

let escapeJson = (s: String) => {
  let step1 = String.replaceAll("\\", "\\\\", s)
  let step2 = String.replaceAll("\"", "\\\"", step1)
  let step3 = String.replaceAll("\n", "\\n", step2)
  let step4 = String.replaceAll("\r", "\\r", step3)
  String.replaceAll("\t", "\\t", step4)
}

let logErr = (text: String) => {
  let _ = File.fdWrite(File.stderr, Bytes.fromString(text ++ "\n"))
  void
}

let mut debugEnabled = true
let mut workspaceRootPath: Option<String> = None
let v0StdRoot = "c:/GIT/workman/std"
let mut inlayDebugEnabled = false
let mut formatDebugEnabled = false

let debug = (text: String) => {
  if (debugEnabled) {
    logErr(text)
  } else {
    void
  }
}

let debugInlay = (text: String) => {
  if (inlayDebugEnabled) {
    logErr(text)
  } else {
    void
  }
}

let debugFormat = (text: String) => {
  if (formatDebugEnabled) {
    logErr(text)
  } else {
    void
  }
}

let writeStdout = (text: String) => {
  let _ = File.fdWrite(File.stdout, Bytes.fromString(text))
  void
}

let sendResponse = (idText: String, resultJson: String) => {
  let body = "{\"jsonrpc\":\"2.0\",\"id\":"
    ++ idText
    ++ ",\"result\":"
    ++ resultJson
    ++ "}"
  let header = "Content-Length: " ++ toString(String.length(body)) ++ "\r\n\r\n"
  writeStdout(header ++ body)
}

let sendNotification = (method: String, paramsJson: String) => {
  let body = "{\"jsonrpc\":\"2.0\",\"method\":\""
    ++ escapeJson(method)
    ++ "\",\"params\":"
    ++ paramsJson
    ++ "}"
  let header = "Content-Length: " ++ toString(String.length(body)) ++ "\r\n\r\n"
  writeStdout(header ++ body)
}

let jsonToIdText = (idJson: Json.Json) => match (idJson) {
  Json.JsonNumber(n) => toString(n),
  Json.JsonString(s) => "\"" ++ escapeJson(s) ++ "\"",
  _ => "null",
}

let jsonGet = (key: String, json: Json.Json) => match (json) {
  Json.JsonObject(entries) => {
    let rec find = items => match (items) {
      [] => None,
      [(k, v), ...rest] => if (k == key) {
        Some(v)
      } else {
        find(rest)
      },
    }
    find(entries)
  },
  _ => None,
}

let jsonGetString = (key: String, json: Json.Json) =>
  match (jsonGet(key, json)) {
    Some(Json.JsonString(s)) => Some(s),
    _ => None,
  }

let jsonGetNumber = (key: String, json: Json.Json) =>
  match (jsonGet(key, json)) {
    Some(Json.JsonNumber(n)) => Some(n),
    _ => None,
  }

let jsonGetObject = (key: String, json: Json.Json) =>
  match (jsonGet(key, json)) {
    Some(Json.JsonObject(items)) => Some(Json.JsonObject(items)),
    _ => None,
  }

let jsonGetArray = (key: String, json: Json.Json) =>
  match (jsonGet(key, json)) {
    Some(Json.JsonArray(arr)) => Some(arr),
    _ => None,
  }

let positionToOffset = (source: String, line0: Number, col0: Number) => {
  let targetLine = line0 + 1
  let targetCol = col0
  let len = String.length(source)
  let rec loop = (idx: Number, line: Number, col: Number) => {
    if (idx >= len) {
      len
    } else if (line == targetLine && col == targetCol) {
      idx
    } else {
      let ch = String.charAt(idx, source)
      if (ch == '\n') {
        loop(idx + 1, line + 1, 0)
      } else {
        loop(idx + 1, line, col + 1)
      }
    }
  }
  loop(0, 1, 0)
}

let decodeUriPath = (uriPath: String) => {
  let step0 = String.replaceAll("%20", " ", uriPath)
  let step1 = String.replaceAll("%3A", ":", step0)
  String.replaceAll("%5C", "\\", step1)
}

let uriToPath = (uri: String) => {
  if (String.startsWith("file:///", uri)) {
    let raw = String.slice(String.length("file:///"), uri)
    let decoded = decodeUriPath(raw)
    let withDrive = if (String.length(decoded) > 1 && String.charAt(1, decoded) == ':') {
      decoded
    } else if (String.length(decoded) > 2 && String.charAt(2, decoded) == ':') {
      String.slice(1, decoded)
    } else {
      decoded
    }
    String.replaceAll("\\", "/", withDrive)
  } else if (String.startsWith("file://", uri)) {
    let raw = String.slice(String.length("file://"), uri)
    String.replaceAll("\\", "/", decodeUriPath(raw))
  } else {
    String.replaceAll("\\", "/", uri)
  }
}

let isAbsolutePath = (path: String) => {
  String.startsWith("/", path)
    || (String.length(path) > 1 && String.charAt(1, path) == ':')
}

let dirname = (path: String) => {
  let normalized = String.replaceAll("\\", "/", path)
  let mut i = String.length(normalized) - 1
  let mut cut = -1
  while (i >= 0 && cut < 0) {
    if (String.charAt(i, normalized) == '/') {
      cut = i
    }
    i -= 1
  }
  if (cut < 0) {
    "."
  } else if (cut == 0) {
    "/"
  } else {
    String.slice(0, end=cut, normalized)
  }
}

let toWorkspacePath = (path: String) => {
  match (workspaceRootPath) {
    Some(root) => {
      let rootWithSlash = if (String.endsWith("/", root)) {
        root
      } else {
        root ++ "/"
      }
      if (String.startsWith(rootWithSlash, path)) {
        String.slice(String.length(rootWithSlash), path)
      } else if (path == root) {
        "."
      } else {
        path
      }
    },
    None => path,
  }
}

let pathToUri = (path: String) => {
  let normalized = String.replaceAll("\\", "/", path)
  let step1 = String.replaceAll(" ", "%20", normalized)
  let encoded = String.replaceAll(":", "%3A", step1)
  if (String.length(normalized) > 1 && String.charAt(1, normalized) == ':') {
    "file:///" ++ encoded
  } else {
    "file://" ++ encoded
  }
}

let stageToString = (stage: Error.Stage) => match (stage) {
  _ => Error.stageName(stage),
}

let diagnosticToJson = (diag: Error.CompilerError) => {
  let line0 = if (diag.span.line > 0) { diag.span.line - 1 } else { 0 }
  let col0 = if (diag.span.col > 0) { diag.span.col - 1 } else { 0 }
  let endCol0 = if (diag.span.end > diag.span.start) {
    col0 + (diag.span.end - diag.span.start)
  } else {
    col0 + 1
  }
  let sourceTag = "workman/" ++ stageToString(diag.stage)
  "{\"range\":{\"start\":{\"line\":"
    ++ toString(line0)
    ++ ",\"character\":"
    ++ toString(col0)
    ++ "},\"end\":{\"line\":"
    ++ toString(line0)
    ++ ",\"character\":"
    ++ toString(endCol0)
    ++ "}},\"severity\":1,\"source\":\""
    ++ escapeJson(sourceTag)
    ++ "\",\"message\":\""
    ++ escapeJson(diag.message)
    ++ "\"}"
}

let publishDiagnostics = (uri: String, diagnostics: List<Error.CompilerError>) => {
  debug(
    "[LSP diag] publish uri="
      ++ uri
      ++ " count="
      ++ toString(List.length(diagnostics))
  )
  let diagnosticsJson = "["
    ++ Array.join(",", Array.fromList(List.map(diagnosticToJson, diagnostics)))
    ++ "]"
  let params = "{\"uri\":\""
    ++ escapeJson(uri)
    ++ "\",\"diagnostics\":"
    ++ diagnosticsJson
    ++ "}"
  sendNotification("textDocument/publishDiagnostics", params)
}

let docsToOverrides = (docs: Map.Map<String, String>) => {
  let overrides = Map.make()
  List.forEach(((uri, source)) => {
    let path = toWorkspacePath(uriToPath(uri))
    Map.set(path, source, overrides)
  }, Map.toList(docs))
  overrides
}

let pathUriLookup = (docs: Map.Map<String, String>) => {
  let lookup = Map.make()
  List.forEach(((uri, _)) => {
    let path = toWorkspacePath(uriToPath(uri))
    Map.set(path, uri, lookup)
  }, Map.toList(docs))
  lookup
}

let publishGraphDiagnostics = (
  entryUri: String,
  docs: Map.Map<String, String>,
  publishedUris: Map.Map<String, Bool>,
) => {
  let absEntryPath = uriToPath(entryUri)
  let rootDir = match (workspaceRootPath) {
    Some(root) => root,
    None => dirname(absEntryPath),
  }
  let entryPath = toWorkspacePath(uriToPath(entryUri))
  debug(
    "[LSP diag] entryUri="
      ++ entryUri
      ++ " entryPath="
      ++ entryPath
      ++ " workspaceRoot="
      ++ match (workspaceRootPath) {
        Some(root) => root,
        None => "<none>",
      }
  )
  let overrides = docsToOverrides(docs)
  let uriLookup = pathUriLookup(docs)
  debug("[LSP diag] overrideCount=" ++ toString(List.length(Map.toList(overrides))))
  debug("[LSP diag] stdRoot=" ++ v0StdRoot)
  let graph = ModuleSystem.buildGraph(
    entryPath,
    options={
      ...ModuleSystem.defaultOptions(),
      rootDir,
      stdRoots: [v0StdRoot],
      sourceOverrides: overrides,
    }
  )
  debug("[LSP diag] topo=" ++ Array.join(" -> ", Array.fromList(graph.topo)))
  let nextPublished = Map.make()
  List.forEach(((modulePath, diagnostics)) => {
    debug(
      "[LSP diag] module="
        ++ modulePath
        ++ " diagnostics="
        ++ toString(List.length(diagnostics))
    )
    let uri = match (Map.get(modulePath, uriLookup)) {
      Some(mappedUri) => mappedUri,
      None => match (workspaceRootPath) {
        Some(root) when !isAbsolutePath(modulePath) => pathToUri(root ++ "/" ++ modulePath),
        _ => pathToUri(modulePath),
      },
    }
    publishDiagnostics(uri, diagnostics)
    List.forEach((diag: Error.CompilerError) => {
      debug(
        "[LSP diag] detail module="
          ++ modulePath
          ++ " uri="
          ++ uri
          ++ " message="
          ++ diag.message
      )
    }, diagnostics)
    Map.set(uri, true, nextPublished)
  }, Map.toList(graph.diagnosticsById))

  List.forEach(((uri, _)) => {
    if (Map.get(uri, nextPublished) == None) {
      publishDiagnostics(uri, [])
    } else {
      void
    }
  }, Map.toList(publishedUris))

  nextPublished
}

let handleInitialize = (idText: String) => {
  let result = "{"
    ++ "\"capabilities\":{"
    ++ "\"textDocumentSync\":{\"openClose\":true,\"change\":1},"
    ++ "\"inlayHintProvider\":true,"
    ++ "\"documentFormattingProvider\":true"
    ++ "},"
    ++ "\"serverInfo\":{\"name\":\"workman-lsp\",\"version\":\"0.0.1\"}"
    ++ "}"
  sendResponse(idText, result)
}

let handleInlayHint = (
  idText: String,
  params: Json.Json,
  docs: Map.Map<String, String>,
) => {
  let uriOpt = match (jsonGetObject("textDocument", params)) {
    Some(obj) => jsonGetString("uri", obj),
    None => None,
  }
  match (uriOpt) {
    None => sendResponse(idText, "[]"),
    Some(uri) => {
      match (Map.get(uri, docs)) {
        None => sendResponse(idText, "[]"),
        Some(source) => {
          let rangeOpt = jsonGetObject("range", params)
          let rangeStart = match (rangeOpt) {
            Some(rangeObj) => {
              let startObj = jsonGetObject("start", rangeObj)
              match (startObj) {
                Some(s) => {
                  let line = match (jsonGetNumber("line", s)) {
                    Some(n) => n,
                    None => 0,
                  }
                  let ch = match (jsonGetNumber("character", s)) {
                    Some(n) => n,
                    None => 0,
                  }
                  positionToOffset(source, line, ch)
                },
                None => 0,
              }
            },
            None => 0,
          }
          let rangeEnd = match (rangeOpt) {
            Some(rangeObj) => {
              let endObj = jsonGetObject("end", rangeObj)
              match (endObj) {
                Some(e) => {
                  let line = match (jsonGetNumber("line", e)) {
                    Some(n) => n,
                    None => 0,
                  }
                  let ch = match (jsonGetNumber("character", e)) {
                    Some(n) => n,
                    None => 0,
                  }
                  positionToOffset(source, line, ch)
                },
                None => String.length(source),
              }
            },
            None => String.length(source),
          }
          let hintsJson = Inlay.inlayHintsForSource(
            source,
            rangeStart,
            rangeEnd,
            debugInlay,
            escapeJson,
            inlayDebugEnabled
          )
          sendResponse(idText, hintsJson)
        },
      }
    },
  }
}

let handleFormatting = (
  idText: String,
  params: Json.Json,
  docs: Map.Map<String, String>,
) => {
  let uriOpt = match (jsonGetObject("textDocument", params)) {
    Some(obj) => jsonGetString("uri", obj),
    None => None,
  }
  match (uriOpt) {
    None => sendResponse(idText, "[]"),
    Some(uri) => {
      match (Map.get(uri, docs)) {
        None => sendResponse(idText, "[]"),
        Some(source) => {
          let editsJson = Format.formattingEditsForSource(
            source,
            debugFormat,
            escapeJson
          )
          sendResponse(idText, editsJson)
        },
      }
    },
  }
}

let handleMessage = (
  msgJson: Json.Json,
  docs: Map.Map<String, String>,
  publishedUris: Map.Map<String, Bool>,
) => {
  let idOpt = jsonGet("id", msgJson)
  let methodOpt = jsonGetString("method", msgJson)
  match (methodOpt) {
    None => publishedUris,
    Some(method) => {
      if (method == "initialize") {
        match (jsonGetObject("params", msgJson)) {
          Some(params) => {
            workspaceRootPath = match (jsonGetString("rootUri", params)) {
              Some(rootUri) => Some(uriToPath(rootUri)),
              None => workspaceRootPath,
            }
            debug(
              "[LSP init] workspaceRoot="
                ++ match (workspaceRootPath) {
                  Some(root) => root,
                  None => "<none>",
                }
            )
          },
          None => void,
        }
        match (idOpt) {
          Some(idJson) => handleInitialize(jsonToIdText(idJson)),
          None => void,
        }
        publishedUris
      } else if (method == "textDocument/didOpen") {
        match (jsonGetObject("params", msgJson)) {
          Some(params) => {
            match (jsonGetObject("textDocument", params)) {
              Some(doc) => {
                match (jsonGetString("uri", doc)) {
                  Some(uri) => match (jsonGetString("text", doc)) {
                    Some(text) => {
                      Map.set(uri, text, docs)
                      if (workspaceRootPath == None) {
                        workspaceRootPath = Some(dirname(uriToPath(uri)))
                        debug(
                          "[LSP didOpen] inferred workspaceRoot="
                            ++ match (workspaceRootPath) {
                              Some(root) => root,
                              None => "<none>",
                            }
                        )
                      } else {
                        void
                      }
                      publishGraphDiagnostics(uri, docs, publishedUris)
                    },
                    None => publishedUris,
                  },
                  None => publishedUris,
                }
              },
              None => publishedUris,
            }
          },
          None => publishedUris,
        }
      } else if (method == "textDocument/didChange") {
        match (jsonGetObject("params", msgJson)) {
          Some(params) => {
            let uriOpt = match (jsonGetObject("textDocument", params)) {
              Some(doc) => jsonGetString("uri", doc),
              None => None,
            }
            let changesOpt = jsonGetArray("contentChanges", params)
            match (uriOpt) {
              Some(uri) => match (changesOpt) {
                Some(changes) => {
                  match (changes) {
                    [Json.JsonObject(first), ..._] => {
                      match (jsonGetString("text", Json.JsonObject(first))) {
                        Some(text) => {
                          Map.set(uri, text, docs)
                          if (workspaceRootPath == None) {
                            workspaceRootPath = Some(dirname(uriToPath(uri)))
                            debug(
                              "[LSP didChange] inferred workspaceRoot="
                                ++ match (workspaceRootPath) {
                                  Some(root) => root,
                                  None => "<none>",
                                }
                            )
                          } else {
                            void
                          }
                          publishGraphDiagnostics(uri, docs, publishedUris)
                        },
                        None => publishedUris,
                      }
                    },
                    _ => publishedUris,
                  }
                },
                None => publishedUris,
              },
              None => publishedUris,
            }
          },
          None => publishedUris,
        }
      } else if (method == "textDocument/didClose") {
        match (jsonGetObject("params", msgJson)) {
          Some(params) => {
            match (jsonGetObject("textDocument", params)) {
              Some(doc) => {
                match (jsonGetString("uri", doc)) {
                  Some(uri) => {
                    Map.remove(uri, docs)
                    publishDiagnostics(uri, [])
                    let next = Map.make()
                    List.forEach(((u, _)) => {
                      if (u == uri) {
                        void
                      } else {
                        Map.set(u, true, next)
                      }
                    }, Map.toList(publishedUris))
                    next
                  },
                  None => publishedUris,
                }
              },
              None => publishedUris,
            }
          },
          None => publishedUris,
        }
      } else if (method == "textDocument/inlayHint") {
        match (idOpt) {
          Some(idJson) => match (jsonGetObject("params", msgJson)) {
            Some(params) => handleInlayHint(jsonToIdText(idJson), params, docs),
            None => void,
          },
          None => void,
        }
        publishedUris
      } else if (method == "textDocument/formatting") {
        match (idOpt) {
          Some(idJson) => match (jsonGetObject("params", msgJson)) {
            Some(params) => handleFormatting(jsonToIdText(idJson), params, docs),
            None => void,
          },
          None => void,
        }
        publishedUris
      } else if (method == "shutdown") {
        match (idOpt) {
          Some(idJson) => sendResponse(jsonToIdText(idJson), "null"),
          None => void,
        }
        publishedUris
      } else if (method == "exit") {
        publishedUris
      } else {
        publishedUris
      }
    },
  }
}

let parseContentLength = (header: String) => {
  let lines = String.split("\r\n", header)
  let rec find = (idx: Number) => {
    if (idx >= Array.length(lines)) {
      None
    } else {
      let line = Array.get(idx, lines)
      if (String.startsWith("Content-Length:", line)) {
        let raw = String.slice(String.length("Content-Length:"), line)
        match (Number.parseInt(String.trim(raw), radix=10)) {
          Ok(n) => Some(n),
          Err(_) => None,
        }
      } else {
        find(idx + 1)
      }
    }
  }
  find(0)
}

let tryExtractMessage = (buffer: String) => {
  match (String.indexOf("\r\n\r\n", buffer)) {
    None => (None, buffer),
    Some(headerEnd) => {
      let header = String.slice(0, end=headerEnd, buffer)
      let bodyStart = headerEnd + 4
      match (parseContentLength(header)) {
        None => (None, buffer),
        Some(len) => {
          let totalNeeded = bodyStart + len
          if (String.length(buffer) < totalNeeded) {
            (None, buffer)
          } else {
            let body = String.slice(bodyStart, end=totalNeeded, buffer)
            let rest = String.slice(
              totalNeeded,
              end=String.length(buffer),
              buffer
            )
            (Some(body), rest)
          }
        },
      }
    },
  }
}

let readChunk = () => {
  match (File.fdRead(File.stdin, 4096)) {
    Ok((bytes, count)) => if (count <= 0) {
      None
    } else {
      let slice = Bytes.slice(0, count, bytes)
      Some(Bytes.toString(slice))
    },
    Err(_) => None,
  }
}

let rec loop = (
  buffer: String,
  docs: Map.Map<String, String>,
  publishedUris: Map.Map<String, Bool>,
) => {
  let (msgOpt, rest) = tryExtractMessage(buffer)
  match (msgOpt) {
    Some(msgText) => {
      match (Json.parse(msgText)) {
        Ok(msgJson) => {
          let nextPublished = handleMessage(msgJson, docs, publishedUris)
          loop(rest, docs, nextPublished)
        },
        Err(err) => {
          logErr("Failed to parse JSON: " ++ toString(err))
          loop(rest, docs, publishedUris)
        },
      }
    },
    None => {
      match (readChunk()) {
        None => void,
        Some(chunk) => loop(buffer ++ chunk, docs, publishedUris),
      }
    },
  }
}

let main = () => {
  let docs = Map.make()
  let publishedUris = Map.make()
  loop("", docs, publishedUris)
}

main()
