module LSP

from "array" include Array
from "bytes" include Bytes
from "list" include List
from "map" include Map
from "number" include Number
from "string" include String
from "uint8" include Uint8
from "wasi/file" include File
from "wasi/process" include Process
from "wasi/time" include Time
from "int64" include Int64
from "json" include Json

from "../../core/source.gr" include Source
from "../../core/error.gr" include Error
from "../../core/module_infer.gr" include ModuleInfer
from "../../module/module_system.gr" include ModuleSystem
from "./format.gr" include Format
from "./inlay.gr" include Inlay
from "./layer1/type_display.gr" include TypeDisplay
from "./layer1/symbol_service.gr" include SymbolService

let escapeJson = (s: String) => {
  let step1 = String.replaceAll("\\", "\\\\", s)
  let step2 = String.replaceAll("\"", "\\\"", step1)
  let step3 = String.replaceAll("\n", "\\n", step2)
  let step4 = String.replaceAll("\r", "\\r", step3)
  String.replaceAll("\t", "\\t", step4)
}

let logErr = (text: String) => {
  let _ = File.fdWrite(File.stderr, Bytes.fromString(text ++ "\n"))
  void
}

let hasArg = (flag: String) => {
  match (Process.argv()) {
    Err(_) => false,
    Ok(args) => {
      Array.reduce((found, arg) => {
        if (found) {
          true
        } else {
          arg == flag
        }
      }, false, args)
    },
  }
}

let argValue = (flag: String) => {
  match (Process.argv()) {
    Err(_) => None,
    Ok(args) => {
      let rec loop = (idx: Number) => {
        if (idx >= Array.length(args)) {
          None
        } else if (Array.get(idx, args) == flag) {
          if (idx + 1 < Array.length(args)) {
            Some(Array.get(idx + 1, args))
          } else {
            None
          }
        } else {
          loop(idx + 1)
        }
      }
      loop(0)
    },
  }
}

let isInlayWorker = hasArg("--inlay-worker")
let _ = logErr("[LSP] isInlayWorker=" ++ (if (isInlayWorker) {
  "true"
} else {
  "false"
}))

let envLookup = (name: String) => {
  match (Process.env()) {
    Err(_) => None,
    Ok(vars) => {
      let prefix = name ++ "="
      let prefixLen = String.length(prefix)
      Array.reduce((acc, entry) => {
        match (acc) {
          Some(_) => acc,
          None => if (String.startsWith(prefix, entry)) {
            Some(String.slice(prefixLen, entry))
          } else {
            None
          },
        }
      }, None, vars)
    },
  }
}

let mut debugEnabled = match (envLookup("WORKMAN_LSP_DEBUG")) {
  Some("0") => false,
  Some("false") => false,
  Some("False") => false,
  Some("FALSE") => false,
  Some(_) => true,
  None => false,
}
let mut workspaceRootPath: Option<String> = None
let defaultV0StdRoot = "c:/GIT/workman/std"
let v0StdRoot = match (argValue("--std-root")) {
  Some(path) => path,
  None => match (envLookup("WORKMAN_STD_ROOT")) {
    Some(path) => path,
    None => defaultV0StdRoot,
  },
}
let _ = logErr("[LSP] stdRoot=" ++ v0StdRoot)
let mut inlayDebugEnabled = false
let mut formatDebugEnabled = false
let timingEnabled = match (envLookup("WORKMAN_LSP_TIMING")) {
  Some("0") => false,
  Some("false") => false,
  Some("False") => false,
  Some("FALSE") => false,
  Some(_) => true,
  None => false,
}
let mut shouldExit = false
let inlayMaxSourceChars = 120000
let formatMaxSourceChars = 200000
let docVersions = Map.make()
let inlayCache: Map.Map<String, String> = Map.make()
let mut inlayCachedVersion: Map.Map<String, Number> = Map.make()
let cachedGraphNodes: Map.Map<String, ModuleSystem.ModuleNode> = Map.make()
let moduleSummaryCache: ModuleInfer.SummaryCache = ModuleInfer.emptySummaryCache()
let publishedDiagnosticsFingerprint: Map.Map<String, String> = Map.make()
let lineStartsCache: Map.Map<String, List<Number>> = Map.make()
let lineStartsCacheVersion: Map.Map<String, Number> = Map.make()
let mut graphEpoch = 0

record InferenceSnapshot {
  cacheKey: String,
  entryPath: String,
  graph: ModuleSystem.ModuleGraph,
  inferred: ModuleInfer.InferenceResult,
}

let inferenceCache: Map.Map<String, InferenceSnapshot> = Map.make()

let nowNs = () =>
  match (Time.monotonicTime()) {
    Ok(t) => t,
    Err(_) => 0L,
  }

let timing = (label: String, startNs: Int64, endNs: Int64) => {
  if (timingEnabled) {
    let ms = (Int64.toNumber(endNs) - Int64.toNumber(startNs)) / 1000000
    logErr("[LSP timing] " ++ label ++ " " ++ toString(ms) ++ "ms")
  } else {
    void
  }
}

let debug = (text: String) => {
  if (debugEnabled) {
    logErr(text)
  } else {
    void
  }
}

let debugInlay = (text: String) => {
  if (inlayDebugEnabled) {
    logErr(text)
  } else {
    void
  }
}

let debugFormat = (text: String) => {
  if (formatDebugEnabled) {
    logErr(text)
  } else {
    void
  }
}

let documentVersion = (uri: String) => match (Map.get(uri, docVersions)) {
  Some(v) => v,
  None => 0,
}

let computeInlayHints = (uri: String, source: String, version: Number) => {
  let sourceLen = String.length(source)
  if (sourceLen > inlayMaxSourceChars) {
    logErr(
      "[LSP inlay] skip uri="
        ++ uri
        ++ " sourceLen="
        ++ toString(sourceLen)
        ++ " exceeds max"
    )
    "[]"
  } else {
    logErr(
      "[LSP inlay] compute start uri="
        ++ uri
        ++ " v"
        ++ toString(version)
        ++ " sourceLen="
        ++ toString(sourceLen)
    )
    let hintsJson = Inlay.inlayHintsForSource(
      source,
      0,
      sourceLen,
      debugInlay,
      escapeJson,
      inlayDebugEnabled
    )
    Map.set(uri, hintsJson, inlayCache)
    Map.set(uri, version, inlayCachedVersion)
    logErr("[LSP inlay] compute done uri=" ++ uri ++ " v" ++ toString(version))
    hintsJson
  }
}

let warmInlayCache = (uri: String, source: String, version: Number) => {
  match (Map.get(uri, inlayCachedVersion)) {
    Some(v) when v == version => {
      logErr(
        "[LSP inlay] warm cache hit uri=" ++ uri ++ " v" ++ toString(version)
      )
    },
    _ => {
      logErr("[LSP inlay] warm start uri=" ++ uri ++ " v" ++ toString(version))
      let _ = computeInlayHints(uri, source, version)
      logErr("[LSP inlay] warm done uri=" ++ uri ++ " v" ++ toString(version))
    },
  }
}

let invalidateInlayCache = (uri: String) => {
  Map.remove(uri, inlayCache)
  Map.remove(uri, inlayCachedVersion)
}

let invalidateInferenceCache = () => {
  graphEpoch += 1
  List.forEach(((key, _)) => {
    Map.remove(key, inferenceCache)
  }, Map.toList(inferenceCache))
}

let docsStateKey = () => {
  toString(graphEpoch)
}

let writeStdout = (text: String) => {
  let _ = File.fdWrite(File.stdout, Bytes.fromString(text))
  void
}

let sendResponse = (idText: String, resultJson: String) => {
  let body = "{\"jsonrpc\":\"2.0\",\"id\":"
    ++ idText
    ++ ",\"result\":"
    ++ resultJson
    ++ "}"
  let bodyBytes = Bytes.fromString(body)
  let header = "Content-Length: "
    ++ toString(Bytes.length(bodyBytes))
    ++ "\r\n\r\n"
  writeStdout(header ++ body)
}

let sendNotification = (method: String, paramsJson: String) => {
  let body = "{\"jsonrpc\":\"2.0\",\"method\":\""
    ++ escapeJson(method)
    ++ "\",\"params\":"
    ++ paramsJson
    ++ "}"
  let bodyBytes = Bytes.fromString(body)
  let header = "Content-Length: "
    ++ toString(Bytes.length(bodyBytes))
    ++ "\r\n\r\n"
  writeStdout(header ++ body)
}

let jsonToIdText = (idJson: Json.Json) => match (idJson) {
  Json.JsonNumber(n) => toString(n),
  Json.JsonString(s) => "\"" ++ escapeJson(s) ++ "\"",
  _ => "null",
}

let jsonGet = (key: String, json: Json.Json) => match (json) {
  Json.JsonObject(entries) => {
    let rec find = items => match (items) {
      [] => None,
      [(k, v), ...rest] => if (k == key) {
        Some(v)
      } else {
        find(rest)
      },
    }
    find(entries)
  },
  _ => None,
}

let jsonGetString = (key: String, json: Json.Json) =>
  match (jsonGet(key, json)) {
    Some(Json.JsonString(s)) => Some(s),
    _ => None,
  }

let jsonGetNumber = (key: String, json: Json.Json) =>
  match (jsonGet(key, json)) {
    Some(Json.JsonNumber(n)) => Some(n),
    _ => None,
  }

let jsonGetObject = (key: String, json: Json.Json) =>
  match (jsonGet(key, json)) {
    Some(Json.JsonObject(items)) => Some(Json.JsonObject(items)),
    _ => None,
  }

let jsonGetArray = (key: String, json: Json.Json) =>
  match (jsonGet(key, json)) {
    Some(Json.JsonArray(arr)) => Some(arr),
    _ => None,
  }

let positionToOffset = (source: String, line0: Number, col0: Number) => {
  let targetLine = line0 + 1
  let targetCol = col0
  let len = String.length(source)
  let rec loop = (idx: Number, line: Number, col: Number) => {
    if (idx >= len) {
      len
    } else if (line == targetLine && col == targetCol) {
      idx
    } else {
      let ch = String.charAt(idx, source)
      if (ch == '\n') {
        loop(idx + 1, line + 1, 0)
      } else {
        loop(idx + 1, line, col + 1)
      }
    }
  }
  loop(0, 1, 0)
}

let buildLineStarts = (source: String) => {
  let len = String.length(source)
  let mut idx = 0
  let mut outRev: List<Number> = [0]
  while (idx < len) {
    if (String.charAt(idx, source) == '\n') {
      outRev = [idx + 1, ...outRev]
    } else {
      void
    }
    idx += 1
  }
  List.reverse(outRev)
}

let lineBoundsFor = (
  lineStarts: List<Number>,
  targetLine1: Number,
  source: String,
) => {
  let len = String.length(source)
  let rec loop = (starts: List<Number>, lineNum: Number) =>
    match (starts) {
      [] => None,
      [start] =>
        if (lineNum == targetLine1) {
          Some((start, len))
        } else {
          None
        },
      [start, nextStart, ...rest] =>
        if (lineNum == targetLine1) {
          let endExclusive = if (
            nextStart > 0
            && nextStart - 1 < len
            && String.charAt(nextStart - 1, source) == '\n'
          ) {
            nextStart - 1
          } else {
            nextStart
          }
          Some((start, endExclusive))
        } else {
          loop([nextStart, ...rest], lineNum + 1)
        },
    }
  loop(lineStarts, 1)
}

let lineStartsForDocument = (uri: String, source: String) => {
  let version = documentVersion(uri)
  match (Map.get(uri, lineStartsCacheVersion)) {
    Some(cachedVersion) when cachedVersion == version =>
      match (Map.get(uri, lineStartsCache)) {
        Some(starts) => starts,
        None => {
          let starts = buildLineStarts(source)
          Map.set(uri, starts, lineStartsCache)
          Map.set(uri, version, lineStartsCacheVersion)
          starts
        },
      },
    _ => {
      let starts = buildLineStarts(source)
      Map.set(uri, starts, lineStartsCache)
      Map.set(uri, version, lineStartsCacheVersion)
      starts
    },
  }
}

let positionToOffsetForUri = (
  uri: String,
  source: String,
  line0: Number,
  col0: Number,
) => {
  let targetLine1 = line0 + 1
  let targetCol = if (col0 < 0) { 0 } else { col0 }
  let lineStarts = lineStartsForDocument(uri, source)
  match (lineBoundsFor(lineStarts, targetLine1, source)) {
    Some((startOffset, endOffset)) => {
      let raw = startOffset + targetCol
      if (raw > endOffset) {
        endOffset
      } else {
        raw
      }
    },
    None => positionToOffset(source, line0, col0),
  }
}

let decodeUriPath = (uriPath: String) => {
  let step0 = String.replaceAll("%20", " ", uriPath)
  let step1 = String.replaceAll("%3A", ":", step0)
  String.replaceAll("%5C", "\\", step1)
}

let uriToPath = (uri: String) => {
  if (String.startsWith("file:///", uri)) {
    let raw = String.slice(String.length("file:///"), uri)
    let decoded = decodeUriPath(raw)
    let restoredAbs = if (
      String.length(decoded) > 1
      && String.charAt(1, decoded) == ':'
    ) {
      decoded
    } else if (String.length(decoded) > 2 && String.charAt(2, decoded) == ':') {
      String.slice(1, decoded)
    } else {
      "/" ++ decoded
    }
    String.replaceAll("\\", "/", restoredAbs)
  } else if (String.startsWith("file://", uri)) {
    let raw = String.slice(String.length("file://"), uri)
    String.replaceAll("\\", "/", decodeUriPath(raw))
  } else {
    String.replaceAll("\\", "/", uri)
  }
}

let isAbsolutePath = (path: String) => {
  String.startsWith("/", path)
    || String.length(path) > 1 && String.charAt(1, path) == ':'
}

let dirname = (path: String) => {
  let normalized = String.replaceAll("\\", "/", path)
  let mut i = String.length(normalized) - 1
  let mut cut = -1
  while (i >= 0 && cut < 0) {
    if (String.charAt(i, normalized) == '/') {
      cut = i
    }
    i -= 1
  }
  if (cut < 0) {
    "."
  } else if (cut == 0) {
    "/"
  } else {
    String.slice(0, end=cut, normalized)
  }
}

let toWorkspacePath = (path: String) => {
  match (workspaceRootPath) {
    Some(root) => {
      let rootWithSlash = if (String.endsWith("/", root)) {
        root
      } else {
        root ++ "/"
      }
      if (String.startsWith(rootWithSlash, path)) {
        String.slice(String.length(rootWithSlash), path)
      } else if (path == root) {
        "."
      } else {
        path
      }
    },
    None => path,
  }
}

let toRootRelativePath = (path: String, root: String) => {
  let normPath = String.replaceAll("\\", "/", path)
  let normRoot = String.replaceAll("\\", "/", root)
  let rootWithSlash = if (String.endsWith("/", normRoot)) {
    normRoot
  } else {
    normRoot ++ "/"
  }
  if (String.startsWith(rootWithSlash, normPath)) {
    String.slice(String.length(rootWithSlash), normPath)
  } else if (normPath == normRoot) {
    "."
  } else {
    normPath
  }
}

let pathToUri = (path: String) => {
  let normalized = String.replaceAll("\\", "/", path)
  let step1 = String.replaceAll(" ", "%20", normalized)
  let encoded = String.replaceAll(":", "%3A", step1)
  if (String.length(normalized) > 1 && String.charAt(1, normalized) == ':') {
    "file:///" ++ encoded
  } else {
    "file://" ++ encoded
  }
}

let hoverRangeJson = (source: String, span: Source.Span) => {
  let startLine0 = if (span.line > 0) {
    span.line - 1
  } else {
    0
  }
  let startCol0 = if (span.col > 0) {
    span.col - 1
  } else {
    0
  }
  let endPos = Source.offsetToLineCol(source, span.end)
  let endLine0 = if (endPos.line > 0) {
    endPos.line - 1
  } else {
    0
  }
  "{\"start\":{\"line\":"
    ++ toString(startLine0)
    ++ ",\"character\":"
    ++ toString(startCol0)
    ++ "},\"end\":{\"line\":"
    ++ toString(endLine0)
    ++ ",\"character\":"
    ++ toString(endPos.col)
    ++ "}}"
}

let hoverJsonForType = (
  source: String,
  typeAtOffset: ModuleInfer.TypeAtOffset,
) => {
  let renderedType = TypeDisplay.render(typeAtOffset.ty)
  "{\"contents\":{\"kind\":\"plaintext\",\"value\":\""
    ++ escapeJson("Type: " ++ renderedType)
    ++ "\"},\"range\":"
    ++ hoverRangeJson(source, typeAtOffset.span)
    ++ "}"
}

let hoverJsonNoType = (line0: Number, col0: Number, offset: Number) =>
  "{\"contents\":{\"kind\":\"plaintext\",\"value\":\""
    ++ escapeJson(
      "No type info at line "
        ++ toString(line0 + 1)
        ++ ", col "
        ++ toString(col0 + 1)
        ++ " (offset "
        ++ toString(offset)
        ++ ")"
    )
    ++ "\"}}"

let lspRangeJsonFromSpan = (span: Source.Span) => {
  let startLine0 = if (span.line > 0) {
    span.line - 1
  } else {
    0
  }
  let startCol0 = if (span.col > 0) {
    span.col - 1
  } else {
    0
  }
  let endCol0 = if (span.end > span.start) {
    startCol0 + (span.end - span.start)
  } else {
    startCol0 + 1
  }
  "{\"start\":{\"line\":"
    ++ toString(startLine0)
    ++ ",\"character\":"
    ++ toString(startCol0)
    ++ "},\"end\":{\"line\":"
    ++ toString(startLine0)
    ++ ",\"character\":"
    ++ toString(endCol0)
    ++ "}}"
}

let definitionJson = (modulePath: String, span: Source.Span) => {
  let uri = match (workspaceRootPath) {
    Some(root) when !isAbsolutePath(modulePath) => pathToUri(root ++ "/" ++ modulePath),
    _ => pathToUri(modulePath),
  }
  "{\"uri\":\""
    ++ escapeJson(uri)
    ++ "\",\"range\":"
    ++ lspRangeJsonFromSpan(span)
    ++ "}"
}

let stageToString = (stage: Error.Stage) => match (stage) {
  _ => Error.stageName(stage),
}

let diagnosticToJson = (diag: Error.CompilerError) => {
  let line0 = if (diag.span.line > 0) {
    diag.span.line - 1
  } else {
    0
  }
  let col0 = if (diag.span.col > 0) {
    diag.span.col - 1
  } else {
    0
  }
  let endCol0 = if (diag.span.end > diag.span.start) {
    col0 + (diag.span.end - diag.span.start)
  } else {
    col0 + 1
  }
  let sourceTag = "workman/" ++ stageToString(diag.stage)
  "{\"range\":{\"start\":{\"line\":"
    ++ toString(line0)
    ++ ",\"character\":"
    ++ toString(col0)
    ++ "},\"end\":{\"line\":"
    ++ toString(line0)
    ++ ",\"character\":"
    ++ toString(endCol0)
    ++ "}},\"severity\":"
    ++ toString(Error.severityToNumber(diag.severity))
    ++ ",\"source\":\""
    ++ escapeJson(sourceTag)
    ++ "\",\"message\":\""
    ++ escapeJson(diag.message)
    ++ "\"}"
}

let diagnosticFingerprint = (diagnostics: List<Error.CompilerError>) =>
  Array.join(
    "|",
    Array.fromList(
      List.map((diag: Error.CompilerError) =>
        toString(diag.span.line)
          ++ ":"
          ++ toString(diag.span.col)
          ++ ":"
          ++ toString(diag.span.start)
          ++ ":"
          ++ toString(diag.span.end)
          ++ ":"
          ++ toString(Error.severityToNumber(diag.severity))
          ++ ":"
          ++ stageToString(diag.stage)
          ++ ":"
          ++ diag.message, diagnostics)
    )
  )

let joinStrings = (sep: String, parts: List<String>) => {
  let rec loop = (remaining: List<String>, out: String) => {
    match (remaining) {
      [] => out,
      [head, ...rest] => if (out == "") {
        loop(rest, head)
      } else {
        loop(rest, out ++ sep ++ head)
      },
    }
  }
  loop(parts, "")
}

let publishDiagnostics = (uri: String, diagnostics: List<Error.CompilerError>) => {
  let nextFingerprint = diagnosticFingerprint(diagnostics)
  let prevFingerprint = match (Map.get(uri, publishedDiagnosticsFingerprint)) {
    Some(fp) => fp,
    None => "",
  }
  if (nextFingerprint == prevFingerprint) {
    debug("[LSP diag] skip unchanged uri=" ++ uri)
    false
  } else {
    if (List.length(diagnostics) > 0) {
      debug(
        "[LSP diag] publish uri="
          ++ uri
          ++ " count="
          ++ toString(List.length(diagnostics))
      )
    } else {
      void
    }
    let diagnosticsJson = "["
      ++ joinStrings(",", List.map(diagnosticToJson, diagnostics))
      ++ "]"
    let params = "{\"uri\":\""
      ++ escapeJson(uri)
      ++ "\",\"diagnostics\":"
      ++ diagnosticsJson
      ++ "}"
    sendNotification("textDocument/publishDiagnostics", params)
    Map.set(uri, nextFingerprint, publishedDiagnosticsFingerprint)
    true
  }
}

let docsToOverrides = (docs: Map.Map<String, String>) => {
  let overrides = Map.make()
  List.forEach(((uri, source)) => {
    let path = toWorkspacePath(uriToPath(uri))
    Map.set(path, source, overrides)
  }, Map.toList(docs))
  overrides
}

let pathUriLookup = (docs: Map.Map<String, String>) => {
  let lookup = Map.make()
  List.forEach(((uri, _)) => {
    let path = toWorkspacePath(uriToPath(uri))
    Map.set(path, uri, lookup)
  }, Map.toList(docs))
  lookup
}

let buildGraphForEntry = (
  entryUri: String,
  docs: Map.Map<String, String>,
) => {
  let absEntryPath = uriToPath(entryUri)
  let rootDir = match (workspaceRootPath) {
    Some(root) => root,
    None => dirname(absEntryPath),
  }
  let entryPath = toWorkspacePath(uriToPath(entryUri))
  let stdRootForGraph = toRootRelativePath(v0StdRoot, rootDir)
  let overrides = docsToOverrides(docs)
  let graph = ModuleSystem.buildGraph(
    entryPath,
    options={
      rootDir,
      stdRoots: [stdRootForGraph],
      sourceOverrides: overrides,
      debugLog: Some(debug),
      cachedNodes: cachedGraphNodes,
    }
  )
  (entryPath, graph)
}

let buildInferenceForEntry = (
  entryUri: String,
  docs: Map.Map<String, String>,
  caller: String="unknown",
) => {
  let cacheKey = entryUri ++ "::" ++ docsStateKey()
  match (Map.get(cacheKey, inferenceCache)) {
    Some(snapshot) => {
      debug(
        "[LSP infer] cache hit caller="
          ++ caller
          ++ " key="
          ++ snapshot.cacheKey
          ++ " uri="
          ++ entryUri
      )
      (snapshot.entryPath, snapshot.graph, snapshot.inferred)
    },
    _ => {
      let missStart = nowNs()
      debug(
        "[LSP infer] cache miss caller="
          ++ caller
          ++ " key="
          ++ cacheKey
          ++ " uri="
          ++ entryUri
      )
      let buildStart = nowNs()
      let (entryPath, graph) = buildGraphForEntry(entryUri, docs)
      let buildEnd = nowNs()
      timing("buildGraph caller=" ++ caller, buildStart, buildEnd)
      let inferStart = nowNs()
      let (inferred, nextSummaryCache, reusedModules, recomputedModules) =
        ModuleInfer.inferGraphWithCache(graph, moduleSummaryCache)
      List.forEach(((moduleId, entry)) => {
        Map.set(moduleId, entry, moduleSummaryCache)
      }, Map.toList(nextSummaryCache))
      let inferEnd = nowNs()
      timing("inferGraph caller=" ++ caller, inferStart, inferEnd)
      debug(
        "[LSP infer] modules reused="
          ++ toString(reusedModules)
          ++ " recomputed="
          ++ toString(recomputedModules)
          ++ " caller="
          ++ caller
      )
      let snapshot: InferenceSnapshot = { cacheKey, entryPath, graph, inferred }
      Map.set(cacheKey, snapshot, inferenceCache)
      let missEnd = nowNs()
      timing("cacheMissTotal caller=" ++ caller, missStart, missEnd)
      (entryPath, graph, inferred)
    },
  }
}

let publishGraphDiagnostics = (
  entryUri: String,
  docs: Map.Map<String, String>,
  publishedUris: Map.Map<String, Bool>,
) => {
  let publishStart = nowNs()
  let (entryPath, graph, inferred) = buildInferenceForEntry(entryUri, docs, caller="diag")
  let uriLookup = pathUriLookup(docs)
  List.forEach(((moduleId, node)) => {
    Map.set(moduleId, node, cachedGraphNodes)
  }, Map.toList(graph.nodes))
  debug(
    "[LSP diag] entry="
      ++ entryPath
      ++ " topo="
      ++ toString(List.length(graph.topo))
      ++ " cached="
      ++ toString(List.length(Map.toList(cachedGraphNodes)))
  )
  let nextPublished = Map.make()
  List.forEach(
    ((modulePath, diagnostics)) => {
      let uri = match (Map.get(modulePath, uriLookup)) {
        Some(mappedUri) => mappedUri,
        None => match (workspaceRootPath) {
          Some(root) when !isAbsolutePath(modulePath) =>
            pathToUri(root ++ "/" ++ modulePath),
          _ => pathToUri(modulePath),
        },
      }
      let mergedDiagnostics = diagnostics
      let didPublish = publishDiagnostics(uri, mergedDiagnostics)
      if (didPublish && List.length(mergedDiagnostics) > 0) {
        List.forEach((diag: Error.CompilerError) => {
          debug(
            "[LSP diag] module=" ++ modulePath ++ " message=" ++ diag.message
          )
        }, mergedDiagnostics)
      } else {
        void
      }
      Map.set(uri, true, nextPublished)
    },
    Map.toList(inferred.diagnosticsById)
  )

  List.forEach(((uri, _)) => {
    if (Map.get(uri, nextPublished) == None && Map.get(uri, docs) == None) {
      debug("[LSP diag] clearing stale diagnostics uri=" ++ uri)
      let _published = publishDiagnostics(uri, [])
      void
    } else {
      void
    }
  }, Map.toList(publishedUris))

  let publishEnd = nowNs()
  timing("publishGraphDiagnostics", publishStart, publishEnd)
  nextPublished
}

let handleInitialize = (idText: String) => {
  let caps = "\"textDocumentSync\":{\"openClose\":true,\"change\":1},\"inlayHintProvider\":true"
    ++ (if (isInlayWorker) {
      ""
    } else {
      ",\"documentFormattingProvider\":true,\"hoverProvider\":true,\"definitionProvider\":true"
    })
  let result = "{"
    ++ "\"capabilities\":{"
    ++ caps
    ++ "},"
    ++ "\"serverInfo\":{\"name\":\"workman-lsp\",\"version\":\"0.0.1\"}"
    ++ "}"
  sendResponse(idText, result)
}

let handleInlayHint = (
  idText: String,
  params: Json.Json,
  docs: Map.Map<String, String>,
) => {
  let uriOpt = match (jsonGetObject("textDocument", params)) {
    Some(obj) => jsonGetString("uri", obj),
    None => None,
  }
  match (uriOpt) {
    None => {
      logErr("[LSP inlay] hint request missing uri")
      sendResponse(idText, "[]")
    },
    Some(uri) => {
      let version = documentVersion(uri)
      logErr("[LSP inlay] hint uri=" ++ uri ++ " v" ++ toString(version))
      match (Map.get(uri, inlayCachedVersion)) {
        Some(v) when v == version => {
          match (Map.get(uri, inlayCache)) {
            Some(cached) => {
              logErr(
                "[LSP inlay] cache hit uri=" ++ uri ++ " v" ++ toString(version)
              )
              sendResponse(idText, cached)
            },
            None => {
              logErr("[LSP inlay] cache hit but empty uri=" ++ uri)
              sendResponse(idText, "[]")
            },
          }
        },
        _ => {
          match (Map.get(uri, docs)) {
            None => {
              logErr("[LSP inlay] doc not open uri=" ++ uri)
              sendResponse(idText, "[]")
            },
            Some(source) => {
              logErr(
                "[LSP inlay] computing uri=" ++ uri ++ " v" ++ toString(version)
              )
              let hintsJson = computeInlayHints(uri, source, version)
              sendResponse(idText, hintsJson)
            },
          }
        },
      }
    },
  }
}

let handleHover = (
  idText: String,
  params: Json.Json,
  docs: Map.Map<String, String>,
) => {
  let uriOpt = match (jsonGetObject("textDocument", params)) {
    Some(obj) => jsonGetString("uri", obj),
    None => None,
  }
  let positionOpt = jsonGetObject("position", params)
  let line0Opt = match (positionOpt) {
    Some(pos) => jsonGetNumber("line", pos),
    None => None,
  }
  let col0Opt = match (positionOpt) {
    Some(pos) => jsonGetNumber("character", pos),
    None => None,
  }
  match ((uriOpt, line0Opt, col0Opt)) {
    (Some(uri), Some(line0), Some(col0)) => {
      match (Map.get(uri, docs)) {
        Some(source) => {
          let hoverStart = nowNs()
          let offset = positionToOffsetForUri(uri, source, line0, col0)
          let modulePath = toWorkspacePath(uriToPath(uri))
          let buildStart = nowNs()
          let (_entryPath, graph, inferred) = buildInferenceForEntry(uri, docs, caller="hover")
          let buildEnd = nowNs()
          timing("hover.infer", buildStart, buildEnd)
          match (Map.get(modulePath, inferred.modules)) {
            Some(summary) => {
              let lookupStart = nowNs()
              match (ModuleInfer.typeAtOffsetInSummary(summary, offset)) {
                Some(found) => {
                  let lookupEnd = nowNs()
                  timing("hover.lookup", lookupStart, lookupEnd)
                  timing("hover.total", hoverStart, lookupEnd)
                  sendResponse(idText, hoverJsonForType(source, found))
                },
                None => {
                  let fallbackDecl = match (Map.get(modulePath, graph.nodes)) {
                    Some(node) => SymbolService.hoverDeclAtOffset(node.program, offset),
                    None => None,
                  }
                  let lookupEnd = nowNs()
                  timing("hover.lookup", lookupStart, lookupEnd)
                  timing("hover.total", hoverStart, lookupEnd)
                  match (fallbackDecl) {
                    Some(decl) =>
                      sendResponse(
                        idText,
                        "{\"contents\":{\"kind\":\"plaintext\",\"value\":\""
                          ++ escapeJson(decl.label)
                          ++ "\"},\"range\":"
                          ++ lspRangeJsonFromSpan(decl.span)
                          ++ "}"
                      ),
                    None =>
                      if (debugEnabled) {
                        sendResponse(idText, hoverJsonNoType(line0, col0, offset))
                      } else {
                        sendResponse(idText, "null")
                      },
                  }
                },
              }
            },
            None =>
              if (debugEnabled) {
                sendResponse(idText, hoverJsonNoType(line0, col0, offset))
              } else {
                sendResponse(idText, "null")
              },
          }
        },
        None =>
          if (debugEnabled) {
            sendResponse(idText, "{\"contents\":{\"kind\":\"plaintext\",\"value\":\"No open document for URI\"}}")
          } else {
            sendResponse(idText, "null")
          },
      }
    },
    _ =>
      if (debugEnabled) {
        sendResponse(idText, "{\"contents\":{\"kind\":\"plaintext\",\"value\":\"Malformed hover request\"}}")
      } else {
        sendResponse(idText, "null")
      },
  }
}

let handleDefinition = (
  idText: String,
  params: Json.Json,
  docs: Map.Map<String, String>,
) => {
  let uriOpt = match (jsonGetObject("textDocument", params)) {
    Some(obj) => jsonGetString("uri", obj),
    None => None,
  }
  let positionOpt = jsonGetObject("position", params)
  let line0Opt = match (positionOpt) {
    Some(pos) => jsonGetNumber("line", pos),
    None => None,
  }
  let col0Opt = match (positionOpt) {
    Some(pos) => jsonGetNumber("character", pos),
    None => None,
  }
  match ((uriOpt, line0Opt, col0Opt)) {
    (Some(uri), Some(line0), Some(col0)) =>
      match (Map.get(uri, docs)) {
        Some(source) => {
          let offset = positionToOffsetForUri(uri, source, line0, col0)
          let (entryPath, graph, _inferred) = buildInferenceForEntry(uri, docs, caller="definition")
          match (SymbolService.findDefinitionAtOffset(graph, entryPath, source, offset)) {
            Some(found) => sendResponse(idText, "[" ++ definitionJson(found.modulePath, found.span) ++ "]"),
            None => sendResponse(idText, "[]"),
          }
        },
        None => sendResponse(idText, "[]"),
      },
    _ => sendResponse(idText, "[]"),
  }
}

let handleFormatting = (
  idText: String,
  params: Json.Json,
  docs: Map.Map<String, String>,
) => {
  debug("[LSP format] request received")
  let uriOpt = match (jsonGetObject("textDocument", params)) {
    Some(obj) => jsonGetString("uri", obj),
    None => None,
  }
  match (uriOpt) {
    None => {
      debug("[LSP format] missing URI, returning empty")
      sendResponse(idText, "[]")
      debug("[LSP format] done status=missing_uri")
    },
    Some(uri) => {
      debug("[LSP format] start uri=" ++ uri)
      match (Map.get(uri, docs)) {
        None => {
          debug("[LSP format] document not open, returning empty uri=" ++ uri)
          sendResponse(idText, "[]")
          debug("[LSP format] done uri=" ++ uri ++ " status=document_not_open")
        },
        Some(source) => {
          let sourceLen = String.length(source)
          if (sourceLen > formatMaxSourceChars) {
            debug(
              "[LSP format] skipped uri="
                ++ uri
                ++ " reason=source_too_large chars="
                ++ toString(sourceLen)
                ++ " limit="
                ++ toString(formatMaxSourceChars)
            )
            sendResponse(idText, "[]")
            debug(
              "[LSP format] done uri="
                ++ uri
                ++ " status=skipped_source_too_large chars="
                ++ toString(sourceLen)
            )
          } else {
            debug("[LSP format] building edits uri=" ++ uri)
            let editsJson = Format.formattingEditsForSource(
              source,
              debugFormat,
              escapeJson
            )
            debug("[LSP format] sending response uri=" ++ uri)
            sendResponse(idText, editsJson)
            debug(
              "[LSP format] done uri="
                ++ uri
                ++ " status=ok edits_json_chars="
                ++ toString(String.length(editsJson))
            )
          }
        },
      }
    },
  }
}

let handleMessage = (
  msgJson: Json.Json,
  docs: Map.Map<String, String>,
  publishedUris: Map.Map<String, Bool>,
) => {
  let idOpt = jsonGet("id", msgJson)
  let methodOpt = jsonGetString("method", msgJson)
  match (methodOpt) {
    None => publishedUris,
    Some(method) => {
      debug("[LSP msg] method=" ++ method)
      if (method == "initialize") {
        match (jsonGetObject("params", msgJson)) {
          Some(params) => {
            workspaceRootPath = match (jsonGetString("rootUri", params)) {
              Some(rootUri) => Some(uriToPath(rootUri)),
              None => workspaceRootPath,
            }
            debug("[LSP init] workspaceRoot=" ++ match (workspaceRootPath) {
              Some(root) => root,
              None => "<none>",
            })
          },
          None => void,
        }
        match (idOpt) {
          Some(idJson) => handleInitialize(jsonToIdText(idJson)),
          None => void,
        }
        publishedUris
      } else if (method == "textDocument/didOpen") {
        debug("[LSP msg] handling didOpen")
        match (jsonGetObject("params", msgJson)) {
          Some(params) => {
            match (jsonGetObject("textDocument", params)) {
              Some(doc) => {
                match (jsonGetString("uri", doc)) {
                  Some(uri) => match (jsonGetString("text", doc)) {
                    Some(text) => {
                      Map.set(uri, text, docs)
                      let version = match (jsonGetNumber("version", doc)) {
                        Some(v) => v,
                        None => 1,
                      }
                      Map.set(uri, version, docVersions)
                      let starts = buildLineStarts(text)
                      Map.set(uri, starts, lineStartsCache)
                      Map.set(uri, version, lineStartsCacheVersion)
                      invalidateInferenceCache()
                      if (isInlayWorker) {
                        warmInlayCache(uri, text, version)
                      } else {
                        void
                      }
                      if (workspaceRootPath == None) {
                        workspaceRootPath = Some(dirname(uriToPath(uri)))
                      } else {
                        void
                      }
                      if (!isInlayWorker) {
                        publishGraphDiagnostics(uri, docs, publishedUris)
                      } else {
                        publishedUris
                      }
                    },
                    None => publishedUris,
                  },
                  None => publishedUris,
                }
              },
              None => publishedUris,
            }
          },
          None => publishedUris,
        }
      } else if (method == "textDocument/didChange") {
        match (jsonGetObject("params", msgJson)) {
          Some(params) => {
            let textDocOpt = jsonGetObject("textDocument", params)
            let uriOpt = match (textDocOpt) {
              Some(doc) => jsonGetString("uri", doc),
              None => None,
            }
            let versionOpt = match (textDocOpt) {
              Some(doc) => jsonGetNumber("version", doc),
              None => None,
            }
            let changesOpt = jsonGetArray("contentChanges", params)
            match (uriOpt) {
              Some(uri) => match (changesOpt) {
                Some(changes) => {
                  match (changes) {
                    [Json.JsonObject(first), ..._] => {
                      match (jsonGetString("text", Json.JsonObject(first))) {
                        Some(text) => {
                          Map.set(uri, text, docs)
                          let nextVersion = match (versionOpt) {
                            Some(v) => v,
                            None => match (Map.get(uri, docVersions)) {
                              Some(prev) => prev + 1,
                              None => 1,
                            },
                          }
                          Map.set(uri, nextVersion, docVersions)
                          let starts = buildLineStarts(text)
                          Map.set(uri, starts, lineStartsCache)
                          Map.set(uri, nextVersion, lineStartsCacheVersion)
                          invalidateInferenceCache()
                          if (isInlayWorker) {
                            invalidateInlayCache(uri)
                          } else {
                            void
                          }
                          if (workspaceRootPath == None) {
                            workspaceRootPath = Some(dirname(uriToPath(uri)))
                          } else {
                            void
                          }
                          if (!isInlayWorker) {
                            publishGraphDiagnostics(uri, docs, publishedUris)
                          } else {
                            publishedUris
                          }
                        },
                        None => publishedUris,
                      }
                    },
                    _ => publishedUris,
                  }
                },
                None => publishedUris,
              },
              None => publishedUris,
            }
          },
          None => publishedUris,
        }
      } else if (method == "textDocument/didClose") {
        debug("[LSP msg] handling didClose")
        match (jsonGetObject("params", msgJson)) {
          Some(params) => {
            match (jsonGetObject("textDocument", params)) {
              Some(doc) => {
                match (jsonGetString("uri", doc)) {
                  Some(uri) => {
                    Map.remove(uri, docs)
                    Map.remove(uri, docVersions)
                    Map.remove(uri, lineStartsCache)
                    Map.remove(uri, lineStartsCacheVersion)
                    invalidateInferenceCache()
                    if (isInlayWorker) {
                      invalidateInlayCache(uri)
                    } else {
                      void
                    }
                    let _published = publishDiagnostics(uri, [])
                    void
                    Map.remove(uri, publishedDiagnosticsFingerprint)
                    let next = Map.make()
                    List.forEach(((u, _)) => {
                      if (u == uri) {
                        void
                      } else {
                        Map.set(u, true, next)
                      }
                    }, Map.toList(publishedUris))
                    next
                  },
                  None => publishedUris,
                }
              },
              None => publishedUris,
            }
          },
          None => publishedUris,
        }
      } else if (method == "textDocument/inlayHint") {
        logErr(
          "[LSP] inlayHint request isInlayWorker="
            ++ (if (isInlayWorker) {
              "true"
            } else {
              "false"
            })
        )
        match (idOpt) {
          Some(idJson) => match (jsonGetObject("params", msgJson)) {
            Some(params) =>
              handleInlayHint(jsonToIdText(idJson), params, docs),
            None => void,
          },
          None => void,
        }
        publishedUris
      } else if (method == "textDocument/formatting") {
        debug("[LSP msg] handling formatting")
        match (idOpt) {
          Some(idJson) => match (jsonGetObject("params", msgJson)) {
            Some(params) =>
              handleFormatting(jsonToIdText(idJson), params, docs),
            None => void,
          },
          None => void,
        }
        publishedUris
      } else if (method == "textDocument/hover") {
        debug("[LSP msg] handling hover")
        if (!isInlayWorker) {
          match (idOpt) {
            Some(idJson) => match (jsonGetObject("params", msgJson)) {
              Some(params) => handleHover(jsonToIdText(idJson), params, docs),
              None => sendResponse(jsonToIdText(idJson), "null"),
            },
            None => void,
          }
        } else {
          match (idOpt) {
            Some(idJson) => sendResponse(jsonToIdText(idJson), "null"),
            None => void,
          }
        }
        publishedUris
      } else if (method == "textDocument/definition") {
        debug("[LSP msg] handling definition")
        if (!isInlayWorker) {
          match (idOpt) {
            Some(idJson) => match (jsonGetObject("params", msgJson)) {
              Some(params) => handleDefinition(jsonToIdText(idJson), params, docs),
              None => sendResponse(jsonToIdText(idJson), "[]"),
            },
            None => void,
          }
        } else {
          match (idOpt) {
            Some(idJson) => sendResponse(jsonToIdText(idJson), "[]"),
            None => void,
          }
        }
        publishedUris
      } else if (method == "shutdown") {
        debug("[LSP msg] handling shutdown")
        match (idOpt) {
          Some(idJson) => sendResponse(jsonToIdText(idJson), "null"),
          None => void,
        }
        publishedUris
      } else if (method == "exit") {
        debug("[LSP msg] handling exit")
        shouldExit = true
        publishedUris
      } else {
        publishedUris
      }
    },
  }
}

let parseContentLength = (header: String) => {
  let lines = String.split("\r\n", header)
  let rec find = (idx: Number) => {
    if (idx >= Array.length(lines)) {
      None
    } else {
      let line = Array.get(idx, lines)
      if (String.startsWith("Content-Length:", line)) {
        let raw = String.slice(String.length("Content-Length:"), line)
        match (Number.parseInt(String.trim(raw), radix=10)) {
          Ok(n) => Some(n),
          Err(_) => None,
        }
      } else {
        find(idx + 1)
      }
    }
  }
  find(0)
}

let findHeaderEnd = (buffer: Bytes) => {
  let len = Bytes.length(buffer)
  let mut i = 0
  let mut found: Option<Number> = None
  while (i + 3 < len && found == None) {
    let b0 = Uint8.toNumber(Bytes.getUint8(i, buffer))
    let b1 = Uint8.toNumber(Bytes.getUint8(i + 1, buffer))
    let b2 = Uint8.toNumber(Bytes.getUint8(i + 2, buffer))
    let b3 = Uint8.toNumber(Bytes.getUint8(i + 3, buffer))
    if (b0 == 13 && b1 == 10 && b2 == 13 && b3 == 10) {
      found = Some(i)
    }
    i += 1
  }
  found
}

let tryExtractMessage = (buffer: Bytes) => {
  match (findHeaderEnd(buffer)) {
    None => (None, buffer),
    Some(headerEnd) => {
      let headerBytes = Bytes.slice(0, headerEnd, buffer)
      let header = Bytes.toString(headerBytes)
      let bodyStart = headerEnd + 4
      match (parseContentLength(header)) {
        None => (None, buffer),
        Some(len) => {
          let bufLen = Bytes.length(buffer)
          let totalNeeded = bodyStart + len
          if (bufLen < totalNeeded) {
            (None, buffer)
          } else {
            let bodyBytes = Bytes.slice(bodyStart, len, buffer)
            let restLen = bufLen - totalNeeded
            let rest = Bytes.slice(totalNeeded, restLen, buffer)
            (Some(Bytes.toString(bodyBytes)), rest)
          }
        },
      }
    },
  }
}

let readChunk = () => {
  match (File.fdRead(File.stdin, 4096)) {
    Ok((bytes, count)) => if (count <= 0) {
      None
    } else {
      let slice = Bytes.slice(0, count, bytes)
      Some(slice)
    },
    Err(_) => None,
  }
}

let rec loop = (
  buffer: Bytes,
  docs: Map.Map<String, String>,
  publishedUris: Map.Map<String, Bool>,
) => {
  if (shouldExit) {
    void
  } else {
    let (msgOpt, rest) = tryExtractMessage(buffer)
    match (msgOpt) {
      Some(msgText) => {
        match (Json.parse(msgText)) {
          Ok(msgJson) => {
            let nextPublished = handleMessage(msgJson, docs, publishedUris)
            loop(rest, docs, nextPublished)
          },
          Err(err) => {
            logErr("Failed to parse JSON: " ++ toString(err))
            loop(rest, docs, publishedUris)
          },
        }
      },
      None => {
        match (readChunk()) {
          None => void,
          Some(chunk) => loop(Bytes.concat(buffer, chunk), docs, publishedUris),
        }
      },
    }
  }
}

let main = () => {
  let docs = Map.make()
  let publishedUris = Map.make()
  loop(Bytes.empty, docs, publishedUris)
}

main()
