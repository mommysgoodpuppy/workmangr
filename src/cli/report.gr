module Report

from "array" include Array
from "list" include List
from "map" include Map
from "string" include String

from "../core/core_ast.gr" include CoreAst
from "../core/analysis.gr" include Analysis
from "../core/infer.gr" include Infer
from "../core/source.gr" include Source
from "../core/types.gr" include Types

record NodeSummary {
  id: Number,
  span: Source.Span,
  line: Number,
  col: Number,
  excerpt: String,
  typeStr: String,
}

let getLineText = (source: String, line: Number) => {
  let lines = String.split("\n", source)
  let index = line - 1
  if (index < 0 || index >= Array.length(lines)) {
    ""
  } else {
    Array.get(index, lines)
  }
}

let summarizeNode = (source: String, node: CoreAst.Expr, analysis: Analysis.Analysis) => {
  match (Map.get(node.node.id, analysis.infer.nodeTypes)) {
    None => None,
    Some(nodeType) => {
      let pos = Source.offsetToLineCol(source, node.node.span.start)
      let excerpt = Source.slice(source, node.node.span)
      let appliedType = Types.applySubstType(analysis.infer.subst, nodeType)
      let typeStr = Types.typeToString(appliedType)
      Some({
        id: node.node.id,
        span: node.node.span,
        line: pos.line,
        col: pos.col,
        excerpt,
        typeStr,
      })
    },
  }
}

let rec collectExprs = (expr: CoreAst.Expr) =>
  match (expr.kind) {
    CoreAst.Mark(_, inner) => [expr, ...collectExprs(inner)],
    CoreAst.Lit(_) => [expr],
    CoreAst.Ident(_) => [expr],
    CoreAst.Hole(_) => [expr],
    CoreAst.Fn(fnExpr) => {
      let bodyExprs = List.filterMap(
        (item: CoreAst.FnItem) =>
          match (item.kind) {
            CoreAst.Clause(clause) => Some(clause.body),
            _ => None,
          },
        fnExpr.items
      )
      let rec collectBodies = (items: List<CoreAst.Expr>) => {
        match (items) {
          [] => [],
          [h, ...t] => List.append(collectExprs(h), collectBodies(t)),
        }
      }
      [expr, ...collectBodies(bodyExprs)]
    },
    CoreAst.Apply(callee, arg) => [expr, ...List.append(collectExprs(callee), collectExprs(arg))],
    CoreAst.Let(binding, body) => {
      let head = collectExprs(binding.value)
      let tail = collectExprs(body)
      [expr, ...List.append(head, tail)]
    },
    CoreAst.If(cond, thenExpr, elseOpt) => {
      let base = List.append(collectExprs(cond), collectExprs(thenExpr))
      let withElse = match (elseOpt) {
        None => base,
        Some(e) => List.append(base, collectExprs(e)),
      }
      [expr, ...withElse]
    },
    _ => [expr]
  }

let rec collectAllExprs = (items: List<CoreAst.TopItem>) => {
  match (items) {
    [] => [],
    [item, ...rest] => {
      let itemExprs = match (item) {
        CoreAst.DeclGroup(dg) => {
          let rec collectFromDecls = (decls: List<CoreAst.Decl>) => {
            match (decls) {
              [] => [],
              [decl, ...restDecls] => {
                let declExprs = match (decl) {
                  CoreAst.LetDecl(ld) => {
                    let rec collectFromBindings = (bindings: List<CoreAst.LetBinding>) => {
                      match (bindings) {
                        [] => [],
                        [b, ...restBindings] => 
                          List.append(collectExprs(b.value), collectFromBindings(restBindings))
                      }
                    }
                    collectFromBindings(ld.bindings)
                  },
                  _ => []
                }
                List.append(declExprs, collectFromDecls(restDecls))
              }
            }
          }
          collectFromDecls(dg.decls)
        },
        _ => []
      }
      List.append(itemExprs, collectAllExprs(rest))
    }
  }
}

let groupByLine = (summaries: List<NodeSummary>) => {
  let groups: Map.Map<Number, List<NodeSummary>> = Map.make()
  List.forEach(
    (summary) => {
      let existing =
        match (Map.get(summary.line, groups)) {
          Some(list) => list,
          None => [],
        }
      Map.set(summary.line, [summary, ...existing], groups)
    },
    summaries,
  )
  groups
}

let sortBySpan = (items: List<NodeSummary>) =>
  List.sort(
    compare=((a, b) =>
      if (a.span.start == b.span.start) { a.span.end - b.span.end } else { a.span.start - b.span.start }
    ),
    items,
  )

let sortByCol = (items: List<NodeSummary>) =>
  List.sort(compare=((a, b) => a.col - b.col), items)

let printLineSummaries = (
  source: String,
  groups: Map.Map<Number, List<NodeSummary>>,
) => {
  let lineKeys = Map.keys(groups)
  let lines = List.sort(compare=((a, b) => a - b), lineKeys)

  List.forEach(
    (lineNum) => {
      let lineText = getLineText(source, lineNum)
      print("Line " ++ toString(lineNum) ++ ": " ++ lineText)

      let lineItems =
        match (Map.get(lineNum, groups)) {
          Some(items) => sortByCol(sortBySpan(items)),
          None => [],
        }

      List.forEach(
        (item) => {
          print(
            " Col " ++ toString(item.col) ++ ": " ++ item.excerpt ++
            "    //(nodeId:" ++ toString(item.id) ++ ")",
          )
          print("  type: " ++ item.typeStr)
        },
        lineItems,
      )
      print("")
    },
    lines,
  )
}

let printTopBindings = (analysis: Analysis.Analysis) => {
  print("=== Top-Level Bindings ===")
  print("")

  let bindings = Map.toList(analysis.infer.topBindings)

  List.forEach(
    (pair) => {
      let (name, scheme): (String, Types.Scheme) = pair
      let applied = Types.applySubstType(analysis.infer.subst, scheme.ty)
      print(name ++ " : " ++ Types.typeToString(applied))
    },
    bindings,
  )
}

provide let report = (source: String, analysis: Analysis.Analysis) => {
  let exprs = collectAllExprs(analysis.program.items)
  let maybeSummaries = List.map((expr) => summarizeNode(source, expr, analysis), exprs)
  let summaries = List.filterMap((x) => x, maybeSummaries)

  let groups = groupByLine(summaries)
  printLineSummaries(source, groups)
  printTopBindings(analysis)
}
