module Ast

from "./source.gr" include Source

provide record rec Node {
  id: Number,
  span: Source.Span,
}
and provide enum HoleOrigin {
  UserTyped, // user wrote `?`
  Inferred, // lsp inserted `?`
}
and provide record Hole {
  node: Node,
  kind: HoleKind,
  origin: HoleOrigin,
}
and provide enum HoleKind {
  ExprHole,
  TypeHole,
  PatternHole,
  NameHole,
}
and provide record Name {
  node: Node,
  text: String,
  // maybe also: kind: NameKind (ValueName | TypeName | OpName)
}
and provide enum AtomLiteral {
  Int(Number),
  Bool(Bool),
  Char(Char),
  Str(String),
  Byte(Number),
  Unit,
}
//#region trivia
and provide enum TriviaPlacement {
  // Anchored between printed tokens mechanically:
  Gap, // between token A and token B (exact boundary)

  // A structural island (block-scale):
  Island, // prints as a block; can contain newlines freely
}
and provide record Trivia {
  node: Node,
  kind: TriviaKind,
  placement: TriviaPlacement,
}
and provide enum TriviaKind {
  LineComment(String), // -- or //
  BlockComment(String), // optional future
  Opaque(String), // unsafe fragment
}
and provide record Attachments {
  leading: List<Trivia>,
  trailing: List<Trivia>,
  dangling: List<Trivia>,
}
//#endregion

provide enum rec ExprKind {
  Lit(AtomLiteral),
  Ident(Name),
  Lambda(Option<Pattern>, Expr),
  InfixChain(InfixChain),
  Postfix(Postfix),
  Block(Block),
  Paren(Expr),
  Tuple(List<Expr>),
  RecordLit(List<RecordItem>),
  MatchApply(MatchApply),
  Bundle(BundleExpr),
  Hole(Hole),
  If(Expr, Expr, Option<Expr>),
}
and provide enum RecordItem {
  Field(Name, Expr),
  Spread(Expr),
}
and provide enum ListItem {
  Elem(Expr),
  Spread(Expr),
}
and provide record Expr {
  node: Node,
  kind: ExprKind,
  attach: Attachments,
}
and provide record AssignStmt {
  target: Expr,
  value: Expr,
}
and provide enum StmtKind {
  Let(LetBinding),
  Assign(AssignStmt),
  Expr(Expr), // expression statement (void)
}
and provide record Stmt {
  node: Node,
  kind: StmtKind,
  attach: Attachments,
}
and provide enum PostfixSegment {
  Call(List<Expr>),
  Project(Name), // .field
  Index(Expr), // [expr]
}
and provide record Postfix {
  target: Expr,
  segments: List<PostfixSegment>,
}
and provide record InfixChain {
  first: Expr,
  rest: List<(Name, /*op*/ Expr)>,
}
and provide record Block {
  node: Node,
  items: List<BlockItem>,
  result: List<Expr>,
}
and provide enum BlockItem {
  Stmt(Stmt),
  TriviaItem(Trivia), // includes comments AND islands
  Directive(Directive),
}
and provide record Directive {
  name: Name,
  args: List<Expr>,
}
and provide enum PatternKind {
  Hole(Hole),
  Wildcard,
  Var(Name), // introduces binding (in match)
  Pin(Name), // refers to existing binding (in match)
  Lit(AtomLiteral),
  Constructor(Name, List<Pattern>),
  Tuple(List<Pattern>),
  List(List<Pattern>, Option<Pattern>), // rest pattern for `.. pat`
  AllErrors,
}
and provide record Pattern {
  node: Node,
  kind: PatternKind,
  attach: Attachments,
}
and provide enum BundleItemKind {
  Case(Pattern, Option<Expr>, Block),
  Trivia(Trivia),
}
and provide record BundleItem {
  node: Node,
  kind: BundleItemKind,
  attach: Attachments,
}
and provide record BundleLiteral {
  node: Node,
  items: List<BundleItem>,
}
and provide enum BundleExprKind {
  Literal(BundleLiteral),
  Ref(Name),
  Compose(List<BundleExpr>),
  Hole(Hole),
  Paren(BundleExpr),
}
and provide record BundleExpr {
  node: Node,
  kind: BundleExprKind,
  attach: Attachments,
}
and provide record MatchApply {
  node: Node,
  scrutinees: List<Expr>,
  bundle: BundleExpr,
}
and provide enum TypeExprKind {
  Hole(Hole),
  Var(Name),
  Ref(Name, List<TypeExpr>), // Foo<T,U>
  Tuple(List<TypeExpr>),
  Record(List<(Name, TypeExpr)>),
  Arrow(List<TypeExpr>, TypeExpr), // params => result
  Ptr(TypeExpr, Option<Name>), // Ptr<T, state?>
  EffectRow(List<EffectCase>, Bool /*has_tail_wildcard*/),
  UnitType, // Void
}
and provide record TypeExpr {
  node: Node,
  kind: TypeExprKind,
  attach: Attachments,
}
and provide record EffectCase {
  node: Node,
  name: Name,
  payload: Option<TypeExpr>,
}
// top level

and provide enum Decl {
  LetDecl(LetDecl),
  TypeDecl(TypeDecl),
  RecordDecl(RecordDecl),
  InfixDecl(InfixDecl),
  PrefixDecl(PrefixDecl),
  // Rule decls later
}
and provide record LetDecl {
  node: Node,
  bindings: List<LetBinding>, // if you want to keep `and` inside; else group holds list
}
and provide record LetBinding {
  node: Node,
  name: Pattern, // allow pattern binding (per manual)
  annotation: Option<TypeExpr>, // `: Type`
  value: Expr,
}
// export type rec infectious domain x =
and provide record TypeDecl {
  node: Node,
  name: Name,
  infection: Option<Name>,
  typeParams: List<Name>,
  body: TypeDeclBody,
}
and provide type Annotation = String
and provide enum TypeDeclBody {
  Alias(TypeExpr),
  Variant(List<(Name, Option<TypeExpr>, Option<Annotation>)>), // enum-like
}
and provide record RecordDecl {
  node: Node,
  name: Name,
  typeParams: List<Name>,
  fields: List<(Name, TypeExpr)>,
}
and provide record InfixDecl {
  node: Node,
  name: Name,
  precedence: Number,
  associativity: InfixAssociativity,
}
and provide enum InfixAssociativity {
  Left,
  Right,
  NonAssoc,
}
and provide record PrefixDecl {
  node: Node,
  name: Name,
}

provide record rec ImportDecl {
  node: Node,
  modulePath: String,
  alias: Option<Name>,
}
and provide record ReexportDecl {
  node: Node,
  modulePath: String,
}
and provide record DeclGroup {
  node: Node,
  exported: Bool,
  kind: DeclGroupKind,
  decls: List<Decl>, // all share the group header modifiers
}
and provide enum DeclGroupKind {
  LetGroup(LetGroupMods),
  TypeGroup(TypeGroupMods),
  RecordGroup(RecordGroupMods),
  OpGroup, // infix/prefix declarations
  RuleGroup(RuleKind), // infectious/domain/policy/op/annotate if you want
}
and provide type Rec = Bool
and provide enum LetGroupMods {
  Rec,
  Mut,
}
and provide enum TypeGroupMods {
  Rec,
}
and provide enum RecordGroupMods {
  Rec,
}
and provide enum RuleKind {
  Domain,
  Policy,
  Op,
  Annotate,
}
and provide enum TopItem {
  Directive(Directive),
  Import(ImportDecl),
  Reexport(ReexportDecl),
  DeclGroup(DeclGroup),
  //can be raw region
  Trivia(Trivia),
}
and provide record Program {
  items: List<TopItem>,
  core: Bool,
}
