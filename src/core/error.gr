module Error

from "list" include List
from "string" include String
from "runtime/unsafe/panic" include Panic
from "../core/source.gr" include Source
from "../core/surface_ast.gr" include SurfaceAst

use Panic.{ panic }

// Compilation stage where error occurred
provide enum Stage {
  Lexing,
  Parsing,
  Lowering,
  TypeInference,
}

// Error clues provide context about what went wrong
provide enum ErrorClue {
  Expected(String),
  Received(String),
  Incomplete(String),
  Note(String),
  Hint(String),
}

// Compiler error with location and context
provide record CompilerError {
  stage: Stage,
  message: String,
  span: Source.Span,
  clues: List<ErrorClue>,
}

provide record MarkedError {
  mark: SurfaceAst.Mark,
  error: CompilerError,
}

let mut diagnostics: List<CompilerError> = []
let mut markedDiagnostics: List<MarkedError> = []
let mut panicMode: Bool = false

let clueToString = (clue: ErrorClue) => {
  match (clue) {
    Expected(s) => "  expected: " ++ s,
    Received(s) => "  received: " ++ s,
    Incomplete(s) => "  incomplete: " ++ s,
    Note(s) => "  note: " ++ s,
    Hint(s) => "  hint: " ++ s,
  }
}

let joinStrings = (sep: String, strings: List<String>) => {
  let rec loop = (acc: String, remaining: List<String>) => {
    match (remaining) {
      [] => acc,
      [h] => acc ++ h,
      [h, ...t] => loop(acc ++ h ++ sep, t),
    }
  }
  match (strings) {
    [] => "",
    [h, ...t] => loop(h, t),
  }
}

let stageToString = (stage: Stage) => {
  match (stage) {
    Lexing => "Lexing",
    Parsing => "Parsing",
    Lowering => "Lowering",
    TypeInference => "Type Inference",
  }
}

provide let stageName = (stage: Stage) => stageToString(stage)

provide let compilerErrorFromMark = (
  stage: Stage,
  mark: SurfaceAst.Mark,
  message: String,
  clues: List<ErrorClue> = [],
) => {
  { stage, message, span: mark.node.span, clues }: CompilerError
}

provide let errorToString = (error: CompilerError) => {
  let cluesStr = match (error.clues) {
    [] => "",
    clues => {
      "\n" ++ joinStrings("\n", List.map(clueToString, clues))
    },
  }
  
  let location = "at line " ++ toString(error.span.line) ++ 
                 ", col " ++ toString(error.span.col)
  
  let stageInfo = "[" ++ stageToString(error.stage) ++ "] "
  
  stageInfo ++ error.message ++ " " ++ location ++ cluesStr
}

provide let clearErrors = () => {
  diagnostics = []
  markedDiagnostics = []
}

provide let getErrors = () => List.reverse(diagnostics)
provide let getMarkedErrors = () => List.reverse(markedDiagnostics)

provide let setPanicMode = (enabled: Bool) => {
  panicMode = enabled
}

provide let createError = (
  stage: Stage,
  span: Source.Span,
  message: String,
  recovery,
  clues: List<ErrorClue> = [],
  shouldPanic: Bool = false,
) => {
  let error: CompilerError = { stage, message, span, clues }
  diagnostics = [error, ...diagnostics]
  if (shouldPanic || panicMode) {
    panic(errorToString(error))
  } else {
    recovery
  }
}

provide let createMarkedError = (
  stage: Stage,
  mark: SurfaceAst.Mark,
  message: String,
  recovery,
  clues: List<ErrorClue> = [],
  shouldPanic: Bool = false,
) => {
  let error = compilerErrorFromMark(stage, mark, message, clues=clues)
  let marked: MarkedError = { mark, error }
  diagnostics = [error, ...diagnostics]
  markedDiagnostics = [marked, ...markedDiagnostics]
  if (shouldPanic || panicMode) {
    panic(errorToString(error))
  } else {
    recovery
  }
}

provide let createPanicError = (
  stage: Stage,
  span: Source.Span,
  message: String,
  clues: List<ErrorClue>,
) => {
  let error: CompilerError = { stage, message, span, clues }
  diagnostics = [error, ...diagnostics]
  panic(errorToString(error))
}
