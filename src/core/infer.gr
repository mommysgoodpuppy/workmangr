module Infer

from "list" include List
from "map" include Map
from "array" include Array
from "runtime/unsafe/panic" include Panic
from "bytes" include Bytes
from "wasi/file" include File
from "wasi/process" include Process

from "./core_ast.gr" include CoreAst
from "./types.gr" include Types
from "./env.gr" include Env
from "./constraints.gr" include Constraints
from "./solver.gr" include Solver
from "./layer1/expr.gr" include Layer1Expr
from "./layer1/patterns.gr" include Layer1Patterns
from "./layer1/declarations.gr" include Layer1Decl
from "./layer1/bindings.gr" include Layer1Bindings
from "./layer1/top.gr" include Layer1Top

provide enum TypeMarkReason {
  TypeMismatch,
  OccursCycle,
  UnknownIdentifier,
  UnfillableHole,
  Internal,
}

provide record TypeMark {
  reason: TypeMarkReason,
  origin: Constraints.Origin,
  related: List<Constraints.Origin>,
  mark: CoreAst.Mark,
  message: String,
}

provide record HoleObservation {
  observed: Types.Type,
  origin: Constraints.Origin,
}

provide record InferState {
  nextVar: Number,
  subst: Types.Subst,
  env: Env.TypingEnv,
  nodeTypes: Map.Map<Number, Types.Type>,
  topBindings: Map.Map<String, Types.Scheme>,
  constraints: List<Constraints.Constraint>,
  matchArms: Map.Map<Number, List<Layer1Patterns.MatchArmInfo>>,
  marks: List<TypeMark>,
  marksByNode: Map.Map<Number, List<TypeMark>>,
  holeObservations: Map.Map<Number, List<HoleObservation>>,
}

let inferDebugEnabled = match (Process.env()) {
  Ok(vars) => List.some((entry: String) => {
    entry == "WORKMAN_INFER_DEBUG=1" || entry == "WORKMAN_INFER_DEBUG=true"
  }, Array.toList(vars)),
  Err(_) => false,
}

let inferDebug = (message: String) => {
  if (inferDebugEnabled) {
    let _ = File.fdWrite(File.stderr, Bytes.fromString("[Infer] " ++ message ++ "\n"))
    void
  } else {
    void
  }
}

let mapSize = (m) => List.length(Map.toList(m))

let renderType = (t: Types.Type, state: InferState) =>
  Types.typeToReadableString(Types.applySubstType(state.subst, t))

let seedBuiltinValues = (env: Env.TypingEnv) => {
  let intType = Types.TNominal("Int", [])
  let numberType = Types.TNumber
  let boolType = Types.TBool
  let orderingType = Types.TNominal("Ordering", [])
  let binaryInt: Types.Scheme = {
    quantifiers: [],
    ty: Types.TFun(Types.TTuple([intType, intType]), intType),
  }
  let binaryNumber: Types.Scheme = {
    quantifiers: [],
    ty: Types.TFun(Types.TTuple([numberType, numberType]), numberType),
  }
  let cmpNumber: Types.Scheme = {
    quantifiers: [],
    ty: Types.TFun(Types.TTuple([numberType, numberType]), boolType),
  }
  let unaryBool: Types.Scheme = {
    quantifiers: [],
    ty: Types.TFun(boolType, boolType),
  }
  let cmpInt: Types.Scheme = {
    quantifiers: [],
    ty: Types.TFun(Types.TTuple([intType, intType]), orderingType),
  }
  let define = (name: String, scheme: Types.Scheme) => {
    Env.defineValue(env, name, scheme)
    void
  }
  Env.defineValue(env, "nativeAdd", binaryInt)
  Env.defineValue(env, "nativeSub", binaryInt)
  Env.defineValue(env, "nativeMul", binaryInt)
  Env.defineValue(env, "nativeDiv", binaryInt)
  Env.defineValue(env, "nativeCmpInt", cmpInt)
  // Temporary builtin operator support until std-based operator resolution lands.
  define("+", binaryNumber)
  define("-", binaryNumber)
  define("*", binaryNumber)
  define("/", binaryNumber)
  define("%", binaryNumber)
  define("==", cmpNumber)
  define("!=", cmpNumber)
  define(">", cmpNumber)
  define("<", cmpNumber)
  define(">=", cmpNumber)
  define("<=", cmpNumber)
  define("!", unaryBool)
  define("not", unaryBool)
  define("&&", {
    quantifiers: [],
    ty: Types.TFun(Types.TTuple([boolType, boolType]), boolType),
  })
  define("||", {
    quantifiers: [],
    ty: Types.TFun(Types.TTuple([boolType, boolType]), boolType),
  })
  env
}

let logState = (label: String, state: InferState, nodeId: Number=-1) => {
  inferDebug(
    label
      ++ " node="
      ++ toString(nodeId)
      ++ " env="
      ++ toString(mapSize(Env.snapshotValues(state.env)))
      ++ " subst="
      ++ toString(mapSize(state.subst))
      ++ " constraints="
      ++ toString(List.length(state.constraints))
      ++ " marks="
      ++ toString(List.length(state.marks))
      ++ " nextVar="
      ++ toString(state.nextVar)
  )
}

let makeInitialState = () => {
  let subst = Types.emptySubst()
  let env = seedBuiltinValues(Env.empty())
  let nodeTypes = Map.make()
  let topBindings = Map.make()
  {
    nextVar: 0,
    subst,
    env,
    nodeTypes,
    topBindings,
    constraints: [],
    matchArms: Map.make(),
    marks: [],
    marksByNode: Map.make(),
    holeObservations: Map.make(),
  }
}

let recordConstraint = (state: InferState, constraint: Constraints.Constraint) =>
  { ...state, constraints: [constraint, ...state.constraints] }

let originForNode = (nodeId: Number, description: String) =>
  Constraints.makeOrigin(nodeId, description)

let addTypeMark = (
  state: InferState,
  reason: TypeMarkReason,
  origin: Constraints.Origin,
  mark: CoreAst.Mark,
  message: String,
) => {
  let recent = List.filterMap((constraint: Constraints.Constraint) =>
    match (constraint) {
      Constraints.Equality(_, _, o) => Some(o),
      Constraints.Domain(_, o) => Some(o),
    }, state.constraints)
  let rec take = (items: List<Constraints.Origin>, n: Number, acc: List<Constraints.Origin>) =>
    if (n <= 0) {
      List.reverse(acc)
    } else {
      match (items) {
        [] => List.reverse(acc),
        [head, ...tail] => take(tail, n - 1, [head, ...acc]),
      }
    }
  let related = take(recent, 3, [])
  let entry: TypeMark = { reason, origin, related, mark, message }
  let updatedMarks = [entry, ...state.marks]
  let updatedByNode = if (origin.nodeId >= 0) {
    let existing = match (Map.get(origin.nodeId, state.marksByNode)) {
      Some(items) => items,
      None => [],
    }
    Map.set(origin.nodeId, [entry, ...existing], state.marksByNode)
    state.marksByNode
  } else {
    state.marksByNode
  }
  { ...state, marks: updatedMarks, marksByNode: updatedByNode }
}

let noteHoleObservation = (
  state: InferState,
  holeId: Number,
  observed: Types.Type,
  origin: Constraints.Origin,
) => {
  let obs: HoleObservation = {
    observed: Types.applySubstType(state.subst, observed),
    origin,
  }
  let existing = match (Map.get(holeId, state.holeObservations)) {
    Some(items) => items,
    None => [],
  }
  Map.set(holeId, [obs, ...existing], state.holeObservations)
  { ...state, holeObservations: state.holeObservations }
}

let recordMatchArms = (fnExpr: CoreAst.FnExpr, state: InferState) => {
  match (Layer1Patterns.analyzeMatchArms(fnExpr, state.env)) {
    None => state,
    Some(armInfos) => {
      Map.set(fnExpr.node.id, armInfos, state.matchArms)
      { ...state, matchArms: state.matchArms }
    },
  }
}

let freshVar = (state: InferState) => {
  let id = state.nextVar
  (Types.TVar(id), { ...state, nextVar: id + 1 })
}

let apply = (state: InferState, t: Types.Type) =>
  Types.applySubstType(state.subst, t)

let occurs = (varId: Number, t: Types.Type, state: InferState) => {
  let fv = Types.freeVars(apply(state, t))
  Types.containsVar(fv, varId)
}

let bindVar = (
  varId: Number,
  t: Types.Type,
  state: InferState,
  origin: Constraints.Origin,
) => {
  let tApplied = apply(state, t)
  if (tApplied == Types.TVar(varId)) {
    state
  } else if (occurs(varId, tApplied, state)) {
    addTypeMark(
      state,
      OccursCycle,
      origin,
      CoreAst.OccursCheck,
      "Type error: occurs check failed"
    )
  } else {
    Types.extendSubst(state.subst, varId, tApplied)
    state
  }
}

let findRecordFieldType = (
  fields: List<(String, Types.Type)>,
  fieldName: String,
) => {
  let rec loop = (remaining: List<(String, Types.Type)>) =>
    match (remaining) {
      [] => None,
      [(name, fieldTy), ...rest] =>
        if (name == fieldName) {
          Some(fieldTy)
        } else {
          loop(rest)
        },
    }
  loop(fields)
}

let resolveNominalRecordFields = (
  typeName: String,
  args: List<Types.Type>,
  state: InferState,
) => {
  match (Env.lookupType(state.env, typeName)) {
    Some(typeInfo) =>
      match (typeInfo.recordFields) {
        None => None,
        Some(recordFields) => {
          let paramMap = Map.make()
          let rec bindParams = (
            params: List<String>,
            values: List<Types.Type>,
          ) => match ((params, values)) {
            ([paramName, ...paramRest], [argType, ...argRest]) => {
              Map.set(paramName, argType, paramMap)
              bindParams(paramRest, argRest)
            },
            _ => void,
          }
          bindParams(typeInfo.typeParams, args)
          Some(
            List.map(
              ((fieldName, fieldTypeExpr): (CoreAst.Name, CoreAst.TypeExpr)) =>
                (fieldName.text, Layer1Expr.typeExprToType(fieldTypeExpr, paramMap)),
              recordFields
            )
          )
        },
      },
    None => None,
  }
}

record NominalRecordCandidate {
  typeName: String,
  nominalType: Types.Type,
  fields: List<(String, Types.Type)>,
}

let hasRecordField = (fields: List<(String, Types.Type)>, fieldName: String) =>
  match (findRecordFieldType(fields, fieldName)) {
    Some(_) => true,
    None => false,
  }

let inferNominalRecordContext = (
  literalNodeId: Number,
  providedFields: List<(String, Types.Type)>,
  state: InferState,
  unifyFn: (Types.Type, Types.Type, Constraints.Origin, InferState) => InferState,
) => {
  let rec buildCandidates = (
    remaining: List<(String, Env.TypeInfo)>,
    nextVar: Number,
    acc: List<NominalRecordCandidate>,
  ) =>
    match (remaining) {
      [] => (List.reverse(acc), nextVar),
      [(_name, info), ...rest] =>
        match (info.recordFields) {
          None => buildCandidates(rest, nextVar, acc),
          Some(_recordFields) => {
            let (paramTypes, _paramMap, nextVar1) = Layer1Expr.instantiateTypeParams(
              info.typeParams,
              nextVar
            )
            let nominalType = Types.TNominal(info.name, paramTypes)
            match (resolveNominalRecordFields(info.name, paramTypes, state)) {
              Some(fields) => {
                let candidate: NominalRecordCandidate = {
                  typeName: info.name,
                  nominalType,
                  fields,
                }
                buildCandidates(rest, nextVar1, [candidate, ...acc])
              },
              None => buildCandidates(rest, nextVar1, acc),
            }
          },
        },
    }
  let (allCandidates, nextVarAfterCandidates) = buildCandidates(
    Map.toList(state.env.types),
    state.nextVar,
    [],
  )
  let state1 = { ...state, nextVar: nextVarAfterCandidates }
  let rec filterByProvided = (
    candidates: List<NominalRecordCandidate>,
    acc: List<NominalRecordCandidate>,
  ) =>
    match (candidates) {
      [] => List.reverse(acc),
      [candidate, ...rest] => {
        let allKnown = List.every(
          ((fieldName, _fieldType)) => hasRecordField(candidate.fields, fieldName),
          providedFields
        )
        if (allKnown) {
          filterByProvided(rest, [candidate, ...acc])
        } else {
          filterByProvided(rest, acc)
        }
      },
    }
  let candidates = filterByProvided(allCandidates, [])
  match (candidates) {
    [] => {
      let holeTy = Types.THole(literalNodeId)
      let marked = addTypeMark(
        state1,
        TypeMismatch,
        originForNode(literalNodeId, "record literal context"),
        CoreAst.Inconsistent,
        "Type error: record literal requires nominal type context"
      )
      (holeTy, marked)
    },
    [candidate] => {
      let rec unifyProvided = (
        remaining: List<(String, Types.Type)>,
        st: InferState,
      ) =>
        match (remaining) {
          [] => st,
          [(fieldName, fieldType), ...rest] =>
            match (findRecordFieldType(candidate.fields, fieldName)) {
                  Some(expectedType) =>
                    unifyProvided(
                      rest,
                      unifyFn(
                        fieldType,
                        expectedType,
                        originForNode(literalNodeId, "record literal field"),
                        st
                  )
                ),
              None =>
                unifyProvided(
                  rest,
                  addTypeMark(
                    st,
                    TypeMismatch,
                    originForNode(literalNodeId, "record literal field"),
                    CoreAst.Inconsistent,
                    "Type error: unknown record field " ++ fieldName
                  )
                ),
            },
        }
      let st2 = unifyProvided(providedFields, state1)
      let rec markMissingFields = (
        remaining: List<(String, Types.Type)>,
        st: InferState,
      ) =>
        match (remaining) {
          [] => st,
          [(expectedName, _), ...rest] =>
            if (
              List.some(
                ((providedName, _)) => providedName == expectedName,
                providedFields
              )
            ) {
              markMissingFields(rest, st)
            } else {
              markMissingFields(
                rest,
                addTypeMark(
                  st,
                  TypeMismatch,
                  originForNode(literalNodeId, "record literal missing field"),
                  CoreAst.Inconsistent,
                  "Type error: missing record field " ++ expectedName
                )
              )
            },
        }
      let st3 = markMissingFields(candidate.fields, st2)
      (candidate.nominalType, st3)
    },
    _ => {
      let holeTy = Types.THole(literalNodeId)
      let marked = addTypeMark(
        state1,
        TypeMismatch,
        originForNode(literalNodeId, "record literal ambiguous context"),
        CoreAst.Inconsistent,
        "Type error: record literal has ambiguous nominal context"
      )
      (holeTy, marked)
    },
  }
}

let validateRecordLiteralAgainstNominal = (
  literalNodeId: Number,
  fields: List<(String, Types.Type)>,
  expectedType: Types.Type,
  state: InferState,
  unifyFn: (Types.Type, Types.Type, Constraints.Origin, InferState) => InferState,
) =>
  match (apply(state, expectedType)) {
    Types.TNominal(typeName, typeArgs) =>
      match (resolveNominalRecordFields(typeName, typeArgs, state)) {
        Some(nominalFields) => {
          let hasProvidedField = (fieldName: String) =>
            List.some(((name, _ty)) => name == fieldName, fields)
          let rec unifyFields = (
            remaining: List<(String, Types.Type)>,
            st: InferState,
          ) =>
            match (remaining) {
              [] => st,
              [(name, litTy), ...rest] =>
                match (findRecordFieldType(nominalFields, name)) {
                  Some(nominalTy) =>
                    unifyFields(
                      rest,
                      unifyFn(
                        litTy,
                        nominalTy,
                        originForNode(literalNodeId, "record field"),
                        st
                      )
                    ),
                  None =>
                    addTypeMark(
                      st,
                      TypeMismatch,
                      originForNode(literalNodeId, "record literal field"),
                      CoreAst.Inconsistent,
                      "Type error: unknown record field " ++ name
                    ),
                },
            }
          let state1 = unifyFields(fields, state)
          let rec markMissingFields = (
            remaining: List<(String, Types.Type)>,
            st: InferState,
          ) =>
            match (remaining) {
              [] => st,
              [(name, _ty), ...rest] =>
                if (hasProvidedField(name)) {
                  markMissingFields(rest, st)
                } else {
                  let st1 = addTypeMark(
                    st,
                    TypeMismatch,
                    originForNode(literalNodeId, "record literal field"),
                    CoreAst.Inconsistent,
                    "Type error: missing record field " ++ name
                  )
                  markMissingFields(rest, st1)
                },
            }
          markMissingFields(nominalFields, state1)
        },
        None =>
          addTypeMark(
            state,
            TypeMismatch,
            originForNode(literalNodeId, "record literal annotation"),
            CoreAst.Inconsistent,
            "Type error: record literal requires nominal type context"
          ),
      },
    _ =>
      addTypeMark(
        state,
        TypeMismatch,
        originForNode(literalNodeId, "record literal annotation"),
        CoreAst.Inconsistent,
        "Type error: record literal requires nominal type context"
      ),
  }

let rec unify = (
  left: Types.Type,
  right: Types.Type,
  origin: Constraints.Origin,
  state: InferState,
) => {
  let constraint = Constraints.Equality(left, right, origin)
  let state1 = recordConstraint(state, constraint)
  let l = apply(state1, left)
  let r = apply(state1, right)

  match ((l, r)) {
    (Types.TNumber, Types.TNumber) => state1,
    (Types.TNumber, Types.TNominal("Int", [])) => state1,
    (Types.TNominal("Int", []), Types.TNumber) => state1,
    (Types.TBool, Types.TBool) => state1,
    (Types.TString, Types.TString) => state1,
    (Types.TByte, Types.TByte) => state1,
    (Types.TChar, Types.TChar) => state1,
    (Types.TVoid, Types.TVoid) => state1,
    (Types.THole(holeId), observed) =>
      noteHoleObservation(state1, holeId, observed, origin),
    (observed, Types.THole(holeId)) =>
      noteHoleObservation(state1, holeId, observed, origin),
    (Types.TVar(id), t) => bindVar(id, t, state1, origin),
    (t, Types.TVar(id)) => bindVar(id, t, state1, origin),
    (Types.TFun(a1, b1), Types.TFun(a2, b2)) => {
      let state2 = unify(a1, a2, origin, state1)
      unify(b1, b2, origin, state2)
    },
    (Types.TTuple(leftItems), Types.TTuple(rightItems)) => {
      let rec unifyTuple = (
        xs: List<Types.Type>,
        ys: List<Types.Type>,
        st: InferState,
      ) => match ((xs, ys)) {
        ([], []) => st,
        ([x, ...xRest], [y, ...yRest]) =>
          unifyTuple(xRest, yRest, unify(x, y, origin, st)),
        _ =>
          addTypeMark(
            st,
            TypeMismatch,
            origin,
            CoreAst.Inconsistent,
            "Type error: cannot unify tuple/argument arity"
          ),
      }
      unifyTuple(leftItems, rightItems, state1)
    },
    (Types.TNominal(nameL, argsL), Types.TNominal(nameR, argsR)) =>
      if (nameL == nameR) {
        let rec unifyNominalArgs = (
          xs: List<Types.Type>,
          ys: List<Types.Type>,
          st: InferState,
        ) => match ((xs, ys)) {
        ([], []) => st,
        ([x, ...xRest], [y, ...yRest]) =>
          unifyNominalArgs(xRest, yRest, unify(x, y, origin, st)),
        _ =>
          addTypeMark(
            st,
            TypeMismatch,
            origin,
            CoreAst.Inconsistent,
            "Type error: nominal arity mismatch"
          ),
        }
        unifyNominalArgs(argsL, argsR, state1)
      } else {
        addTypeMark(
          state1,
          TypeMismatch,
          origin,
          CoreAst.Inconsistent,
          "Type error: cannot unify nominal types"
        )
      },
    _ =>
      addTypeMark(
        state1,
        TypeMismatch,
        origin,
        CoreAst.Inconsistent,
        "Type error (" ++ origin.description ++ "): cannot unify "
          ++ renderType(l, state1)
          ++ " with "
          ++ renderType(r, state1)
      ),
  }
}

let unifyForNode = (
  nodeId: Number,
  description: String,
  left: Types.Type,
  right: Types.Type,
  state: InferState,
) => unify(left, right, originForNode(nodeId, description), state)

let recordNodeType = (id: Number, t: Types.Type, state: InferState) => {
  let applied = apply(state, t)
  Map.set(id, applied, state.nodeTypes)
  applied
}

let handleMatchApplication = (
  fnExpr: CoreAst.FnExpr,
  argType: Types.Type,
  state: InferState,
) => {
  match (Map.get(fnExpr.node.id, state.matchArms)) {
    Some(armInfos) => match (armInfos) {
      [] => state,
      [first, ..._] => {
        match (Env.lookupType(state.env, first.typeName)) {
          None => Panic.panic("Unknown nominal type " ++ first.typeName),
          Some(typeInfo) => {
            let (paramTypes, _paramMap, nextVar) = Layer1Expr.instantiateTypeParams(
              typeInfo.typeParams,
              state.nextVar
            )
            let state1 = { ...state, nextVar }
            let scrutineeType = Types.TNominal(typeInfo.name, paramTypes)
            unifyForNode(
              fnExpr.node.id,
              "match scrutinee",
              argType,
              scrutineeType,
              state1
            )
          },
        }
      },
    },
    None => state,
  }
}

let lookupEnv = (name: CoreAst.Name, state: InferState) => {
  match (Env.lookupValue(state.env, name.text)) {
    Some(scheme) => {
      let (inst, nextVar) = Types.instantiate(scheme, state.nextVar)
      (Types.applySubstType(state.subst, inst), { ...state, nextVar })
    },
    None => {
      let (unknownType, state1) = freshVar(state)
      let marked = addTypeMark(
        state1,
        UnknownIdentifier,
        originForNode(name.node.id, "unknown identifier"),
        CoreAst.FreeVar(name),
        "Type error: unknown identifier " ++ name.text
      )
      (unknownType, marked)
    },
  }
}

let cloneEnvValues = (values: Types.Env) => {
  let cloned = Types.emptyEnv()
  Map.forEach((name, scheme) => {
    Map.set(name, scheme, cloned)
  }, values)
  cloned
}

let typeFromAnnotation = (annotation: CoreAst.TypeExpr) =>
  Layer1Expr.typeExprToType(annotation, Map.make())

let withBinding = (
  name: String,
  scheme: Types.Scheme,
  state: InferState,
  fn: InferState => (Types.Type, InferState),
) => {
  let previous = Env.lookupValue(state.env, name)
  let envWithBinding = Env.defineValue(state.env, name, scheme)
  let stateWithBinding = { ...state, env: envWithBinding }
  let (resultType, stateAfter) = fn(stateWithBinding)
  let restoredEnv = match (previous) {
    Some(prevScheme) => Env.defineValue(stateAfter.env, name, prevScheme),
    None => Env.removeValue(stateAfter.env, name),
  }
  (resultType, { ...stateAfter, env: restoredEnv })
}

let rec withPatternBindings = (
  pattern: CoreAst.Pattern,
  expectedType: Types.Type,
  state: InferState,
  fn: InferState => (Types.Type, InferState),
) => {
  let monoScheme: Types.Scheme = { quantifiers: [], ty: expectedType }
  match (pattern.kind) {
    CoreAst.Var(name) => {
      let applied = apply(state, expectedType)
      Map.set(pattern.node.id, applied, state.nodeTypes)
      Map.set(name.node.id, applied, state.nodeTypes)
      withBinding(name.text, monoScheme, state, fn)
    },
    CoreAst.Pin(name) => {
      let applied = apply(state, expectedType)
      Map.set(pattern.node.id, applied, state.nodeTypes)
      Map.set(name.node.id, applied, state.nodeTypes)
      withBinding(name.text, monoScheme, state, fn)
    },
    CoreAst.Lit(_) => {
      let litType = match (pattern.kind) {
        CoreAst.Lit(CoreAst.Int(_)) => Types.TNumber,
        CoreAst.Lit(CoreAst.Bool(_)) => Types.TBool,
        CoreAst.Lit(CoreAst.Str(_)) => Types.TString,
        CoreAst.Lit(CoreAst.Byte(_)) => Types.TByte,
        CoreAst.Lit(CoreAst.Char(_)) => Types.TChar,
        CoreAst.Lit(CoreAst.Unit) => Types.TVoid,
        _ => Types.TNumber,
      }
      let state1 = unifyForNode(
        pattern.node.id,
        "literal pattern",
        expectedType,
        litType,
        state
      )
      fn(state1)
    },
    CoreAst.Tuple(items) => {
      let rec freshTupleTypes = (
        remaining: List<CoreAst.Pattern>,
        st: InferState,
        acc: List<(CoreAst.Pattern, Types.Type)>,
      ) =>
        match (remaining) {
          [] => (List.reverse(acc), st),
          [item, ...rest] => {
            let (itemType, st1) = freshVar(st)
            freshTupleTypes(rest, st1, [(item, itemType), ...acc])
          },
        }

      let (itemPairs, state1) = freshTupleTypes(items, state, [])
      let tupleType = Types.TTuple(List.map(((_item, itemType)) => itemType, itemPairs))
      let state2 = unifyForNode(
        pattern.node.id,
        "tuple pattern",
        expectedType,
        tupleType,
        state1
      )

      let rec bindTupleItems = (
        pairs: List<(CoreAst.Pattern, Types.Type)>,
        st: InferState,
      ) =>
        match (pairs) {
          [] => fn(st),
          [(itemPattern, itemType), ...rest] =>
            withPatternBindings(
              itemPattern,
              itemType,
              st,
              stNext => bindTupleItems(rest, stNext)
            ),
        }

      bindTupleItems(itemPairs, state2)
    },
    CoreAst.Constructor(name, items) => {
      let (ctorType, state1) = lookupEnv(name, state)
      let (ctorArgs, ctorResult) = Layer1Patterns.flattenFunctionType(ctorType)
      let state2 = unifyForNode(
        pattern.node.id,
        "constructor pattern",
        expectedType,
        ctorResult,
        state1
      )

      let baseItemTypes = match ((ctorArgs, items)) {
        ([], []) => [],
        ([only], _) when List.length(items) > 1 => match (apply(state2, only)) {
          Types.TTuple(tupleItems) when List.length(tupleItems) == List.length(items) =>
            tupleItems,
          _ => [only],
        },
        _ => ctorArgs,
      }

      let arityMessage =
        "Constructor pattern arity mismatch for "
          ++ name.text
          ++ " (expected "
          ++ toString(List.length(baseItemTypes))
          ++ ", got "
          ++ toString(List.length(items))
          ++ ")"

      let rec freshTypes = (
        remaining: List<CoreAst.Pattern>,
        st: InferState,
        acc: List<Types.Type>,
      ) =>
        match (remaining) {
          [] => (List.reverse(acc), st),
          [_item, ...rest] => {
            let (ty, st1) = freshVar(st)
            freshTypes(rest, st1, [ty, ...acc])
          },
        }

      let (itemTypes, state3) = if (
        List.length(baseItemTypes) == List.length(items)
      ) {
        (baseItemTypes, state2)
      } else {
        let marked = addTypeMark(
          state2,
          TypeMismatch,
          originForNode(pattern.node.id, "constructor pattern arity"),
          CoreAst.PatternError,
          arityMessage
        )
        freshTypes(items, marked, [])
      }

      let rec zip = (
        pats: List<CoreAst.Pattern>,
        tys: List<Types.Type>,
        acc: List<(CoreAst.Pattern, Types.Type)>,
      ) => match ((pats, tys)) {
        ([], []) => List.reverse(acc),
        ([pat, ...patRest], [ty, ...tyRest]) =>
          zip(patRest, tyRest, [(pat, ty), ...acc]),
        _ => [],
      }

      let itemPairs = zip(items, itemTypes, [])

      let rec bindItems = (
        pairs: List<(CoreAst.Pattern, Types.Type)>,
        st: InferState,
      ) => match (pairs) {
        [] => fn(st),
        [(itemPattern, itemType), ...rest] =>
          withPatternBindings(
            itemPattern,
            itemType,
            st,
            stNext => bindItems(rest, stNext)
          ),
      }

      bindItems(itemPairs, state3)
    },
    _ => fn(state),
  }
}

let rec inferExpr = (expr: CoreAst.Expr, state: InferState) => {
  match (expr.kind) {
    CoreAst.Mark(_, inner) => inferExpr(inner, state),
    CoreAst.Lit(CoreAst.Int(_value)) => {
      let t = recordNodeType(expr.node.id, Types.TNumber, state)
      (t, state)
    },
    CoreAst.Lit(CoreAst.Bool(_)) => {
      let t = recordNodeType(expr.node.id, Types.TBool, state)
      (t, state)
    },
    CoreAst.Lit(CoreAst.Str(_)) => {
      let t = recordNodeType(expr.node.id, Types.TString, state)
      (t, state)
    },
    CoreAst.Lit(CoreAst.Byte(_)) => {
      let t = recordNodeType(expr.node.id, Types.TByte, state)
      (t, state)
    },
    CoreAst.Lit(CoreAst.Char(_)) => {
      let t = recordNodeType(expr.node.id, Types.TChar, state)
      (t, state)
    },
    CoreAst.Lit(CoreAst.Unit) => {
      let t = recordNodeType(expr.node.id, Types.TVoid, state)
      (t, state)
    },
    CoreAst.Ident(name) => {
      let (t, state1) = lookupEnv(name, state)
      let tRecorded = recordNodeType(expr.node.id, t, state1)
      (tRecorded, state1)
    },
    CoreAst.Hole(_) => {
      let t = Types.THole(expr.node.id)
      let state1 = state
      let tRecorded = recordNodeType(expr.node.id, t, state1)
      (tRecorded, state1)
    },
    CoreAst.Fn(fnExpr) => {
      let stateWithMatch = recordMatchArms(fnExpr, state)
      let clauses = List.filterMap(
        (item: CoreAst.FnItem) => match (item.kind) {
          CoreAst.Clause(clause) => Some(clause),
          _ => None,
        },
        fnExpr.items
      )
      if (clauses == []) {
        Panic.panic("Type error: empty function clauses")
      }
      let (paramType, state1) = freshVar(stateWithMatch)
      let (resultType, state2) = freshVar(state1)

      let rec inferClauses = (remaining: List<CoreAst.FnClause>, st: InferState) =>
        match (remaining) {
          [] => st,
          [clause, ...rest] => {
            let (_ignoredType, nextState) = withPatternBindings(
              clause.param,
              paramType,
              st,
              st1 => {
                let st2 = match (clause.guard) {
                  Some(guardExpr) => {
                    let (guardType, stGuard) = inferExpr(guardExpr, st1)
                    unifyForNode(
                      clause.node.id,
                      "function clause guard",
                      guardType,
                      Types.TBool,
                      stGuard
                    )
                  },
                None => st1,
              }
              let (bodyType, st3) = inferExpr(clause.body, st2)
                let st4 = unifyForNode(
                  clause.node.id,
                  "function clause result",
                  bodyType,
                  resultType,
                  st3
                )
                let nextState = inferClauses(rest, st4)
                (apply(nextState, resultType), nextState)
              }
            )
            nextState
          },
        }

      let stFn = inferClauses(clauses, state2)
      let fnType = Types.TFun(apply(stFn, paramType), apply(stFn, resultType))
      let tRecorded = recordNodeType(expr.node.id, fnType, stFn)
      (tRecorded, stFn)
    },
    CoreAst.Apply(callee, arg) => {
      match ((callee.kind, arg.kind)) {
        (CoreAst.Apply(innerCallee, targetExpr), _) =>
          match (innerCallee.kind) {
            CoreAst.Ident(fnName) when fnName.text == "project" =>
              match (arg.kind) {
                CoreAst.Lit(CoreAst.Str(fieldName)) => {
                  let (targetType, state1) = inferExpr(targetExpr, state)
                  let (fieldType, state2) = freshVar(state1)
                  let state3 = match (apply(state2, targetType)) {
                    Types.TNominal(typeName, typeArgs) =>
                      match (resolveNominalRecordFields(typeName, typeArgs, state2)) {
                        Some(fields) =>
                          match (findRecordFieldType(fields, fieldName)) {
                            Some(existingType) =>
                              unifyForNode(
                                expr.node.id,
                                "record projection field",
                                fieldType,
                                existingType,
                                state2
                              ),
                            None =>
                              addTypeMark(
                                state2,
                                TypeMismatch,
                                originForNode(expr.node.id, "record projection missing field"),
                                CoreAst.Inconsistent,
                                "Type error: unknown record field " ++ fieldName
                              ),
                          },
                        None =>
                          addTypeMark(
                            state2,
                            TypeMismatch,
                            originForNode(expr.node.id, "record projection nominal"),
                            CoreAst.Inconsistent,
                            "Type error: projection expects a nominal record value"
                          ),
                      },
                    _ =>
                      addTypeMark(
                        state2,
                        TypeMismatch,
                        originForNode(expr.node.id, "record projection"),
                        CoreAst.Inconsistent,
                        "Type error: projection expects a nominal record value"
                      ),
                  }
                  let resolved = apply(state3, fieldType)
                  let tRecorded = recordNodeType(expr.node.id, resolved, state3)
                  (tRecorded, state3)
                },
                _ => {
                  let (tUnknown, state1) = freshVar(state)
                  let state2 = addTypeMark(
                    state1,
                    TypeMismatch,
                    originForNode(expr.node.id, "record projection field"),
                    CoreAst.Inconsistent,
                    "Type error: record projection expects string field name"
                  )
                  let tRecorded = recordNodeType(expr.node.id, tUnknown, state2)
                  (tRecorded, state2)
                },
              },
            _ => {
              let (tCallee, state1) = inferExpr(callee, state)
              let (tArg, state2) = inferExpr(arg, state1)
              let (tRes, state3) = freshVar(state2)
              let state4 = unifyForNode(
                expr.node.id,
                "function application",
                tCallee,
                Types.TFun(tArg, tRes),
                state3
              )
              let state5 = match (callee.kind) {
                CoreAst.Fn(fnExpr) => handleMatchApplication(fnExpr, tArg, state4),
                _ => state4,
              }
              let tApplied = apply(state5, tRes)
              let tRecorded = recordNodeType(expr.node.id, tApplied, state5)
              (tRecorded, state5)
            },
          },
        (CoreAst.Ident(fnName), CoreAst.Tuple([targetExpr, fieldExpr])) when fnName.text == "project" =>
          match (fieldExpr.kind) {
            CoreAst.Lit(CoreAst.Str(fieldName)) => {
              let (targetType, state1) = inferExpr(targetExpr, state)
              let (fieldType, state2) = freshVar(state1)
              let state3 = match (apply(state2, targetType)) {
                Types.TNominal(typeName, typeArgs) =>
                  match (resolveNominalRecordFields(typeName, typeArgs, state2)) {
                    Some(fields) =>
                      match (findRecordFieldType(fields, fieldName)) {
                        Some(existingType) =>
                          unifyForNode(
                            expr.node.id,
                            "record projection field",
                            fieldType,
                            existingType,
                            state2
                          ),
                        None =>
                          addTypeMark(
                            state2,
                            TypeMismatch,
                            originForNode(expr.node.id, "record projection missing field"),
                            CoreAst.Inconsistent,
                            "Type error: unknown record field " ++ fieldName
                          ),
                      },
                    None =>
                      addTypeMark(
                        state2,
                        TypeMismatch,
                        originForNode(expr.node.id, "record projection nominal"),
                        CoreAst.Inconsistent,
                        "Type error: projection expects a nominal record value"
                      ),
                  },
                _ =>
                  addTypeMark(
                    state2,
                    TypeMismatch,
                    originForNode(expr.node.id, "record projection"),
                    CoreAst.Inconsistent,
                    "Type error: projection expects a nominal record value"
                  ),
              }
              let resolved = apply(state3, fieldType)
              let tRecorded = recordNodeType(expr.node.id, resolved, state3)
              (tRecorded, state3)
            },
            _ => {
              let (tUnknown, state1) = freshVar(state)
              let state2 = addTypeMark(
                state1,
                TypeMismatch,
                originForNode(expr.node.id, "record projection field"),
                CoreAst.Inconsistent,
                "Type error: record projection expects string field name"
              )
              let tRecorded = recordNodeType(expr.node.id, tUnknown, state2)
              (tRecorded, state2)
            },
          },
        (CoreAst.Ident(typeName), CoreAst.RecordLit(items)) =>
          match (Env.lookupType(state.env, typeName.text)) {
            Some(typeInfo) =>
              match (typeInfo.recordFields) {
                Some(_) => {
                  let (paramTypes, _paramMap, nextVar) = Layer1Expr.instantiateTypeParams(
                    typeInfo.typeParams,
                    state.nextVar
                  )
                  let nominalType = Types.TNominal(typeInfo.name, paramTypes)
                  let state0 = { ...state, nextVar }
                  let rec collectFields = (
                    remaining: List<CoreAst.RecordItem>,
                    st: InferState,
                    acc: List<(String, Types.Type)>,
                  ) =>
                    match (remaining) {
                      [] => (List.reverse(acc), st),
                      [item, ...rest] => match (item) {
                        CoreAst.Field(fieldName, valueExpr) => {
                          let (valueType, st1) = inferExpr(valueExpr, st)
                          collectFields(rest, st1, [(fieldName.text, valueType), ...acc])
                        },
                        CoreAst.Spread(valueExpr) => {
                          let (spreadType, st1) = inferExpr(valueExpr, st)
                          match (apply(st1, spreadType)) {
                            Types.TNominal(typeName, typeArgs) =>
                              match (resolveNominalRecordFields(typeName, typeArgs, st1)) {
                                Some(spreadFields) =>
                                  collectFields(rest, st1, List.append(List.reverse(spreadFields), acc)),
                                None => {
                                  let st2 = addTypeMark(
                                    st1,
                                    TypeMismatch,
                                    originForNode(expr.node.id, "record spread"),
                                    CoreAst.Inconsistent,
                                    "Type error: record spread expects a nominal record value"
                                  )
                                  collectFields(rest, st2, acc)
                                },
                              },
                            _ => {
                              let st2 = addTypeMark(
                                st1,
                                TypeMismatch,
                                originForNode(expr.node.id, "record spread"),
                                CoreAst.Inconsistent,
                                "Type error: record spread expects a nominal record value"
                              )
                              collectFields(rest, st2, acc)
                            },
                          }
                        },
                      },
                    }
                  let (fields, state1) = collectFields(items, state0, [])
                  let state2 = validateRecordLiteralAgainstNominal(
                    expr.node.id,
                    fields,
                    nominalType,
                    state1,
                    unify
                  )
                  let tRecorded = recordNodeType(expr.node.id, nominalType, state2)
                  (tRecorded, state2)
                },
                None => {
                  let (tCallee, state1) = inferExpr(callee, state)
                  let (tArg, state2) = inferExpr(arg, state1)
                  let (tRes, state3) = freshVar(state2)
                  let state4 = unifyForNode(
                    expr.node.id,
                    "function application",
                    tCallee,
                    Types.TFun(tArg, tRes),
                    state3
                  )
                  let tApplied = apply(state4, tRes)
                  let tRecorded = recordNodeType(expr.node.id, tApplied, state4)
                  (tRecorded, state4)
                },
              },
            None => {
              let (tCallee, state1) = inferExpr(callee, state)
              let (tArg, state2) = inferExpr(arg, state1)
              let (tRes, state3) = freshVar(state2)
              let state4 = unifyForNode(
                expr.node.id,
                "function application",
                tCallee,
                Types.TFun(tArg, tRes),
                state3
              )
              let tApplied = apply(state4, tRes)
              let tRecorded = recordNodeType(expr.node.id, tApplied, state4)
              (tRecorded, state4)
            },
          },
        _ => {
          let (tCallee, state1) = inferExpr(callee, state)
          let (tArg, state2) = inferExpr(arg, state1)
          let (tRes, state3) = freshVar(state2)
          let state4 = unifyForNode(
            expr.node.id,
            "function application",
            tCallee,
            Types.TFun(tArg, tRes),
            state3
          )
          let state5 = match (callee.kind) {
            CoreAst.Fn(fnExpr) => handleMatchApplication(fnExpr, tArg, state4),
            _ => state4,
          }
          let tApplied = apply(state5, tRes)
          let tRecorded = recordNodeType(expr.node.id, tApplied, state5)
          (tRecorded, state5)
        },
      }
    },
    CoreAst.Let(binding, body) => {
      match (binding.name.kind) {
        CoreAst.Var(name) | CoreAst.Pin(name) => {
          let (placeholder, stateSeed) = freshVar(state)
          let seedScheme: Types.Scheme = { quantifiers: [], ty: placeholder }
          let (tValueRaw, state1) = withBinding(
            name.text,
            seedScheme,
            stateSeed,
            st => inferExpr(binding.value, st)
          )
          let state2 = unifyForNode(
            binding.node.id,
            "recursive/local binding",
            placeholder,
            tValueRaw,
            state1
          )
          let state3 = match (binding.annotation) {
            Some(annotation) =>
              unifyForNode(
                binding.node.id,
                "binding annotation",
                tValueRaw,
                typeFromAnnotation(annotation),
                state2
              ),
            None => state2,
          }
          let tValue = match (binding.annotation) {
            Some(annotation) => apply(state3, typeFromAnnotation(annotation)),
            None => apply(state3, tValueRaw),
          }
          logState("let.preGeneralize", state3, nodeId=binding.node.id)
          let scheme = Types.generalize(
            Env.snapshotValues(state3.env),
            state3.subst,
            tValue
          )
          let (tBody, state3) = withBinding(
            name.text,
            scheme,
            state3,
            st => inferExpr(body, st)
          )
          let tRecorded = recordNodeType(expr.node.id, tBody, state3)
          (tRecorded, state3)
        },
        _ => {
          let (tValueRaw, state1) = inferExpr(binding.value, state)
          let state2 = match (binding.annotation) {
            Some(annotation) =>
              unifyForNode(
                binding.node.id,
                "binding annotation",
                tValueRaw,
                typeFromAnnotation(annotation),
                state1
              ),
            None => state1,
          }
          let tValue = match (binding.annotation) {
            Some(annotation) => apply(state2, typeFromAnnotation(annotation)),
            None => apply(state2, tValueRaw),
          }
          logState("let.preGeneralize", state2, nodeId=binding.node.id)
          let scheme = Types.generalize(
            Env.snapshotValues(state2.env),
            state2.subst,
            tValue
          )
          let (instType, nextVar) = Types.instantiate(scheme, state2.nextVar)
          let state3 = { ...state2, nextVar }
          let (tBody, state4) = withPatternBindings(
            binding.name,
            instType,
            state3,
            st => inferExpr(body, st)
          )
          let tRecorded = recordNodeType(expr.node.id, tBody, state4)
          (tRecorded, state4)
        },
      }
    },
    CoreAst.If(cond, thenExpr, elseOpt) => {
      let (tCond, state1) = inferExpr(cond, state)
      let (tThen, state2) = inferExpr(thenExpr, state1)
      let (tElse, state3) = match (elseOpt) {
        None => (Types.TVoid, state2),
        Some(e) => inferExpr(e, state2),
      }
      let state4 = unifyForNode(
        expr.node.id,
        "if condition",
        tCond,
        Types.TBool,
        state3
      )
      let state5 = unifyForNode(
        expr.node.id,
        "if branches",
        tThen,
        tElse,
        state4
      )
      let t = recordNodeType(expr.node.id, tThen, state5)
      (t, state5)
    },
    CoreAst.Tuple(exprs) => {
      let (types, state1) = inferExprList(exprs, state)
      let t = recordNodeType(expr.node.id, Types.TTuple(types), state1)
      (t, state1)
    },
    CoreAst.RecordLit(items) => {
      let rec collectProvidedFields = (
        remaining: List<CoreAst.RecordItem>,
        st: InferState,
        acc: List<(String, Types.Type)>,
      ) =>
        match (remaining) {
          [] => (List.reverse(acc), st),
          [item, ...rest] => match (item) {
            CoreAst.Field(fieldName, valueExpr) => {
              let (valueType, st1) = inferExpr(valueExpr, st)
              collectProvidedFields(rest, st1, [(fieldName.text, valueType), ...acc])
            },
            CoreAst.Spread(valueExpr) => {
              let (_spreadType, st1) = inferExpr(valueExpr, st)
              collectProvidedFields(rest, st1, acc)
            },
          },
        }
      let (fields, state1) = collectProvidedFields(items, state, [])
      let (recordType, state2) = inferNominalRecordContext(expr.node.id, fields, state1, unify)
      let t = recordNodeType(expr.node.id, recordType, state2)
      (t, state2)
    },
    _ => {
      let (t, state1) = freshVar(state)
      let tRecorded = recordNodeType(expr.node.id, t, state1)
      (tRecorded, state1)
    },
  }
}
and inferExprList = (exprs: List<CoreAst.Expr>, state: InferState) => {
  match (exprs) {
    [] => ([], state),
    [expr, ...rest] => {
      let (t, state1) = inferExpr(expr, state)
      let (restTypes, state2) = inferExprList(rest, state1)
      ([t, ...restTypes], state2)
    },
  }
}

let inferBindingValue = (binding: CoreAst.LetBinding, state: InferState) => {
  let annotationTypeOpt = match (binding.annotation) {
    Some(annotation) => Some(typeFromAnnotation(annotation)),
    None => None,
  }
  let (valueType, state1) = match ((annotationTypeOpt, binding.value.kind)) {
    (Some(expectedType), CoreAst.RecordLit(items)) => {
      let rec collectFields = (
        remaining: List<CoreAst.RecordItem>,
        st: InferState,
        acc: List<(String, Types.Type)>,
      ) =>
        match (remaining) {
          [] => (List.reverse(acc), st),
          [item, ...rest] => match (item) {
            CoreAst.Field(fieldName, valueExpr) => {
              let (valueType, st1) = inferExpr(valueExpr, st)
              collectFields(rest, st1, [(fieldName.text, valueType), ...acc])
            },
            CoreAst.Spread(valueExpr) => {
              let (spreadType, st1) = inferExpr(valueExpr, st)
              match (apply(st1, spreadType)) {
                Types.TNominal(typeName, typeArgs) =>
                  match (resolveNominalRecordFields(typeName, typeArgs, st1)) {
                    Some(spreadFields) =>
                      collectFields(rest, st1, List.append(List.reverse(spreadFields), acc)),
                    None => {
                      let st2 = addTypeMark(
                        st1,
                        TypeMismatch,
                        originForNode(binding.value.node.id, "record spread"),
                        CoreAst.Inconsistent,
                        "Type error: record spread expects a nominal record value"
                      )
                      collectFields(rest, st2, acc)
                    },
                  },
                _ => {
                  let st2 = addTypeMark(
                    st1,
                    TypeMismatch,
                    originForNode(binding.value.node.id, "record spread"),
                    CoreAst.Inconsistent,
                    "Type error: record spread expects a nominal record value"
                  )
                  collectFields(rest, st2, acc)
                },
              }
            },
          },
        }
      let (fields, st1) = collectFields(items, state, [])
      let st2 = validateRecordLiteralAgainstNominal(binding.value.node.id, fields, expectedType, st1, unify)
      (expectedType, st2)
    },
    _ => inferExpr(binding.value, state),
  }
  let state2 = match (annotationTypeOpt) {
    Some(annotationType) =>
      unifyForNode(
        binding.node.id,
        "binding annotation",
        valueType,
        annotationType,
        state1
      ),
    None => state1,
  }
  let appliedValueType0 = match (annotationTypeOpt) {
    Some(annotationType) => apply(state2, annotationType),
    None => apply(state2, valueType),
  }
  let (appliedValueType, state3a) = (appliedValueType0, state2)
  let state3 = match (binding.name.kind) {
    CoreAst.Var(name) => {
      Map.set(binding.name.node.id, appliedValueType, state3a.nodeTypes)
      Map.set(name.node.id, appliedValueType, state3a.nodeTypes)
      state3a
    },
    CoreAst.Pin(name) => {
      Map.set(binding.name.node.id, appliedValueType, state3a.nodeTypes)
      Map.set(name.node.id, appliedValueType, state3a.nodeTypes)
      state3a
    },
    _ => state3a,
  }
  (appliedValueType, state3)
}

let inferLetBinding = (binding: CoreAst.LetBinding, state: InferState) => {
  let (tValue, state1) = inferBindingValue(binding, state)
  logState("letBinding.preGeneralize", state1, nodeId=binding.node.id)
  let scheme = Types.generalize(
    Env.snapshotValues(state1.env),
    state1.subst,
    tValue
  )
  let name = Layer1Expr.bindingName(binding)
  Env.defineValue(state1.env, name, scheme)
  Map.set(name, scheme, state1.topBindings)
  state1
}

let inferRecursiveBindings = (bindings: List<CoreAst.LetBinding>, state: InferState) => {
  let baseValues = cloneEnvValues(Env.snapshotValues(state.env))
  let seed = Layer1Bindings.seedRecursivePlaceholders(bindings, state.nextVar)
  let placeholders = seed.placeholders
  let state1 = { ...state, nextVar: seed.nextVar }
  List.forEach(((name, placeholderType): (String, Types.Type)) => {
    Env.defineValue(
      state1.env,
      name,
      { quantifiers: [], ty: placeholderType }: Types.Scheme
    )
    void
  }, placeholders)

  let rec inferBodies = (remaining: List<CoreAst.LetBinding>, st: InferState) =>
    match (remaining) {
      [] => st,
      [binding, ...rest] => {
        let name = Layer1Expr.bindingName(binding)
        let placeholderType = match (Layer1Bindings.lookupPlaceholder(name, placeholders)) {
          Some(t) => t,
          None => Panic.panic("Missing placeholder for recursive binding " ++ name),
        }
        let (valueType, st1) = inferBindingValue(binding, st)
        let st2 = unifyForNode(
          binding.node.id,
          "recursive binding",
          placeholderType,
          valueType,
          st1
        )
        inferBodies(rest, st2)
      },
    }

  let state2 = inferBodies(bindings, state1)
  logState("rec.preFinalize", state2)

  let rec finalize = (remaining: List<(String, Types.Type)>, st: InferState) =>
    match (remaining) {
      [] => st,
      [(name, placeholderType), ...rest] => {
        let scheme = Types.generalize(baseValues, st.subst, placeholderType)
        Env.defineValue(st.env, name, scheme)
        Map.set(name, scheme, st.topBindings)
        finalize(rest, st)
      },
    }

  finalize(placeholders, state2)
}

let registerTypeDecl = (decl: CoreAst.TypeDecl, state: InferState) => {
  let prepared = Layer1Decl.prepareTypeDecl(decl, state.nextVar)
  let env1 = Env.registerType(state.env, prepared.info)
  List.forEach(((name, scheme): (String, Types.Scheme)) => {
    Env.defineValue(env1, name, scheme)
    void
  }, prepared.constructorSchemes)
  { ...state, nextVar: prepared.nextVar, env: env1 }
}

let registerRecordDecl = (decl: CoreAst.RecordDecl, state: InferState) => {
  let info = Layer1Decl.prepareRecordDecl(decl)
  let env1 = Env.registerType(state.env, info)
  { ...state, env: env1 }
}

let inferTopItems = (items: List<CoreAst.TopItem>, state: InferState) =>
  Layer1Top.inferTopItems(
    items,
    state,
    (dg, st) =>
      Layer1Top.inferDeclGroup(
        dg,
        st,
        (ld, groupKind, stDecl) => match (groupKind) {
          CoreAst.LetGroup(CoreAst.Rec) =>
            inferRecursiveBindings(ld.bindings, stDecl),
          _ =>
            Layer1Bindings.inferLetBindingsSequential(
              ld.bindings,
              stDecl,
              inferLetBinding
            ),
        },
        registerTypeDecl,
        (decl, stDecl) => match (decl) {
          CoreAst.RecordDecl(recordDecl) => registerRecordDecl(recordDecl, stDecl),
          _ => stDecl,
        }
      ),
    (_item, st) => st
  )

let solveConstraints = (state: InferState) => {
  let isConcreteConflict = (left: Types.Type, right: Types.Type) => {
    let rec loop = (a: Types.Type, b: Types.Type) =>
      match ((a, b)) {
        (Types.THole(_), _) => false,
        (_, Types.THole(_)) => false,
        (Types.TVar(_), _) => false,
        (_, Types.TVar(_)) => false,
        (Types.TNumber, Types.TNumber) => false,
        (Types.TBool, Types.TBool) => false,
        (Types.TString, Types.TString) => false,
        (Types.TByte, Types.TByte) => false,
        (Types.TChar, Types.TChar) => false,
        (Types.TVoid, Types.TVoid) => false,
        (Types.TFun(a1, b1), Types.TFun(a2, b2)) => loop(a1, a2) || loop(b1, b2),
        (Types.TTuple(xs), Types.TTuple(ys)) =>
          if (List.length(xs) != List.length(ys)) {
            true
          } else {
            let rec anyConflict = (leftItems: List<Types.Type>, rightItems: List<Types.Type>) =>
              match ((leftItems, rightItems)) {
                ([], []) => false,
                ([xh, ...xt], [yh, ...yt]) => loop(xh, yh) || anyConflict(xt, yt),
                _ => true,
            }
            anyConflict(xs, ys)
          },
        (Types.TNominal(nameL, argsL), Types.TNominal(nameR, argsR)) =>
          if (nameL != nameR || List.length(argsL) != List.length(argsR)) {
            true
          } else {
            let rec anyConflict = (leftItems: List<Types.Type>, rightItems: List<Types.Type>) =>
              match ((leftItems, rightItems)) {
                ([], []) => false,
                ([xh, ...xt], [yh, ...yt]) => loop(xh, yh) || anyConflict(xt, yt),
                _ => true,
              }
            anyConflict(argsL, argsR)
          },
        _ => true,
      }
    loop(left, right)
  }

  let addUnfillableHoleMarks = (
    marksState: InferState,
    solvedSubst: Types.Subst,
  ) =>
    List.reduce(
      (acc: InferState, entry: (Number, List<HoleObservation>)) => {
        let (holeId, observations) = entry
        let normalized = List.map(
          (obs: HoleObservation) =>
            {
              observed: Types.applySubstType(solvedSubst, obs.observed),
              origin: obs.origin,
            }: HoleObservation,
          observations
        )
        let rec hasConflict = (remaining: List<HoleObservation>) =>
          match (remaining) {
            [] => false,
            [head, ...tail] => {
              let pairConflict = List.some(
                (other: HoleObservation) =>
                  isConcreteConflict(head.observed, other.observed),
                tail
              )
              pairConflict || hasConflict(tail)
            },
          }
        if (hasConflict(normalized)) {
          addTypeMark(
            acc,
            UnfillableHole,
            Constraints.makeOrigin(holeId, "unfillable hole"),
            CoreAst.UnfillableHole,
            "Type error: unfillable hole"
          )
        } else {
          acc
        }
      },
      marksState,
      Map.toList(marksState.holeObservations)
    )

  // Hazel-style layering: Layer 1 has already enforced HM equality constraints.
  // Layer 2 handles only deferred/domain constraints.
  let deferred = List.filter((constraint: Constraints.Constraint) =>
    match (constraint) {
      Constraints.Domain(_, _) => true,
      _ => false,
    }, state.constraints)

  let solverState = List.reduce(
    (acc, constraint) => Solver.addConstraint(acc, constraint),
    Solver.withSubst(state.subst),
    List.reverse(deferred)
  )
  match (Solver.solve(solverState)) {
    Ok(result) => {
      Env.applySubst(state.env, result.subst)
      let solvedNodeTypes = Map.make()
      Map.forEach((id, ty) => {
        let solved = Types.applySubstType(result.subst, ty)
        Map.set(id, solved, solvedNodeTypes)
      }, state.nodeTypes)

      let solvedState = {
        ...state,
        subst: result.subst,
        nodeTypes: solvedNodeTypes,
        constraints: result.domainConstraints,
      }
      addUnfillableHoleMarks(solvedState, result.subst)
    },
    Err(Solver.Occurs(origin)) =>
      addTypeMark(
        state,
        OccursCycle,
        origin,
        CoreAst.OccursCheck,
        "Type error: occurs check failed"
      ),
    Err(Solver.CannotUnify(left, right, origin)) =>
      addTypeMark(
        state,
        TypeMismatch,
        origin,
        CoreAst.Inconsistent,
        "Type error (" ++ origin.description ++ "): cannot unify "
          ++ Types.typeToReadableString(left)
          ++ " with "
          ++ Types.typeToReadableString(right)
      ),
  }
}

provide let inferProgram = (program: CoreAst.Program) => {
  let state = makeInitialState()
  let inferred = inferTopItems(program.items, state)
  solveConstraints(inferred)
}

provide let inferProgramWithEnv = (program: CoreAst.Program, env: Types.Env) => {
  let baseEnv = seedBuiltinValues(Env.empty())
  Map.forEach((name, scheme) => {
    Env.defineValue(baseEnv, name, scheme)
    void
  }, env)
  let state = { ...makeInitialState(), env: baseEnv }
  let inferred = inferTopItems(program.items, state)
  solveConstraints(inferred)
}

provide let inferProgramLayer1 = (program: CoreAst.Program) => {
  let state = makeInitialState()
  inferTopItems(program.items, state)
}

provide let inferProgramLayer1WithEnv = (program: CoreAst.Program, env: Types.Env) => {
  let baseEnv = seedBuiltinValues(Env.empty())
  Map.forEach((name, scheme) => {
    Env.defineValue(baseEnv, name, scheme)
    void
  }, env)
  let state = { ...makeInitialState(), env: baseEnv }
  inferTopItems(program.items, state)
}

provide let inferProgramLayer2 = (state: InferState) => solveConstraints(state)
