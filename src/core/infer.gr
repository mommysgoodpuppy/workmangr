module Infer

from "list" include List
from "map" include Map
from "runtime/unsafe/panic" include Panic

from "./core_ast.gr" include CoreAst
from "./types.gr" include Types
from "./env.gr" include Env
from "./constraints.gr" include Constraints
from "./solver.gr" include Solver

provide record InferState {
  nextVar: Number,
  subst: Types.Subst,
  env: Env.TypingEnv,
  nodeTypes: Map.Map<Number, Types.Type>,
  topBindings: Map.Map<String, Types.Scheme>,
  constraints: List<Constraints.Constraint>,
}

let makeInitialState = () => {
  let subst = Types.emptySubst()
  let env = Env.empty()
  let nodeTypes = Map.make()
  let topBindings = Map.make()
  { nextVar: 1, subst, env, nodeTypes, topBindings, constraints: [] }
}

let recordConstraint = (state: InferState, constraint: Constraints.Constraint) =>
  { ...state, constraints: [constraint, ...state.constraints] }

let originForNode = (nodeId: Number, description: String) =>
  Constraints.makeOrigin(nodeId, description)

let panicWithOrigin = (message: String, origin: Constraints.Origin) =>
  Panic.panic(message ++ " (" ++ Constraints.originToString(origin) ++ ")")

let freshVar = (state: InferState) => {
  let id = state.nextVar
  (Types.TVar(id), { ...state, nextVar: id + 1 })
}

let apply = (state: InferState, t: Types.Type) =>
  Types.applySubstType(state.subst, t)

let occurs = (varId: Number, t: Types.Type, state: InferState) => {
  let fv = Types.freeVars(apply(state, t))
  Types.containsVar(fv, varId)
}

let bindVar = (
  varId: Number,
  t: Types.Type,
  state: InferState,
  origin: Constraints.Origin,
) => {
  let tApplied = apply(state, t)
  if (tApplied == Types.TVar(varId)) {
    state
  } else if (occurs(varId, tApplied, state)) {
    panicWithOrigin("Type error: occurs check failed", origin)
  } else {
    Map.set(varId, tApplied, state.subst)
    state
  }
}

let rec unify = (
  left: Types.Type,
  right: Types.Type,
  origin: Constraints.Origin,
  state: InferState,
) => {
  let constraint = Constraints.Equality(left, right, origin)
  let state1 = recordConstraint(state, constraint)
  let l = apply(state1, left)
  let r = apply(state1, right)

  match ((l, r)) {
    (Types.TNumber, Types.TNumber) => state1,
    (Types.TVoid, Types.TVoid) => state1,
    (Types.TVar(id), t) => bindVar(id, t, state1, origin),
    (t, Types.TVar(id)) => bindVar(id, t, state1, origin),
    (Types.TFun(a1, b1), Types.TFun(a2, b2)) => {
      let state2 = unify(a1, a2, origin, state1)
      unify(b1, b2, origin, state2)
    },
    _ => panicWithOrigin("Type error: cannot unify types", origin),
  }
}

let unifyForNode = (
  nodeId: Number,
  description: String,
  left: Types.Type,
  right: Types.Type,
  state: InferState,
) => unify(left, right, originForNode(nodeId, description), state)

let recordNodeType = (id: Number, t: Types.Type, state: InferState) => {
  let applied = apply(state, t)
  Map.set(id, applied, state.nodeTypes)
  applied
}

let lookupEnv = (name: String, state: InferState) => {
  match (Env.lookupValue(state.env, name)) {
    Some(scheme) => {
      let (inst, nextVar) = Types.instantiate(scheme, state.nextVar)
      (Types.applySubstType(state.subst, inst), { ...state, nextVar })
    },
    None => Panic.panic("Type error: unknown identifier"),
  }
}

let withBinding = (
  name: String,
  scheme: Types.Scheme,
  state: InferState,
  fn: InferState => (Types.Type, InferState),
) => {
  let previous = Env.lookupValue(state.env, name)
  let envWithBinding = Env.defineValue(state.env, name, scheme)
  let (resultType, stateAfter) = fn(state)
  match (previous) {
    Some(prevScheme) => Env.defineValue(envWithBinding, name, prevScheme),
    None => Env.removeValue(state.env, name),
  }
  (resultType, stateAfter)
}

let rec inferExpr = (expr: CoreAst.Expr, state: InferState) => {
  match (expr.kind) {
    CoreAst.Mark(_, inner) => inferExpr(inner, state),
    CoreAst.Lit(CoreAst.Int(_value)) => {
      let t = recordNodeType(expr.node.id, Types.TNumber, state)
      (t, state)
    },
    CoreAst.Lit(_) => {
      let t = recordNodeType(expr.node.id, Types.TNumber, state)
      (t, state)
    },
    CoreAst.Ident(name) => {
      let (t, state1) = lookupEnv(name.text, state)
      let tRecorded = recordNodeType(expr.node.id, t, state1)
      (tRecorded, state1)
    },
    CoreAst.Hole(_) => {
      let (t, state1) = freshVar(state)
      let tRecorded = recordNodeType(expr.node.id, t, state1)
      (tRecorded, state1)
    },
    CoreAst.Fn(fnExpr) => {
      let clause = match (fnExpr.items) {
        [item, ..._] => match (item.kind) {
          CoreAst.Clause(c) => c,
          _ => Panic.panic("Type error: function item is not a clause"),
        },
        _ => Panic.panic("Type error: empty function clauses"),
      }
      let paramName = match (clause.param.kind) {
        CoreAst.Var(name) => name.text,
        _ => "_",
      }
      let (paramType, state1) = freshVar(state)
      let monoScheme: Types.Scheme = { quantifiers: [], ty: paramType }
      let (fnType, stFn) = withBinding(paramName, monoScheme, state1, st => {
        let (tBody, stBody) = inferExpr(clause.body, st)
        (Types.TFun(paramType, tBody), stBody)
      })
      let tRecorded = recordNodeType(expr.node.id, fnType, stFn)
      (tRecorded, stFn)
    },
    CoreAst.Apply(callee, arg) => {
      let (tCallee, state1) = inferExpr(callee, state)
      let (tArg, state2) = inferExpr(arg, state1)
      let (tRes, state3) = freshVar(state2)
      let state4 = unifyForNode(
        expr.node.id,
        "function application",
        tCallee,
        Types.TFun(tArg, tRes),
        state3
      )
      let tApplied = apply(state4, tRes)
      let tRecorded = recordNodeType(expr.node.id, tApplied, state4)
      (tRecorded, state4)
    },
    CoreAst.Let(binding, body) => {
      let (tValue, state1) = inferExpr(binding.value, state)
      Env.applySubst(state1.env, state1.subst)
      let scheme = Types.generalize(
        Env.snapshotValues(state1.env),
        state1.subst,
        tValue
      )
      let bindingName = match (binding.name.kind) {
        CoreAst.Var(name) => name.text,
        _ => "_",
      }
      let (tBody, state2) = withBinding(
        bindingName,
        scheme,
        state1,
        st => inferExpr(body, st)
      )
      let tRecorded = recordNodeType(expr.node.id, tBody, state2)
      (tRecorded, state2)
    },
    CoreAst.If(cond, thenExpr, elseOpt) => {
      let (tCond, state1) = inferExpr(cond, state)
      let (tThen, state2) = inferExpr(thenExpr, state1)
      let (tElse, state3) = match (elseOpt) {
        None => (Types.TVoid, state2),
        Some(e) => inferExpr(e, state2),
      }
      let state4 = unifyForNode(
        expr.node.id,
        "if branches",
        tThen,
        tElse,
        state3
      )
      let t = recordNodeType(expr.node.id, tThen, state4)
      (t, state4)
    },
    CoreAst.Tuple(exprs) => {
      let (types, state1) = inferExprList(exprs, state)
      let t = recordNodeType(expr.node.id, Types.TNumber, state1)
      (t, state1)
    },
    _ => {
      let (t, state1) = freshVar(state)
      let tRecorded = recordNodeType(expr.node.id, t, state1)
      (tRecorded, state1)
    },
  }
}
and inferExprList = (exprs: List<CoreAst.Expr>, state: InferState) => {
  match (exprs) {
    [] => ([], state),
    [expr, ...rest] => {
      let (t, state1) = inferExpr(expr, state)
      let (restTypes, state2) = inferExprList(rest, state1)
      ([t, ...restTypes], state2)
    },
  }
}

let inferLetBinding = (binding: CoreAst.LetBinding, state: InferState) => {
  let (tValue, state1) = inferExpr(binding.value, state)
  Env.applySubst(state1.env, state1.subst)
  let scheme = Types.generalize(
    Env.snapshotValues(state1.env),
    state1.subst,
    tValue
  )
  let bindingName = match (binding.name.kind) {
    CoreAst.Var(name) => name.text,
    _ => "_",
  }
  Env.defineValue(state1.env, bindingName, scheme)
  Map.set(bindingName, scheme, state1.topBindings)
  state1
}

let rec inferTopItems = (items: List<CoreAst.TopItem>, state: InferState) => {
  match (items) {
    [] => state,
    [item, ...rest] => {
      let state1 = match (item) {
        CoreAst.DeclGroup(dg) => {
          let rec inferDecls = (decls: List<CoreAst.Decl>, st: InferState) => {
            match (decls) {
              [] => st,
              [decl, ...restDecls] => {
                let st1 = match (decl) {
                  CoreAst.LetDecl(ld) => {
                    let rec inferBindings = (
                      bindings: List<CoreAst.LetBinding>,
                      s: InferState,
                    ) => {
                      match (bindings) {
                        [] => s,
                        [b, ...restBindings] =>
                          inferBindings(restBindings, inferLetBinding(b, s)),
                      }
                    }
                    inferBindings(ld.bindings, st)
                  },
                  _ => st,
                }
                inferDecls(restDecls, st1)
              },
            }
          }
          inferDecls(dg.decls, state)
        },
        _ => state,
      }
      inferTopItems(rest, state1)
    },
  }
}

let solveConstraints = (state: InferState) => {
  let solverState = List.reduce(
    (acc, constraint) => Solver.addConstraint(acc, constraint),
    Solver.withSubst(state.subst),
    List.reverse(state.constraints)
  )
  match (Solver.solve(solverState)) {
    Ok(result) => {
      Env.applySubst(state.env, result.subst)
      { ...state, subst: result.subst, constraints: result.domainConstraints }
    },
    Err(Solver.Occurs(origin)) =>
      panicWithOrigin("Type error: occurs check failed", origin),
    Err(Solver.CannotUnify(left, right, origin)) =>
      panicWithOrigin(
        "Type error: cannot unify "
          ++ Types.typeToString(left)
          ++ " with "
          ++ Types.typeToString(right),
        origin
      ),
  }
}

provide let inferProgram = (program: CoreAst.Program) => {
  let state = makeInitialState()
  let inferred = inferTopItems(program.items, state)
  solveConstraints(inferred)
}

provide let inferProgramWithEnv = (program: CoreAst.Program, env: Types.Env) => {
  let baseEnv = Env.empty()
  Map.forEach((name, scheme) => {
    Env.defineValue(baseEnv, name, scheme)
    void
  }, env)
  let state = { ...makeInitialState(), env: baseEnv }
  let inferred = inferTopItems(program.items, state)
  solveConstraints(inferred)
}
