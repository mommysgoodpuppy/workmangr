module Infer

from "map" include Map
from "runtime/unsafe/panic" include Panic

from "./core_ast.gr" include CoreAst
from "./types.gr" include Types

provide record InferState {
  nextVar: Number,
  subst: Types.Subst,
  env: Types.Env,
  nodeTypes: Map.Map<Number, Types.Type>,
  topBindings: Map.Map<String, Types.Scheme>,
}

let makeInitialState = () => {
  let subst = Types.emptySubst()
  let env = Types.emptyEnv()
  let nodeTypes = Map.make()
  let topBindings = Map.make()
  { nextVar: 1, subst, env, nodeTypes, topBindings }
}

let freshVar = (state: InferState) => {
  let id = state.nextVar
  (Types.TVar(id), { ...state, nextVar: id + 1 })
}

let apply = (state: InferState, t: Types.Type) =>
  Types.applySubstType(state.subst, t)

let occurs = (varId: Number, t: Types.Type, state: InferState) => {
  let fv = Types.freeVars(apply(state, t))
  Types.containsVar(fv, varId)
}

let bindVar = (varId: Number, t: Types.Type, state: InferState) => {
  let tApplied = apply(state, t)
  if (tApplied == Types.TVar(varId)) {
    state
  } else if (occurs(varId, tApplied, state)) {
    Panic.panic("Type error: occurs check failed")
  } else {
    Map.set(varId, tApplied, state.subst)
    state
  }
}

let rec unify = (left: Types.Type, right: Types.Type, state: InferState) => {
  let l = apply(state, left)
  let r = apply(state, right)

  match ((l, r)) {
    (Types.TNumber, Types.TNumber) => state,
    (Types.TVoid, Types.TVoid) => state,
    (Types.TVar(id), t) => bindVar(id, t, state),
    (t, Types.TVar(id)) => bindVar(id, t, state),
    (Types.TFun(a1, b1), Types.TFun(a2, b2)) => {
      let state1 = unify(a1, a2, state)
      unify(b1, b2, state1)
    },
    _ => Panic.panic("Type error: cannot unify types"),
  }
}

let recordNodeType = (id: Number, t: Types.Type, state: InferState) => {
  let applied = apply(state, t)
  Map.set(id, applied, state.nodeTypes)
  applied
}

let lookupEnv = (name: String, state: InferState) => {
  match (Map.get(name, state.env)) {
    Some(scheme) => {
      let (inst, nextVar) = Types.instantiate(scheme, state.nextVar)
      (Types.applySubstType(state.subst, inst), { ...state, nextVar })
    },
    None => Panic.panic("Type error: unknown identifier"),
  }
}

let withBinding = (
  name: String,
  scheme: Types.Scheme,
  state: InferState,
  fn: InferState => (Types.Type, InferState),
) => {
  let previous = Map.get(name, state.env)
  Map.set(name, scheme, state.env)
  let (resultType, stateAfter) = fn(state)
  match (previous) {
    Some(prevScheme) => Map.set(name, prevScheme, state.env),
    None => Map.remove(name, state.env),
  }
  (resultType, stateAfter)
}

let rec inferExpr = (expr: CoreAst.Expr, state: InferState) => {
  match (expr.kind) {
    CoreAst.Mark(_, inner) => inferExpr(inner, state),
    CoreAst.Lit(CoreAst.Int(_value)) => {
      let t = recordNodeType(expr.node.id, Types.TNumber, state)
      (t, state)
    },
    CoreAst.Lit(_) => {
      let t = recordNodeType(expr.node.id, Types.TNumber, state)
      (t, state)
    },
    CoreAst.Ident(name) => {
      let (t, state1) = lookupEnv(name.text, state)
      let tRecorded = recordNodeType(expr.node.id, t, state1)
      (tRecorded, state1)
    },
    CoreAst.Hole(_) => {
      let (t, state1) = freshVar(state)
      let tRecorded = recordNodeType(expr.node.id, t, state1)
      (tRecorded, state1)
    },
    CoreAst.Fn(fnExpr) => {
      let clause = match (fnExpr.items) {
        [item, ..._] =>
          match (item.kind) {
            CoreAst.Clause(c) => c,
            _ => Panic.panic("Type error: function item is not a clause"),
          },
        _ => Panic.panic("Type error: empty function clauses"),
      }
      let paramName = match (clause.param.kind) {
        CoreAst.Var(name) => name.text,
        _ => "_",
      }
      let (paramType, state1) = freshVar(state)
      let monoScheme: Types.Scheme = { quantifiers: [], ty: paramType }
      let (fnType, stFn) = withBinding(
        paramName,
        monoScheme,
        state1,
        st => {
          let (tBody, stBody) = inferExpr(clause.body, st)
          (Types.TFun(paramType, tBody), stBody)
        }
      )
      let tRecorded = recordNodeType(expr.node.id, fnType, stFn)
      (tRecorded, stFn)
    },
    CoreAst.Apply(callee, arg) => {
      let (tCallee, state1) = inferExpr(callee, state)
      let (tArg, state2) = inferExpr(arg, state1)
      let (tRes, state3) = freshVar(state2)
      let state4 = unify(tCallee, Types.TFun(tArg, tRes), state3)
      let tApplied = apply(state4, tRes)
      let tRecorded = recordNodeType(expr.node.id, tApplied, state4)
      (tRecorded, state4)
    },
    CoreAst.Let(binding, body) => {
      let (tValue, state1) = inferExpr(binding.value, state)
      Types.applySubstEnv(state1.subst, state1.env)
      let scheme = Types.generalize(state1.env, state1.subst, tValue)
      let bindingName = match (binding.name.kind) {
        CoreAst.Var(name) => name.text,
        _ => "_",
      }
      let (tBody, state2) = withBinding(
        bindingName,
        scheme,
        state1,
        st => inferExpr(body, st)
      )
      let tRecorded = recordNodeType(expr.node.id, tBody, state2)
      (tRecorded, state2)
    },
    CoreAst.If(cond, thenExpr, elseOpt) => {
      let (tCond, state1) = inferExpr(cond, state)
      let (tThen, state2) = inferExpr(thenExpr, state1)
      let (tElse, state3) = match (elseOpt) {
        None => (Types.TVoid, state2),
        Some(e) => inferExpr(e, state2),
      }
      let state4 = unify(tThen, tElse, state3)
      let t = recordNodeType(expr.node.id, tThen, state4)
      (t, state4)
    },
    CoreAst.Tuple(exprs) => {
      let (types, state1) = inferExprList(exprs, state)
      let t = recordNodeType(expr.node.id, Types.TNumber, state1)
      (t, state1)
    },
    _ => {
      let (t, state1) = freshVar(state)
      let tRecorded = recordNodeType(expr.node.id, t, state1)
      (tRecorded, state1)
    }
  }
}
and inferExprList = (exprs: List<CoreAst.Expr>, state: InferState) => {
  match (exprs) {
    [] => ([], state),
    [expr, ...rest] => {
      let (t, state1) = inferExpr(expr, state)
      let (restTypes, state2) = inferExprList(rest, state1)
      ([t, ...restTypes], state2)
    },
  }
}

let inferLetBinding = (binding: CoreAst.LetBinding, state: InferState) => {
  let (tValue, state1) = inferExpr(binding.value, state)
  Types.applySubstEnv(state1.subst, state1.env)
  let scheme = Types.generalize(state1.env, state1.subst, tValue)
  let bindingName = match (binding.name.kind) {
    CoreAst.Var(name) => name.text,
    _ => "_",
  }
  Map.set(bindingName, scheme, state1.env)
  Map.set(bindingName, scheme, state1.topBindings)
  state1
}

let rec inferTopItems = (items: List<CoreAst.TopItem>, state: InferState) => {
  match (items) {
    [] => state,
    [item, ...rest] => {
      let state1 = match (item) {
        CoreAst.DeclGroup(dg) => {
          let rec inferDecls = (decls: List<CoreAst.Decl>, st: InferState) => {
            match (decls) {
              [] => st,
              [decl, ...restDecls] => {
                let st1 = match (decl) {
                  CoreAst.LetDecl(ld) => {
                    let rec inferBindings = (bindings: List<CoreAst.LetBinding>, s: InferState) => {
                      match (bindings) {
                        [] => s,
                        [b, ...restBindings] => inferBindings(restBindings, inferLetBinding(b, s))
                      }
                    }
                    inferBindings(ld.bindings, st)
                  },
                  _ => st
                }
                inferDecls(restDecls, st1)
              }
            }
          }
          inferDecls(dg.decls, state)
        },
        _ => state
      }
      inferTopItems(rest, state1)
    }
  }
}

provide let inferProgram = (program: CoreAst.Program) => {
  let state = makeInitialState()
  let finalState = inferTopItems(program.items, state)
  Types.applySubstEnv(finalState.subst, finalState.env)
  finalState
}

provide let inferProgramWithEnv = (program: CoreAst.Program, env: Types.Env) => {
  let state = { ...makeInitialState(), env }
  let finalState = inferTopItems(program.items, state)
  Types.applySubstEnv(finalState.subst, finalState.env)
  finalState
}
