module Infer

from "list" include List
from "map" include Map
from "runtime/unsafe/panic" include Panic

from "./core_ast.gr" include CoreAst
from "./types.gr" include Types
from "./env.gr" include Env
from "./constraints.gr" include Constraints
from "./solver.gr" include Solver

provide record MatchArmInfo {
  clauseId: Number,
  typeName: String,
  constructor: Env.ConstructorInfo,
}

provide record InferState {
  nextVar: Number,
  subst: Types.Subst,
  env: Env.TypingEnv,
  nodeTypes: Map.Map<Number, Types.Type>,
  topBindings: Map.Map<String, Types.Scheme>,
  constraints: List<Constraints.Constraint>,
  matchArms: Map.Map<Number, List<MatchArmInfo>>,
}

let makeInitialState = () => {
  let subst = Types.emptySubst()
  let env = Env.empty()
  let nodeTypes = Map.make()
  let topBindings = Map.make()
  {
    nextVar: 1,
    subst,
    env,
    nodeTypes,
    topBindings,
    constraints: [],
    matchArms: Map.make(),
  }
}

let recordConstraint = (state: InferState, constraint: Constraints.Constraint) =>
  { ...state, constraints: [constraint, ...state.constraints] }

let originForNode = (nodeId: Number, description: String) =>
  Constraints.makeOrigin(nodeId, description)

let panicWithOrigin = (message: String, origin: Constraints.Origin) =>
  Panic.panic(message ++ " (" ++ Constraints.originToString(origin) ++ ")")

let rec containsString = (values: List<String>, target: String) =>
  match (values) {
    [] => false,
    [head, ...tail] => if (head == target) {
      true
    } else {
      containsString(tail, target)
    },
  }

let rec dedupeStrings = (values: List<String>, acc: List<String>) =>
  match (values) {
    [] => List.reverse(acc),
    [head, ...tail] => if (containsString(acc, head)) {
      dedupeStrings(tail, acc)
    } else {
      dedupeStrings(tail, [head, ...acc])
    },
  }

let rec findConstructorInfo = (
  constructors: List<Env.ConstructorInfo>,
  target: String,
) => match (constructors) {
  [] => None,
  [ctor, ...rest] => if (ctor.name == target) {
    Some(ctor)
  } else {
    findConstructorInfo(rest, target)
  },
}

let recordMatchArms = (fnExpr: CoreAst.FnExpr, state: InferState) => {
  let rec gather = (
    items: List<CoreAst.FnItem>,
    acc: List<(Number, String, Option<String>)>,
    hasWildcard: Bool,
  ) => match (items) {
    [] => (acc, hasWildcard),
    [item, ...rest] => match (item.kind) {
      CoreAst.Clause(clause) => match (clause.matchConstructor) {
        Some(name) => {
          let owner: Option<String> = Env.lookupConstructorOwner(
            state.env,
            name.text
          )
          let newWildcard = hasWildcard || owner == None
          gather(
            rest,
            [(clause.node.id, name.text, owner), ...acc],
            newWildcard
          )
        },
        None => gather(rest, acc, true),
      },
      _ => gather(rest, acc, hasWildcard),
    },
  }

  let (seeds, hasWildcard) = gather(fnExpr.items, [], false)
  if (seeds == []) {
    state
  } else {
    let owners = dedupeStrings(
      List.filterMap((entry: (Number, String, Option<String>)) => {
        let (_, _, owner) = entry
        owner
      }, seeds),
      []
    )
    match (owners) {
      [] => state,
      [_only, ...more] when more != [] =>
        Panic.panic("Match clauses reference multiple nominal types"),
      [typeName] => match (Env.lookupConstructors(state.env, typeName)) {
        None => state,
        Some(expectedConstructors) => {
          let typedSeeds = List.filter(
            (entry: (Number, String, Option<String>)) => {
              let (_, _, owner) = entry
              match (owner) {
                Some(name) => name == typeName,
                None => false,
              }
            },
            seeds
          )
          if (typedSeeds == []) {
            state
          } else {
            let actualNames = dedupeStrings(
              List.map(
                (entry: (Number, String, Option<String>)) => {
                  let (_, ctorName, _) = entry
                  ctorName
                },
                typedSeeds
              ),
              []
            )
            let missing = if (hasWildcard) {
              []
            } else {
              List.filter(
                (ctor: Env.ConstructorInfo) =>
                  !containsString(actualNames, ctor.name),
                expectedConstructors
              )
            }
            if (missing != []) {
              Panic.panic("Match missing constructors for type " ++ typeName)
            }
            let armInfos = List.filterMap(
              (entry: (Number, String, Option<String>)) => {
                let (clauseId, ctorName, _) = entry
                match (findConstructorInfo(expectedConstructors, ctorName)) {
                  Some(info) => Some({ clauseId, typeName, constructor: info }),
                  None => None,
                }
              },
              typedSeeds
            )
            if (armInfos == []) {
              state
            } else {
              Map.set(fnExpr.node.id, armInfos, state.matchArms)
              { ...state, matchArms: state.matchArms }
            }
          }
        },
      },
    }
  }
}

let freshVar = (state: InferState) => {
  let id = state.nextVar
  (Types.TVar(id), { ...state, nextVar: id + 1 })
}

let apply = (state: InferState, t: Types.Type) =>
  Types.applySubstType(state.subst, t)

let occurs = (varId: Number, t: Types.Type, state: InferState) => {
  let fv = Types.freeVars(apply(state, t))
  Types.containsVar(fv, varId)
}

let bindVar = (
  varId: Number,
  t: Types.Type,
  state: InferState,
  origin: Constraints.Origin,
) => {
  let tApplied = apply(state, t)
  if (tApplied == Types.TVar(varId)) {
    state
  } else if (occurs(varId, tApplied, state)) {
    panicWithOrigin("Type error: occurs check failed", origin)
  } else {
    Map.set(varId, tApplied, state.subst)
    state
  }
}

let rec unify = (
  left: Types.Type,
  right: Types.Type,
  origin: Constraints.Origin,
  state: InferState,
) => {
  let constraint = Constraints.Equality(left, right, origin)
  let state1 = recordConstraint(state, constraint)
  let l = apply(state1, left)
  let r = apply(state1, right)

  match ((l, r)) {
    (Types.TNumber, Types.TNumber) => state1,
    (Types.TVoid, Types.TVoid) => state1,
    (Types.TVar(id), t) => bindVar(id, t, state1, origin),
    (t, Types.TVar(id)) => bindVar(id, t, state1, origin),
    (Types.TFun(a1, b1), Types.TFun(a2, b2)) => {
      let state2 = unify(a1, a2, origin, state1)
      unify(b1, b2, origin, state2)
    },
    _ => panicWithOrigin("Type error: cannot unify types", origin),
  }
}

let unifyForNode = (
  nodeId: Number,
  description: String,
  left: Types.Type,
  right: Types.Type,
  state: InferState,
) => unify(left, right, originForNode(nodeId, description), state)

let recordNodeType = (id: Number, t: Types.Type, state: InferState) => {
  let applied = apply(state, t)
  Map.set(id, applied, state.nodeTypes)
  applied
}

let instantiateTypeParams = (typeParams: List<String>, state: InferState) => {
  let paramMap: Map.Map<String, Types.Type> = Map.make()
  let rec loop = (params: List<String>, st: InferState, acc: List<Types.Type>) =>
    match (params) {
      [] => (List.reverse(acc), paramMap, st),
      [name, ...rest] => {
        let (tVar, st1) = freshVar(st)
        Map.set(name, tVar, paramMap)
        loop(rest, st1, [tVar, ...acc])
      },
    }
  loop(typeParams, state, [])
}

let rec typeExprToType = (
  typeExpr: CoreAst.TypeExpr,
  paramMap: Map.Map<String, Types.Type>,
) => {
  match (typeExpr.kind) {
    CoreAst.Var(name) => match (Map.get(name.text, paramMap)) {
      Some(t) => t,
      None => Types.TNominal(name.text, []),
    },
    CoreAst.Ref(name, args) =>
      Types.TNominal(
        name.text,
        List.map(arg => typeExprToType(arg, paramMap), args),
      ),
    CoreAst.Tuple(items) =>
      Types.TTuple(List.map(item => typeExprToType(item, paramMap), items)),
    CoreAst.UnitType => Types.TVoid,
    _ => Panic.panic("Unsupported constructor type expression"),
  }
}

let handleMatchApplication = (
  fnExpr: CoreAst.FnExpr,
  argType: Types.Type,
  state: InferState,
) => {
  match (Map.get(fnExpr.node.id, state.matchArms)) {
    Some(armInfos) => match (armInfos) {
      [] => state,
      [first, ..._] => {
        match (Env.lookupType(state.env, first.typeName)) {
          None => Panic.panic("Unknown nominal type " ++ first.typeName),
          Some(typeInfo) => {
            let (paramTypes, _paramMap, state1) = instantiateTypeParams(
              typeInfo.typeParams,
              state
            )
            let scrutineeType = Types.TNominal(typeInfo.name, paramTypes)
            unifyForNode(
              fnExpr.node.id,
              "match scrutinee",
              argType,
              scrutineeType,
              state1
            )
          },
        }
      },
    },
    None => state,
  }
}

let lookupEnv = (name: String, state: InferState) => {
  match (Env.lookupValue(state.env, name)) {
    Some(scheme) => {
      let (inst, nextVar) = Types.instantiate(scheme, state.nextVar)
      (Types.applySubstType(state.subst, inst), { ...state, nextVar })
    },
    None => Panic.panic("Type error: unknown identifier"),
  }
}

let withBinding = (
  name: String,
  scheme: Types.Scheme,
  state: InferState,
  fn: InferState => (Types.Type, InferState),
) => {
  let previous = Env.lookupValue(state.env, name)
  let envWithBinding = Env.defineValue(state.env, name, scheme)
  let (resultType, stateAfter) = fn(state)
  match (previous) {
    Some(prevScheme) => Env.defineValue(envWithBinding, name, prevScheme),
    None => Env.removeValue(state.env, name),
  }
  (resultType, stateAfter)
}

let rec inferExpr = (expr: CoreAst.Expr, state: InferState) => {
  match (expr.kind) {
    CoreAst.Mark(_, inner) => inferExpr(inner, state),
    CoreAst.Lit(CoreAst.Int(_value)) => {
      let t = recordNodeType(expr.node.id, Types.TNumber, state)
      (t, state)
    },
    CoreAst.Lit(_) => {
      let t = recordNodeType(expr.node.id, Types.TNumber, state)
      (t, state)
    },
    CoreAst.Ident(name) => {
      let (t, state1) = lookupEnv(name.text, state)
      let tRecorded = recordNodeType(expr.node.id, t, state1)
      (tRecorded, state1)
    },
    CoreAst.Hole(_) => {
      let (t, state1) = freshVar(state)
      let tRecorded = recordNodeType(expr.node.id, t, state1)
      (tRecorded, state1)
    },
    CoreAst.Fn(fnExpr) => {
      let stateWithMatch = recordMatchArms(fnExpr, state)
      let clause = match (fnExpr.items) {
        [item, ..._] => match (item.kind) {
          CoreAst.Clause(c) => c,
          _ => Panic.panic("Type error: function item is not a clause"),
        },
        _ => Panic.panic("Type error: empty function clauses"),
      }
      let paramName = match (clause.param.kind) {
        CoreAst.Var(name) => name.text,
        _ => "_",
      }
      let (paramType, state1) = freshVar(stateWithMatch)
      let monoScheme: Types.Scheme = { quantifiers: [], ty: paramType }
      let (fnType, stFn) = withBinding(paramName, monoScheme, state1, st => {
        let (tBody, stBody) = inferExpr(clause.body, st)
        (Types.TFun(paramType, tBody), stBody)
      })
      let tRecorded = recordNodeType(expr.node.id, fnType, stFn)
      (tRecorded, stFn)
    },
    CoreAst.Apply(callee, arg) => {
      let (tCallee, state1) = inferExpr(callee, state)
      let (tArg, state2) = inferExpr(arg, state1)
      let (tRes, state3) = freshVar(state2)
      let state4 = unifyForNode(
        expr.node.id,
        "function application",
        tCallee,
        Types.TFun(tArg, tRes),
        state3
      )
      let state5 = match (callee.kind) {
        CoreAst.Fn(fnExpr) => handleMatchApplication(fnExpr, tArg, state4),
        _ => state4,
      }
      let tApplied = apply(state5, tRes)
      let tRecorded = recordNodeType(expr.node.id, tApplied, state5)
      (tRecorded, state5)
    },
    CoreAst.Let(binding, body) => {
      let (tValue, state1) = inferExpr(binding.value, state)
      Env.applySubst(state1.env, state1.subst)
      let scheme = Types.generalize(
        Env.snapshotValues(state1.env),
        state1.subst,
        tValue
      )
      let bindingName = match (binding.name.kind) {
        CoreAst.Var(name) => name.text,
        _ => "_",
      }
      let (tBody, state2) = withBinding(
        bindingName,
        scheme,
        state1,
        st => inferExpr(body, st)
      )
      let tRecorded = recordNodeType(expr.node.id, tBody, state2)
      (tRecorded, state2)
    },
    CoreAst.If(cond, thenExpr, elseOpt) => {
      let (tCond, state1) = inferExpr(cond, state)
      let (tThen, state2) = inferExpr(thenExpr, state1)
      let (tElse, state3) = match (elseOpt) {
        None => (Types.TVoid, state2),
        Some(e) => inferExpr(e, state2),
      }
      let state4 = unifyForNode(
        expr.node.id,
        "if branches",
        tThen,
        tElse,
        state3
      )
      let t = recordNodeType(expr.node.id, tThen, state4)
      (t, state4)
    },
    CoreAst.Tuple(exprs) => {
      let (types, state1) = inferExprList(exprs, state)
      let t = recordNodeType(expr.node.id, Types.TNumber, state1)
      (t, state1)
    },
    _ => {
      let (t, state1) = freshVar(state)
      let tRecorded = recordNodeType(expr.node.id, t, state1)
      (tRecorded, state1)
    },
  }
}
and inferExprList = (exprs: List<CoreAst.Expr>, state: InferState) => {
  match (exprs) {
    [] => ([], state),
    [expr, ...rest] => {
      let (t, state1) = inferExpr(expr, state)
      let (restTypes, state2) = inferExprList(rest, state1)
      ([t, ...restTypes], state2)
    },
  }
}

let inferLetBinding = (binding: CoreAst.LetBinding, state: InferState) => {
  let (tValue, state1) = inferExpr(binding.value, state)
  Env.applySubst(state1.env, state1.subst)
  let scheme = Types.generalize(
    Env.snapshotValues(state1.env),
    state1.subst,
    tValue
  )
  let bindingName = match (binding.name.kind) {
    CoreAst.Var(name) => name.text,
    _ => "_",
  }
  Env.defineValue(state1.env, bindingName, scheme)
  Map.set(bindingName, scheme, state1.topBindings)
  state1
}

let registerTypeDecl = (decl: CoreAst.TypeDecl, state: InferState) => {
  let typeName = decl.name.text
  let typeParams = List.map((name: CoreAst.Name) => name.text, decl.typeParams)
  let infection = match (decl.infection) {
    Some(name) => Some(name.text),
    None => None,
  }
  let constructors = match (decl.body) {
    CoreAst.Alias(_) => [],
    CoreAst.Variant(ctors) =>
      List.map(
        (
          (ctorName, payload, annotation): (
            CoreAst.Name,
            Option<CoreAst.TypeExpr>,
            Option<CoreAst.Annotation>
          ),
        ) => {
          { name: ctorName.text, payload, annotation }: Env.ConstructorInfo
        },
        ctors
      ),
  }
  let info: Env.TypeInfo = {
    name: typeName,
    typeParams,
    constructors,
    infection,
  }
  let env = Env.registerType(state.env, info)
  { ...state, env }
}

let rec inferTopItems = (items: List<CoreAst.TopItem>, state: InferState) => {
  match (items) {
    [] => state,
    [item, ...rest] => {
      let state1 = match (item) {
        CoreAst.DeclGroup(dg) => {
          let rec inferDecls = (decls: List<CoreAst.Decl>, st: InferState) => {
            match (decls) {
              [] => st,
              [decl, ...restDecls] => {
                let st1 = match (decl) {
                  CoreAst.LetDecl(ld) => {
                    let rec inferBindings = (
                      bindings: List<CoreAst.LetBinding>,
                      s: InferState,
                    ) => {
                      match (bindings) {
                        [] => s,
                        [b, ...restBindings] =>
                          inferBindings(restBindings, inferLetBinding(b, s)),
                      }
                    }
                    inferBindings(ld.bindings, st)
                  },
                  CoreAst.TypeDecl(td) => registerTypeDecl(td, st),
                  _ => st,
                }
                inferDecls(restDecls, st1)
              },
            }
          }
          inferDecls(dg.decls, state)
        },
        _ => state,
      }
      inferTopItems(rest, state1)
    },
  }
}

let solveConstraints = (state: InferState) => {
  let solverState = List.reduce(
    (acc, constraint) => Solver.addConstraint(acc, constraint),
    Solver.withSubst(state.subst),
    List.reverse(state.constraints)
  )
  match (Solver.solve(solverState)) {
    Ok(result) => {
      Env.applySubst(state.env, result.subst)
      { ...state, subst: result.subst, constraints: result.domainConstraints }
    },
    Err(Solver.Occurs(origin)) =>
      panicWithOrigin("Type error: occurs check failed", origin),
    Err(Solver.CannotUnify(left, right, origin)) =>
      panicWithOrigin(
        "Type error: cannot unify "
          ++ Types.typeToString(left)
          ++ " with "
          ++ Types.typeToString(right),
        origin
      ),
  }
}

provide let inferProgram = (program: CoreAst.Program) => {
  let state = makeInitialState()
  let inferred = inferTopItems(program.items, state)
  solveConstraints(inferred)
}

provide let inferProgramWithEnv = (program: CoreAst.Program, env: Types.Env) => {
  let baseEnv = Env.empty()
  Map.forEach((name, scheme) => {
    Env.defineValue(baseEnv, name, scheme)
    void
  }, env)
  let state = { ...makeInitialState(), env: baseEnv }
  let inferred = inferTopItems(program.items, state)
  solveConstraints(inferred)
}
