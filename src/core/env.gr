module Env

from "list" include List
from "map" include Map

from "../module/module_system.gr" include ModuleSystem
from "./core_ast.gr" include CoreAst
from "./types.gr" include Types

provide record ModuleEntry {
  id: String,
  exports: Map.Map<String, Types.Scheme>,
}

provide record ConstructorInfo {
  name: String,
  payload: Option<CoreAst.TypeExpr>,
  annotation: Option<CoreAst.Annotation>,
}

provide record TypeInfo {
  name: String,
  typeParams: List<String>,
  constructors: List<ConstructorInfo>,
  infection: Option<String>,
}

provide record TypingEnv {
  values: Types.Env,
  modules: Map.Map<String, ModuleEntry>,
  moduleGraph: Option<ModuleSystem.ModuleGraph>,
  currentModule: Option<String>,
  types: Map.Map<String, TypeInfo>,
  constructorOwners: Map.Map<String, String>,
}

provide let empty = () => {
  let values = Types.emptyEnv()
  {
    values,
    modules: Map.make(),
    moduleGraph: None,
    currentModule: None,
    types: Map.make(),
    constructorOwners: Map.make(),
  }: TypingEnv
}

provide let setModuleGraph = (env: TypingEnv, graph: ModuleSystem.ModuleGraph) =>
  { ...env, moduleGraph: Some(graph) }

provide let clearModuleGraph = (env: TypingEnv) => { ...env, moduleGraph: None }

provide let setCurrentModule = (env: TypingEnv, moduleId: String) =>
  { ...env, currentModule: Some(moduleId) }

provide let clearCurrentModule = (env: TypingEnv) =>
  { ...env, currentModule: None }

provide let defineValue = (env: TypingEnv, name: String, scheme: Types.Scheme) => {
  Map.set(name, scheme, env.values)
  env
}

provide let removeValue = (env: TypingEnv, name: String) => {
  Map.remove(name, env.values)
  env
}

provide let lookupValue = (env: TypingEnv, name: String) =>
  Map.get(name, env.values)

provide let snapshotValues = (env: TypingEnv) => env.values

provide let applySubst = (env: TypingEnv, subst: Types.Subst) => {
  Types.applySubstEnv(subst, env.values)
  env
}

provide let registerType = (env: TypingEnv, typeInfo: TypeInfo) => {
  Map.set(typeInfo.name, typeInfo, env.types)
  List.forEach((ctor: ConstructorInfo) => {
    Map.set(ctor.name, typeInfo.name, env.constructorOwners)
  }, typeInfo.constructors)
  env
}

provide let lookupType = (env: TypingEnv, name: String) =>
  Map.get(name, env.types)

provide let lookupConstructors = (env: TypingEnv, typeName: String) =>
  match (Map.get(typeName, env.types)) {
    Some(info) => Some(info.constructors),
    None => None,
  }

provide let lookupConstructorOwner = (env: TypingEnv, ctorName: String) =>
  Map.get(ctorName, env.constructorOwners)

provide let registerModuleExports = (
  env: TypingEnv,
  moduleId: String,
  exports: Map.Map<String, Types.Scheme>,
) => {
  let entry: ModuleEntry = { id: moduleId, exports }
  Map.set(moduleId, entry, env.modules)
  env
}

provide let lookupModuleExport = (
  env: TypingEnv,
  moduleId: String,
  name: String,
) => match (Map.get(moduleId, env.modules)) {
  Some(entry) => Map.get(name, entry.exports),
  None => None,
}

provide let moduleGraph = (env: TypingEnv) => env.moduleGraph
provide let currentModuleId = (env: TypingEnv) => env.currentModule
