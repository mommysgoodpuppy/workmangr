module Env

from "map" include Map

from "../module/module_system.gr" include ModuleSystem
from "./types.gr" include Types

provide record ModuleEntry {
  id: String,
  exports: Map.Map<String, Types.Scheme>,
}

provide record TypingEnv {
  values: Types.Env,
  modules: Map.Map<String, ModuleEntry>,
  moduleGraph: Option<ModuleSystem.ModuleGraph>,
  currentModule: Option<String>,
}

provide let empty = () => {
  let values = Types.emptyEnv()
  {
    values,
    modules: Map.make(),
    moduleGraph: None,
    currentModule: None,
  }: TypingEnv
}

provide let setModuleGraph = (
  env: TypingEnv,
  graph: ModuleSystem.ModuleGraph,
) => ({ ...env, moduleGraph: Some(graph) })

provide let clearModuleGraph = (env: TypingEnv) => ({ ...env, moduleGraph: None })

provide let setCurrentModule = (
  env: TypingEnv,
  moduleId: String,
) => ({ ...env, currentModule: Some(moduleId) })

provide let clearCurrentModule = (env: TypingEnv) => ({ ...env, currentModule: None })

provide let defineValue = (
  env: TypingEnv,
  name: String,
  scheme: Types.Scheme,
) => {
  Map.set(name, scheme, env.values)
  env
}

provide let removeValue = (env: TypingEnv, name: String) => {
  Map.remove(name, env.values)
  env
}

provide let lookupValue = (env: TypingEnv, name: String) =>
  Map.get(name, env.values)

provide let snapshotValues = (env: TypingEnv) => env.values

provide let applySubst = (env: TypingEnv, subst: Types.Subst) => {
  Types.applySubstEnv(subst, env.values)
  env
}

provide let registerModuleExports = (
  env: TypingEnv,
  moduleId: String,
  exports: Map.Map<String, Types.Scheme>,
) => {
  let entry: ModuleEntry = { id: moduleId, exports }
  Map.set(moduleId, entry, env.modules)
  env
}

provide let lookupModuleExport = (
  env: TypingEnv,
  moduleId: String,
  name: String,
) =>
  match (Map.get(moduleId, env.modules)) {
    Some(entry) => Map.get(name, entry.exports),
    None => None,
  }

provide let moduleGraph = (env: TypingEnv) => env.moduleGraph
provide let currentModuleId = (env: TypingEnv) => env.currentModule
