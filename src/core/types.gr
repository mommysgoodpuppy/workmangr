module Types

from "list" include List
from "map" include Map
from "string" include String

let joinStrings = (sep: String, strs: List<String>) => match (strs) {
  [] => "",
  [x, ...xs] => List.reduce((acc, s) => acc ++ sep ++ s, x, xs),
}

provide enum rec Type {
  TNumber,
  TBool,
  TString,
  TByte,
  TChar,
  TVoid,
  THole(Number),
  TVar(Number),
  TFun(Type, Type),
  TTuple(List<Type>),
  TNominal(String, List<Type>),
}

provide record Scheme {
  quantifiers: List<Number>,
  ty: Type,
}

provide type Subst = Map.Map<Number, Type>
provide type Env = Map.Map<String, Scheme>

let emptySubst = () => Map.make()
let emptyEnv = () => Map.make()

provide let rec typeToString = (t: Type) => match (t) {
  TNumber => "Number",
  TBool => "Bool",
  TString => "String",
  TByte => "Byte",
  TChar => "Char",
  TVoid => "Void",
  THole(id) => "?[" ++ toString(id) ++ "]",
  TVar(id) => "'" ++ toString(id),
  TFun(a, b) => {
    let left = match (a) {
      TFun(_, _) => "(" ++ typeToString(a) ++ ")",
      _ => typeToString(a),
    }
    left ++ " -> " ++ typeToString(b)
  },
  TTuple(items) => {
    let parts = List.map(typeToString, items)
    "(" ++ joinStrings(", ", parts) ++ ")"
  },
  TNominal(name, args) => {
    if (args == []) {
      name
    } else {
      let rendered = List.map(typeToString, args)
      name ++ "<" ++ joinStrings(", ", rendered) ++ ">"
    }
  },
}

let containsVar = (vars: List<Number>, target: Number) => {
  let rec loop = (rest: List<Number>) => match (rest) {
    [] => false,
    [x, ...xs] => if (x == target) {
      true
    } else {
      loop(xs)
    },
  }
  loop(vars)
}

let dedupeVars = (vars: List<Number>) => {
  let rec loop = (input: List<Number>, acc: List<Number>) => match (input) {
    [] => acc,
    [x, ...xs] => if (containsVar(acc, x)) {
      loop(xs, acc)
    } else {
      loop(xs, [x, ...acc])
    },
  }
  List.reverse(loop(vars, []))
}

let rec freeVars = (t: Type) => match (t) {
  TNumber => [],
  TBool => [],
  TString => [],
  TByte => [],
  TChar => [],
  TVoid => [],
  THole(_) => [],
  TVar(id) => [id],
  TFun(a, b) => List.append(freeVars(a), freeVars(b)),
  TTuple(items) => List.flatten(List.map(freeVars, items)),
  TNominal(_, args) => List.flatten(List.map(freeVars, args)),
}

let freeVarsScheme = (scheme: Scheme) => {
  let fv = freeVars(scheme.ty)
  List.filter(id => !containsVar(scheme.quantifiers, id), fv)
}

let freeVarsEnv = (env: Env) => {
  let pairs = Map.toList(env)
  let gathered = List.reduce((acc, pair) => {
    let (_name, scheme) = pair
    List.append(acc, freeVarsScheme(scheme))
  }, [], pairs)
  dedupeVars(gathered)
}

let rec applySubstType = (subst: Subst, t: Type) => match (t) {
  TNumber => t,
  TBool => t,
  TString => t,
  TByte => t,
  TChar => t,
  TVoid => t,
  THole(_) => t,
  TFun(a, b) => TFun(applySubstType(subst, a), applySubstType(subst, b)),
  TVar(id) => match (Map.get(id, subst)) {
    Some(t2) => applySubstType(subst, t2),
    None => t,
  },
  TTuple(items) => TTuple(List.map(item => applySubstType(subst, item), items)),
  TNominal(name, args) =>
    TNominal(name, List.map(arg => applySubstType(subst, arg), args)),
}

let applySubstScheme = (subst: Subst, scheme: Scheme) => {
  // Do not substitute quantified variables.
  let filtered = Map.make()
  Map.forEach((key, value) => {
    if (!containsVar(scheme.quantifiers, key)) {
      Map.set(key, value, filtered)
    }
  }, subst)
  { ...scheme, ty: applySubstType(filtered, scheme.ty) }
}

let applySubstEnv = (subst: Subst, env: Env) =>
  Map.forEach(
    (name, scheme) => Map.set(name, applySubstScheme(subst, scheme), env),
    env
  )

let generalize = (env: Env, subst: Subst, t: Type) => {
  let tApplied = applySubstType(subst, t)
  let envVars = freeVarsEnv(env)
  let typeVars = dedupeVars(freeVars(tApplied))
  let quantifiers = List.filter(id => !containsVar(envVars, id), typeVars)
  { quantifiers, ty: tApplied }
}

let instantiate = (scheme: Scheme, nextVarStart: Number) => {
  let mapping: Map.Map<Number, Type> = Map.make()

  let nextVar = List.reduce((next, id) => {
    Map.set(id, TVar(next), mapping)
    next + 1
  }, nextVarStart, scheme.quantifiers)

  let rec replace = (t: Type) => match (t) {
    TNumber => t,
    TBool => t,
    TString => t,
    TByte => t,
    TChar => t,
    TVoid => t,
    THole(_) => t,
    TFun(a, b) => TFun(replace(a), replace(b)),
    TTuple(items) => TTuple(List.map(replace, items)),
    TNominal(name, args) => TNominal(name, List.map(replace, args)),
    TVar(id) => match (Map.get(id, mapping)) {
      Some(t2) => t2,
      None => t,
    },
  }

  (replace(scheme.ty), nextVar)
}

provide {
  emptySubst,
  emptyEnv,
  freeVars,
  applySubstType,
  applySubstScheme,
  applySubstEnv,
  instantiate,
  generalize,
  containsVar,
}
