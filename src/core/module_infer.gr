module ModuleInfer

from "list" include List
from "map" include Map

from "./analysis.gr" include Analysis
from "./core_ast.gr" include CoreAst
from "./env.gr" include Env
from "./error.gr" include Error
from "./infer.gr" include Infer
from "./source.gr" include Source
from "./types.gr" include Types
from "../frontend/lower.gr" include Lower
from "../module/module_system.gr" include ModuleSystem
from "./layer1/expr.gr" include Layer1Expr

provide record ModuleSummary {
  moduleId: String,
  program: CoreAst.Program,
  infer: Infer.InferState,
  valueExports: Types.Env,
  typeExports: Map.Map<String, Env.TypeInfo>,
  diagnostics: List<Error.CompilerError>,
}

provide record InferenceResult {
  graph: ModuleSystem.ModuleGraph,
  modules: Map.Map<String, ModuleSummary>,
  diagnosticsById: Map.Map<String, List<Error.CompilerError>>,
}

provide record TypeAtOffset {
  span: Source.Span,
  ty: Types.Type,
}

let spanContainsOffset = (span: Source.Span, offset: Number) => {
  if (span.end <= span.start) {
    offset == span.start
  } else {
    offset >= span.start && offset < span.end
  }
}

let spanLength = (span: Source.Span) => span.end - span.start

provide let typeAtOffsetInSummary = (summary: ModuleSummary, offset: Number) => {
  let nodeSpans = Analysis.buildNodeSpans(summary.program)
  let rec choose = (
    entries: List<(Number, Types.Type)>,
    best: Option<TypeAtOffset>,
  ) =>
    match (entries) {
      [] => best,
      [(nodeId, inferredType), ...rest] =>
        match (Map.get(nodeId, nodeSpans)) {
          Some(span) when spanContainsOffset(span, offset) => {
            let appliedType = Types.applySubstType(summary.infer.subst, inferredType)
            let candidate: TypeAtOffset = { span, ty: appliedType }
            let nextBest = match (best) {
              None => Some(candidate),
              Some(prev) =>
                if (spanLength(candidate.span) <= spanLength(prev.span)) {
                  Some(candidate)
                } else {
                  best
                },
            }
            choose(rest, nextBest)
          },
          _ => choose(rest, best),
        },
    }

  choose(Map.toList(summary.infer.nodeTypes), None)
}

let typeDiagnosticsForProgram = (
  program: CoreAst.Program,
  infer: Infer.InferState,
) => {
  let nodeSpans = Analysis.buildNodeSpans(program)
  Analysis.typeInferenceDiagnostics(infer.marks, nodeSpans)
}

let collectImportedEnv = (
  node: ModuleSystem.ModuleNode,
  lowered: CoreAst.Program,
  summaries: Map.Map<String, ModuleSummary>,
) => {
  let env = Map.make()
  let importDecls = List.filterMap((item: CoreAst.TopItem) =>
    match (item) {
      CoreAst.Import(importDecl) => Some(importDecl),
      _ => None,
    }, lowered.items)
  let rec loop = (
    remainingImports: List<CoreAst.ImportDecl>,
    remainingPaths: List<String>,
  ) => {
    match ((remainingImports, remainingPaths)) {
      ([], []) => void,
      ([], [providerPath, ...pathRest]) => {
        match (Map.get(providerPath, summaries)) {
          Some(summary) =>
            List.forEach(((name, scheme)) => {
              Map.set(name, scheme, env)
            }, Map.toList(summary.valueExports)),
          None => void,
        }
        loop([], pathRest)
      },
      (_, []) => void,
      ([importDecl, ...importRest], [providerPath, ...pathRest]) => {
        match (Map.get(providerPath, summaries)) {
          Some(summary) => {
            if (importDecl.names != []) {
              List.forEach((item: CoreAst.ImportName) => {
                let exportedName = item.name.text
                let localName = match (item.alias) {
                  Some(aliasName) => aliasName.text,
                  None => exportedName,
                }
                match (Map.get(exportedName, summary.valueExports)) {
                  Some(scheme) => Map.set(localName, scheme, env),
                  None => void,
                }
              }, importDecl.names)
            } else {
              match (importDecl.alias) {
                Some(alias) =>
                  List.forEach(((name, scheme)) => {
                    let qualified = alias.text ++ "." ++ name
                    Map.set(qualified, scheme, env)
                  }, Map.toList(summary.valueExports)),
                None =>
                  List.forEach(((name, scheme)) => {
                    Map.set(name, scheme, env)
                  }, Map.toList(summary.valueExports)),
              }
            }
          },
          None => void,
        }
        loop(importRest, pathRest)
      },
    }
  }
  loop(importDecls, node.imports)
  env
}

let collectExplicitExports = (program: CoreAst.Program) => {
  let exportedValues: Map.Map<String, Bool> = Map.make()
  let exportedTypes: Map.Map<String, Bool> = Map.make()
  List.forEach((item: CoreAst.TopItem) => {
    match (item) {
      CoreAst.DeclGroup(group) when group.exported =>
        List.forEach((decl: CoreAst.Decl) => {
          match (decl) {
            CoreAst.LetDecl(letDecl) =>
              List.forEach((binding: CoreAst.LetBinding) => {
                let name = Layer1Expr.bindingName(binding)
                if (name != "_") {
                  Map.set(name, true, exportedValues)
                } else {
                  void
                }
              }, letDecl.bindings),
            CoreAst.TypeDecl(typeDecl) => Map.set(typeDecl.name.text, true, exportedTypes),
            CoreAst.RecordDecl(recordDecl) =>
              Map.set(recordDecl.name.text, true, exportedTypes),
            _ => void,
          }
        }, group.decls),
      _ => void,
    }
  }, program.items)
  (exportedValues, exportedTypes)
}

let buildOwnExports = (
  lowered: CoreAst.Program,
  infer: Infer.InferState,
) => {
  let values = Map.make()
  let types = Map.make()
  let allValues = Env.snapshotValues(infer.env)
  let (explicitValueNames, explicitTypeNames) = collectExplicitExports(lowered)
  let hasExplicit =
    List.length(Map.toList(explicitValueNames)) > 0
      || List.length(Map.toList(explicitTypeNames)) > 0

  if (hasExplicit) {
    List.forEach((name: String) => {
      match (Map.get(name, allValues)) {
        Some(scheme) => Map.set(name, scheme, values),
        None => void,
      }
    }, List.map(((name, _)) => name, Map.toList(explicitValueNames)))

    List.forEach((typeName: String) => {
      match (Env.lookupType(infer.env, typeName)) {
        Some(typeInfo) => {
          Map.set(typeName, typeInfo, types)
          List.forEach((ctor: Env.ConstructorInfo) => {
            match (Map.get(ctor.name, allValues)) {
              Some(scheme) => Map.set(ctor.name, scheme, values),
              None => void,
            }
          }, typeInfo.constructors)
        },
        None => void,
      }
    }, List.map(((name, _)) => name, Map.toList(explicitTypeNames)))
  } else {
    List.forEach(((name, scheme)) => {
      Map.set(name, scheme, values)
    }, Map.toList(infer.topBindings))
  }

  (values, types)
}

let applyReexports = (
  node: ModuleSystem.ModuleNode,
  summaries: Map.Map<String, ModuleSummary>,
  values: Types.Env,
  types: Map.Map<String, Env.TypeInfo>,
) => {
  List.forEach((providerPath: String) => {
    match (Map.get(providerPath, summaries)) {
      Some(provider) => {
        List.forEach(((name, scheme)) => {
          Map.set(name, scheme, values)
        }, Map.toList(provider.valueExports))
        List.forEach(((name, info)) => {
          Map.set(name, info, types)
        }, Map.toList(provider.typeExports))
      },
      None => void,
    }
  }, node.reexports)
}

provide let inferGraph = (graph: ModuleSystem.ModuleGraph) => {
  let summaries: Map.Map<String, ModuleSummary> = Map.make()
  let diagnosticsById = Map.make()

  List.forEach((moduleId: String) => {
    match (Map.get(moduleId, graph.nodes)) {
      None => void,
      Some(node) => {
        let lowered = Lower.lowerProgram(node.program)
        let importedEnv = collectImportedEnv(node, lowered, summaries)
        let infer = Infer.inferProgramWithEnv(lowered, importedEnv)
        let typeDiagnostics = typeDiagnosticsForProgram(lowered, infer)
        let parseDiagnostics = match (Map.get(moduleId, graph.diagnosticsById)) {
          Some(diags) => diags,
          None => [],
        }
        let combined = List.append(parseDiagnostics, typeDiagnostics)
        Map.set(moduleId, combined, diagnosticsById)

        let (ownValues, ownTypes) = buildOwnExports(lowered, infer)
        applyReexports(node, summaries, ownValues, ownTypes)
        let summary: ModuleSummary = {
          moduleId,
          program: lowered,
          infer,
          valueExports: ownValues,
          typeExports: ownTypes,
          diagnostics: combined,
        }
        Map.set(moduleId, summary, summaries)
      },
    }
  }, graph.topo)

  { graph, modules: summaries, diagnosticsById }: InferenceResult
}

provide let inferEntry = (
  entryPath: String,
  options: ModuleSystem.BuildOptions=ModuleSystem.defaultOptions(),
) => {
  let graph = ModuleSystem.buildGraph(entryPath, options=options)
  inferGraph(graph)
}
