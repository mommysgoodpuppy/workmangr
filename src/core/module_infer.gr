module ModuleInfer

from "list" include List
from "map" include Map
from "array" include Array

from "./analysis.gr" include Analysis
from "./core_ast.gr" include CoreAst
from "./env.gr" include Env
from "./error.gr" include Error
from "./infer.gr" include Infer
from "./source.gr" include Source
from "./types.gr" include Types
from "../frontend/lower.gr" include Lower
from "../module/module_system.gr" include ModuleSystem
from "./layer1/expr.gr" include Layer1Expr

provide record TypeAtOffset {
  span: Source.Span,
  ty: Types.Type,
}

provide record ModuleSummary {
  moduleId: String,
  program: CoreAst.Program,
  infer: Infer.InferState,
  typeEntries: List<TypeAtOffset>,
  valueExports: Types.Env,
  typeExports: Map.Map<String, Env.TypeInfo>,
  diagnostics: List<Error.CompilerError>,
}

provide record InferenceResult {
  graph: ModuleSystem.ModuleGraph,
  modules: Map.Map<String, ModuleSummary>,
  diagnosticsById: Map.Map<String, List<Error.CompilerError>>,
}

provide record SummaryCacheEntry {
  node: ModuleSystem.ModuleNode,
  dependencySignature: String,
  exportSignature: String,
  summary: ModuleSummary,
}

provide type SummaryCache = Map.Map<String, SummaryCacheEntry>

provide let emptySummaryCache = () => {
  let cache: SummaryCache = Map.make()
  cache
}

let spanContainsOffset = (span: Source.Span, offset: Number) => {
  if (span.end <= span.start) {
    offset == span.start
  } else {
    offset >= span.start && offset < span.end
  }
}

let spanLength = (span: Source.Span) => span.end - span.start

let buildTypeEntries = (
  program: CoreAst.Program,
  infer: Infer.InferState,
) => {
  let nodeSpans = Analysis.buildNodeSpans(program)
  let raw = List.filterMap(((nodeId, inferredType): (Number, Types.Type)) =>
    match (Map.get(nodeId, nodeSpans)) {
      Some(span) => {
        let appliedType = Types.applySubstType(infer.subst, inferredType)
        Some({ span, ty: appliedType }: TypeAtOffset)
      },
      None => None,
    }, Map.toList(infer.nodeTypes))
  List.sort(
    compare=((a, b) => {
      let lenA = spanLength(a.span)
      let lenB = spanLength(b.span)
      if (lenA == lenB) {
        a.span.start - b.span.start
      } else {
        lenA - lenB
      }
    }),
    raw,
  )
}

provide let typeAtOffsetInSummary = (summary: ModuleSummary, offset: Number) => {
  let rec choose = (entries: List<TypeAtOffset>) =>
    match (entries) {
      [] => None,
      [entry, ...rest] =>
        if (spanContainsOffset(entry.span, offset)) {
          Some(entry)
        } else {
          choose(rest)
        },
    }

  choose(summary.typeEntries)
}

let typeDiagnosticsForProgram = (
  program: CoreAst.Program,
  infer: Infer.InferState,
) => {
  let nodeSpans = Analysis.buildNodeSpans(program)
  Analysis.typeInferenceDiagnostics(infer.marks, nodeSpans)
}

let collectImportedEnv = (
  node: ModuleSystem.ModuleNode,
  lowered: CoreAst.Program,
  summaries: Map.Map<String, ModuleSummary>,
) => {
  let env = Map.make()
  let importDecls = List.filterMap((item: CoreAst.TopItem) =>
    match (item) {
      CoreAst.Import(importDecl) => Some(importDecl),
      _ => None,
    }, lowered.items)
  let rec loop = (
    remainingImports: List<CoreAst.ImportDecl>,
    remainingPaths: List<String>,
  ) => {
    match ((remainingImports, remainingPaths)) {
      ([], []) => void,
      ([], [providerPath, ...pathRest]) => {
        match (Map.get(providerPath, summaries)) {
          Some(summary) =>
            List.forEach(((name, scheme)) => {
              Map.set(name, scheme, env)
            }, Map.toList(summary.valueExports)),
          None => void,
        }
        loop([], pathRest)
      },
      (_, []) => void,
      ([importDecl, ...importRest], [providerPath, ...pathRest]) => {
        match (Map.get(providerPath, summaries)) {
          Some(summary) => {
            if (importDecl.names != []) {
              List.forEach((item: CoreAst.ImportName) => {
                let exportedName = item.name.text
                let localName = match (item.alias) {
                  Some(aliasName) => aliasName.text,
                  None => exportedName,
                }
                match (Map.get(exportedName, summary.valueExports)) {
                  Some(scheme) => Map.set(localName, scheme, env),
                  None => void,
                }
              }, importDecl.names)
            } else {
              match (importDecl.alias) {
                Some(alias) =>
                  List.forEach(((name, scheme)) => {
                    let qualified = alias.text ++ "." ++ name
                    Map.set(qualified, scheme, env)
                  }, Map.toList(summary.valueExports)),
                None =>
                  List.forEach(((name, scheme)) => {
                    Map.set(name, scheme, env)
                  }, Map.toList(summary.valueExports)),
              }
            }
          },
          None => void,
        }
        loop(importRest, pathRest)
      },
    }
  }
  loop(importDecls, node.imports)
  env
}

let collectExplicitExports = (program: CoreAst.Program) => {
  let exportedValues: Map.Map<String, Bool> = Map.make()
  let exportedTypes: Map.Map<String, Bool> = Map.make()
  List.forEach((item: CoreAst.TopItem) => {
    match (item) {
      CoreAst.DeclGroup(group) when group.exported =>
        List.forEach((decl: CoreAst.Decl) => {
          match (decl) {
            CoreAst.LetDecl(letDecl) =>
              List.forEach((binding: CoreAst.LetBinding) => {
                let name = Layer1Expr.bindingName(binding)
                if (name != "_") {
                  Map.set(name, true, exportedValues)
                } else {
                  void
                }
              }, letDecl.bindings),
            CoreAst.TypeDecl(typeDecl) => Map.set(typeDecl.name.text, true, exportedTypes),
            CoreAst.RecordDecl(recordDecl) =>
              Map.set(recordDecl.name.text, true, exportedTypes),
            _ => void,
          }
        }, group.decls),
      _ => void,
    }
  }, program.items)
  (exportedValues, exportedTypes)
}

let buildOwnExports = (
  lowered: CoreAst.Program,
  infer: Infer.InferState,
) => {
  let values = Map.make()
  let types = Map.make()
  let allValues = Env.snapshotValues(infer.env)
  let (explicitValueNames, explicitTypeNames) = collectExplicitExports(lowered)
  let hasExplicit =
    List.length(Map.toList(explicitValueNames)) > 0
      || List.length(Map.toList(explicitTypeNames)) > 0

  if (hasExplicit) {
    List.forEach((name: String) => {
      match (Map.get(name, allValues)) {
        Some(scheme) => Map.set(name, scheme, values),
        None => void,
      }
    }, List.map(((name, _)) => name, Map.toList(explicitValueNames)))

    List.forEach((typeName: String) => {
      match (Env.lookupType(infer.env, typeName)) {
        Some(typeInfo) => {
          Map.set(typeName, typeInfo, types)
          List.forEach((ctor: Env.ConstructorInfo) => {
            match (Map.get(ctor.name, allValues)) {
              Some(scheme) => Map.set(ctor.name, scheme, values),
              None => void,
            }
          }, typeInfo.constructors)
        },
        None => void,
      }
    }, List.map(((name, _)) => name, Map.toList(explicitTypeNames)))
  } else {
    List.forEach(((name, scheme)) => {
      Map.set(name, scheme, values)
    }, Map.toList(infer.topBindings))
  }

  (values, types)
}

let applyReexports = (
  node: ModuleSystem.ModuleNode,
  summaries: Map.Map<String, ModuleSummary>,
  values: Types.Env,
  types: Map.Map<String, Env.TypeInfo>,
) => {
  List.forEach((providerPath: String) => {
    match (Map.get(providerPath, summaries)) {
      Some(provider) => {
        List.forEach(((name, scheme)) => {
          Map.set(name, scheme, values)
        }, Map.toList(provider.valueExports))
        List.forEach(((name, info)) => {
          Map.set(name, info, types)
        }, Map.toList(provider.typeExports))
      },
      None => void,
    }
  }, node.reexports)
}

let schemeSignature = (scheme: Types.Scheme) => {
  let qs = Array.join(",", Array.fromList(List.map(toString, scheme.quantifiers)))
  qs ++ "|" ++ Types.typeToString(scheme.ty)
}

let typeInfoSignature = (info: Env.TypeInfo) => {
  let typeParams = Array.join(",", Array.fromList(info.typeParams))
  let ctors = Array.join(
    ",",
    Array.fromList(List.map((ctor: Env.ConstructorInfo) => ctor.name, info.constructors))
  )
  info.name ++ "<" ++ typeParams ++ ">[" ++ ctors ++ "]"
}

let exportSignature = (summary: ModuleSummary) => {
  let values = Array.join(
    ";",
    Array.fromList(
      List.map(
        ((name, scheme)) => name ++ "=" ++ schemeSignature(scheme),
        Map.toList(summary.valueExports)
      )
    )
  )
  let types = Array.join(
    ";",
    Array.fromList(
      List.map(
        ((name, info)) => name ++ "=" ++ typeInfoSignature(info),
        Map.toList(summary.typeExports)
      )
    )
  )
  "v{" ++ values ++ "}t{" ++ types ++ "}"
}

let dependencySignature = (
  node: ModuleSystem.ModuleNode,
  nextCache: SummaryCache,
) => {
  let depList = List.append(node.imports, node.reexports)
  let parts = List.map((depId: String) =>
    match (Map.get(depId, nextCache)) {
      Some(dep) => depId ++ "#" ++ dep.exportSignature,
      None => depId ++ "#missing",
    }, depList)
  Array.join("|", Array.fromList(parts))
}

provide let inferGraphWithCache = (
  graph: ModuleSystem.ModuleGraph,
  previousCache: SummaryCache,
) => {
  let summaries: Map.Map<String, ModuleSummary> = Map.make()
  let diagnosticsById = Map.make()
  let nextCache: SummaryCache = Map.make()
  let mut reused = 0
  let mut recomputed = 0

  List.forEach((moduleId: String) => {
    match (Map.get(moduleId, graph.nodes)) {
      None => void,
      Some(node) => {
        let depSig = dependencySignature(node, nextCache)
        let reusedSummary = match (Map.get(moduleId, previousCache)) {
          Some(prev) when prev.node == node && prev.dependencySignature == depSig =>
            Some(prev.summary),
          _ => None,
        }
        match (reusedSummary) {
          Some(summary) => {
            reused += 1
            Map.set(moduleId, summary, summaries)
            Map.set(moduleId, summary.diagnostics, diagnosticsById)
            let sig = exportSignature(summary)
            let cacheEntry: SummaryCacheEntry = {
              node,
              dependencySignature: depSig,
              exportSignature: sig,
              summary,
            }
            Map.set(moduleId, cacheEntry, nextCache)
          },
          None => {
            recomputed += 1
            let lowered = Lower.lowerProgram(node.program)
            let importedEnv = collectImportedEnv(node, lowered, summaries)
            let infer = Infer.inferProgramWithEnv(lowered, importedEnv)
            let typeEntries = buildTypeEntries(lowered, infer)
            let typeDiagnostics = typeDiagnosticsForProgram(lowered, infer)
            let parseDiagnostics = match (Map.get(moduleId, graph.diagnosticsById)) {
              Some(diags) => diags,
              None => [],
            }
            let combined = List.append(parseDiagnostics, typeDiagnostics)
            Map.set(moduleId, combined, diagnosticsById)

            let (ownValues, ownTypes) = buildOwnExports(lowered, infer)
            applyReexports(node, summaries, ownValues, ownTypes)
            let summary: ModuleSummary = {
              moduleId,
              program: lowered,
              infer,
              typeEntries,
              valueExports: ownValues,
              typeExports: ownTypes,
              diagnostics: combined,
            }
            Map.set(moduleId, summary, summaries)
            let sig = exportSignature(summary)
            let cacheEntry: SummaryCacheEntry = {
              node,
              dependencySignature: depSig,
              exportSignature: sig,
              summary,
            }
            Map.set(moduleId, cacheEntry, nextCache)
          },
        }
      },
    }
  }, graph.topo)

  ({ graph, modules: summaries, diagnosticsById }: InferenceResult, nextCache, reused, recomputed)
}

provide let inferGraph = (graph: ModuleSystem.ModuleGraph) => {
  let (result, _cache, _reused, _recomputed) = inferGraphWithCache(
    graph,
    emptySummaryCache()
  )
  result
}

provide let inferEntry = (
  entryPath: String,
  options: ModuleSystem.BuildOptions=ModuleSystem.defaultOptions(),
) => {
  let graph = ModuleSystem.buildGraph(entryPath, options=options)
  inferGraph(graph)
}
