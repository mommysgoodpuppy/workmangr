module Serialize

from "list" include List
from "map" include Map
from "string" include String
from "array" include Array

from "../core/surface_ast.gr" include SurfaceAst
from "../core/analysis.gr" include Analysis
from "../core/types.gr" include Types
from "../core/source.gr" include Source

let escapeJson = (s: String) => {
  let rec escape = (chars: List<Char>, acc: String) => {
    match (chars) {
      [] => acc,
      [c, ...rest] => {
        let escaped = if (c == '"') {
          "\\\""
        } else if (c == '\\') {
          "\\\\"
        } else if (c == '\n') {
          "\\n"
        } else if (c == '\r') {
          "\\r"
        } else if (c == '\t') {
          "\\t"
        } else {
          String.concat([String.fromChar(c)])
        }
        escape(rest, acc ++ escaped)
      }
    }
  }
  escape(String.explode(s), "")
}

let spanToJson = (span: Source.Span) => {
  "{\"line\":" ++ toString(span.line) ++ 
  ",\"col\":" ++ toString(span.col) ++ 
  ",\"start\":" ++ toString(span.start) ++ 
  ",\"end\":" ++ toString(span.end) ++ "}"
}

let nodeToJson = (node: SurfaceAst.Node) => {
  "{\"id\":" ++ toString(node.id) ++ 
  ",\"span\":" ++ spanToJson(node.span) ++ "}"
}

let expectedTopItemKindToString = (kind: SurfaceAst.ExpectedTopItemKind) => {
  match (kind) {
    SurfaceAst.TopItemAny => "AnyTopItem",
    SurfaceAst.TopItemDeclGroup => "DeclGroup",
    SurfaceAst.TopItemImport => "Import",
    SurfaceAst.TopItemReexport => "Reexport",
    SurfaceAst.TopItemExport => "Export",
    SurfaceAst.TopItemDirective => "Directive",
    SurfaceAst.TopItemTrivia => "Trivia",
    SurfaceAst.TopItemMark => "Mark",
  }
}

let expectedKindToString = (kind: SurfaceAst.ExpectedKind) => {
  match (kind) {
    SurfaceAst.ExpectTopItem(tk) => "TopItem(" ++ expectedTopItemKindToString(tk) ++ ")",
    SurfaceAst.ExpectExpr => "Expr",
    SurfaceAst.ExpectPattern => "Pattern",
    SurfaceAst.ExpectTypeExpr => "TypeExpr",
    SurfaceAst.ExpectToken => "Token",
    SurfaceAst.ExpectBlock => "Block",
  }
}

let rec exprKindToString = (kind: SurfaceAst.ExprKind) => {
  match (kind) {
    SurfaceAst.Lit(SurfaceAst.Int(n)) => "Lit(Int(" ++ toString(n) ++ "))",
    SurfaceAst.Lit(SurfaceAst.Bool(b)) => "Lit(Bool(" ++ toString(b) ++ "))",
    SurfaceAst.Lit(SurfaceAst.Str(s)) => "Lit(Str(\"" ++ escapeJson(s) ++ "\"))",
    SurfaceAst.Lit(SurfaceAst.Char(c)) => "Lit(Char('" ++ String.fromChar(c) ++ "'))",
    SurfaceAst.Lit(SurfaceAst.Unit) => "Lit(Unit)",
    SurfaceAst.Ident(name) => "Ident(" ++ name.text ++ ")",
    SurfaceAst.Fn(_) => "Fn",
    SurfaceAst.Match(_) => "Match",
    SurfaceAst.Apply(_, _) => "Apply",
    SurfaceAst.InfixChain(_) => "InfixChain",
    SurfaceAst.Postfix(_) => "Postfix",
    SurfaceAst.Block(_) => "Block",
    SurfaceAst.Paren(_) => "Paren",
    SurfaceAst.Tuple(_) => "Tuple",
    SurfaceAst.RecordLit(_) => "RecordLit",
    SurfaceAst.Seq(_) => "Seq",
    SurfaceAst.Hole(_) => "Hole",
    SurfaceAst.If(_, _, _) => "If",
    SurfaceAst.Let(_, _) => "Let",
    SurfaceAst.Assign(_) => "Assign",
    _ => "Unknown"
  }
}

let rec exprToJson = (expr: SurfaceAst.Expr, depth: Number) => {
  if (depth > 10) {
    "{\"kind\":\"MaxDepth\"}"
  } else {
    let kindStr = exprKindToString(expr.kind)
    let childrenJson = match (expr.kind) {
      SurfaceAst.Block(block) => {
        let bodyJson = exprToJson(block.body, depth + 1)
        ",\"children\":[" ++ bodyJson ++ "]"
      },
      SurfaceAst.Fn(fnExpr) => {
        let clauseBodies = List.filterMap(
          (item: SurfaceAst.FnItem) =>
            match (item.kind) {
              SurfaceAst.Clause(clause) => Some(
                exprToJson(
                  { node: clause.body.node, kind: SurfaceAst.Block(clause.body), attach: clause.attach },
                  depth + 1,
                ),
              ),
              _ => None,
            },
          fnExpr.items
        )
        ",\"children\":[" ++ String.join(",", clauseBodies) ++ "]"
      },
      SurfaceAst.Match(m) => {
        let scrutineeJson = match (m.scrutinee) {
          None => [],
          Some(s) => [exprToJson(s, depth + 1)],
        }
        let clauseBodies = List.filterMap(
          (item: SurfaceAst.FnItem) =>
            match (item.kind) {
              SurfaceAst.Clause(clause) => Some(
                exprToJson(
                  { node: clause.body.node, kind: SurfaceAst.Block(clause.body), attach: clause.attach },
                  depth + 1,
                ),
              ),
              _ => None,
            },
          m.bundle.items
        )
        let allChildren = List.append(scrutineeJson, clauseBodies)
        ",\"children\":[" ++ String.join(",", allChildren) ++ "]"
      },
      SurfaceAst.Apply(callee, arg) => {
        let calleeJson = exprToJson(callee, depth + 1)
        let argJson = exprToJson(arg, depth + 1)
        ",\"children\":[" ++ calleeJson ++ "," ++ argJson ++ "]"
      },
      SurfaceAst.Let(binding, body) => {
        let valueJson = exprToJson(binding.value, depth + 1)
        let bodyJson = exprToJson(body, depth + 1)
        ",\"children\":[" ++ valueJson ++ "," ++ bodyJson ++ "]"
      },
      SurfaceAst.Assign(asg) => {
        let targetJson = exprToJson(asg.target, depth + 1)
        let valueJson = exprToJson(asg.value, depth + 1)
        ",\"children\":[" ++ targetJson ++ "," ++ valueJson ++ "]"
      },
      SurfaceAst.Paren(inner) => ",\"children\":[" ++ exprToJson(inner, depth + 1) ++ "]",
      SurfaceAst.Tuple(exprs) => {
        let items = List.map((e) => exprToJson(e, depth + 1), exprs)
        ",\"children\":[" ++ String.join(",", items) ++ "]"
      },
      SurfaceAst.Seq(exprs) => {
        let items = List.map((e) => exprToJson(e, depth + 1), exprs)
        ",\"children\":[" ++ String.join(",", items) ++ "]"
      },
      SurfaceAst.If(cond, thenE, elseE) => {
        let condJson = exprToJson(cond, depth + 1)
        let thenJson = exprToJson(thenE, depth + 1)
        let elseJson = match (elseE) {
          Some(e) => exprToJson(e, depth + 1),
          None => "null"
        }
        ",\"children\":[" ++ condJson ++ "," ++ thenJson ++ "," ++ elseJson ++ "]"
      },
      _ => ""
    }
    "{\"node\":" ++ nodeToJson(expr.node) ++ 
    ",\"kind\":\"" ++ kindStr ++ "\"" ++ childrenJson ++ "}"
  }
}

let topItemToJson = (item: SurfaceAst.TopItem) => {
  match (item) {
    SurfaceAst.DeclGroup(dg) => {
      let exported = if (dg.exported) { "true" } else { "false" }
      let kindStr = match (dg.kind) {
        SurfaceAst.LetGroup(_) => "LetGroup",
        SurfaceAst.TypeGroup(_) => "TypeGroup",
        SurfaceAst.RecordGroup(_) => "RecordGroup",
        SurfaceAst.OpGroup => "OpGroup",
        SurfaceAst.RuleGroup(_) => "RuleGroup"
      }
      "{\"type\":\"DeclGroup\",\"exported\":" ++ exported ++ 
      ",\"kind\":\"" ++ kindStr ++ "\"}"
    },
    SurfaceAst.Import(_) => "{\"type\":\"Import\"}",
    SurfaceAst.Reexport(_) => "{\"type\":\"Reexport\"}",
    SurfaceAst.Export(_) => "{\"type\":\"Export\"}",
    SurfaceAst.Directive(_) => "{\"type\":\"Directive\"}",
    SurfaceAst.Mark(mark) =>
      match (mark.kind) {
        SurfaceAst.UnknownTopLevel(text) =>
          "{\"type\":\"Mark\",\"kind\":\"UnknownTopLevel\",\"text\":\""
          ++ escapeJson(text) ++ "\",\"expected\":\""
          ++ expectedKindToString(Mark.expected) ++ "\"}",
        SurfaceAst.InvalidTopLevel(text) =>
          "{\"type\":\"Mark\",\"kind\":\"InvalidTopLevel\",\"text\":\""
          ++ escapeJson(text) ++ "\",\"expected\":\""
          ++ expectedKindToString(Mark.expected) ++ "\"}",
        SurfaceAst.MissingSemicolon =>
          "{\"type\":\"Mark\",\"kind\":\"MissingSemicolon\",\"expected\":\""
          ++ expectedKindToString(Mark.expected) ++ "\"}",
        SurfaceAst.MissingRBrace =>
          "{\"type\":\"Mark\",\"kind\":\"MissingRBrace\",\"expected\":\""
          ++ expectedKindToString(Mark.expected) ++ "\"}",
      },
    SurfaceAst.Trivia(_) => "{\"type\":\"Trivia\"}"
  }
}

let programToJson = (program: SurfaceAst.Program) => {
  let coreStr = if (program.core) { "true" } else { "false" }
  let items = List.map(topItemToJson, program.items)
  let itemsJson = "[" ++ String.join(",", items) ++ "]"
  "{\"core\":" ++ coreStr ++ ",\"items\":" ++ itemsJson ++ "}"
}

let typeToJson = (ty: Types.Type) => {
  let typeStr = Types.typeToString(ty)
  "\"" ++ escapeJson(typeStr) ++ "\""
}

let nodeTypesToJson = (nodeTypes: Map.Map<Number, Types.Type>) => {
  let pairs = Map.toList(nodeTypes)
  let items = List.map(
    ((id, ty)) => {
      "{\"id\":" ++ toString(id) ++ ",\"type\":" ++ typeToJson(ty) ++ "}"
    },
    pairs
  )
  "[" ++ String.join(",", items) ++ "]"
}

let topBindingsToJson = (bindings: Map.Map<String, Types.Scheme>) => {
  let pairs = Map.toList(bindings)
  let items = List.map(
    ((name, scheme)) => {
      let typeStr = Types.typeToString(scheme.ty)
      "{\"name\":\"" ++ escapeJson(name) ++ "\",\"type\":\"" ++ escapeJson(typeStr) ++ "\"}"
    },
    pairs
  )
  "[" ++ String.join(",", items) ++ "]"
}

let analysisToJson = (analysis: Analysis.Analysis) => {
  let programJson = programToJson(analysis.program)
  let nodeTypesJson = nodeTypesToJson(analysis.infer.nodeTypes)
  let bindingsJson = topBindingsToJson(analysis.infer.topBindings)
  
  "{\"program\":" ++ programJson ++ 
  ",\"nodeTypes\":" ++ nodeTypesJson ++ 
  ",\"topBindings\":" ++ bindingsJson ++ "}"
}

provide { analysisToJson, programToJson, exprToJson }
