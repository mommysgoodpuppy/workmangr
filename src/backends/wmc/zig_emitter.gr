module ZigEmitter

from "list" include List
from "string" include String

from "./backend_ir.gr" include BackendIR

// Zig reserved words we need to escape
let escapeIdent = (name: String) =>
  match (name) {
    "_" => "_",
    "const" => "@\"const\"",
    "var" => "@\"var\"",
    "return" => "@\"return\"",
    "if" => "@\"if\"",
    "else" => "@\"else\"",
    "while" => "@\"while\"",
    "for" => "@\"for\"",
    "break" => "@\"break\"",
    "continue" => "@\"continue\"",
    "true" => "@\"true\"",
    "false" => "@\"false\"",
    "error" => "@\"error\"",
    "test" => "@\"test\"",
    "pub" => "@\"pub\"",
    _ => name,
  }

let mut labelCounter = 0

let freshLabel = () => {
  let n = labelCounter
  labelCounter = n + 1
  "__blk_" ++ toString(n)
}

let indent = (n) => {
  let rec go = (i, acc) =>
    if (i <= 0) { acc } else { go(i - 1, acc ++ "    ") }
  go(n, "")
}

let rec emitExpr = (expr: BackendIR.Expr) =>
  emitExprI(expr, 0)

and emitExprI = (expr: BackendIR.Expr, depth: Number) =>
  match (expr) {
    BackendIR.Lit(lit) => emitLiteral(lit),
    BackendIR.Var(name) => escapeIdent(name),
    BackendIR.Prim(op, args) => emitPrimI(op, args, depth),
    BackendIR.Call(callee, arg) =>
      emitExprI(callee, depth) ++ ".func.f(" ++ emitExprI(arg, depth) ++ ")",
    BackendIR.Lambda(param, body) => {
      let inner = depth + 1
      let i = indent(inner)
      let i0 = indent(depth)
      "WmFunc.init(struct {\n" ++
      i ++ "fn f(" ++ escapeIdent(param) ++ ": Value) Value {\n" ++
      i ++ "    return " ++ emitExprI(body, inner + 1) ++ ";\n" ++
      i ++ "}\n" ++
      i0 ++ "}.f)"
    },
    BackendIR.Let(name, value, body) => {
      let label = freshLabel()
      let i = indent(depth)
      let binding = if (name == "_") {
        "_ = " ++ emitExprI(value, depth)
      } else {
        "const " ++ escapeIdent(name) ++ " = " ++ emitExprI(value, depth)
      }
      label ++ ": {\n" ++
      i ++ "    " ++ binding ++ ";\n" ++
      i ++ "    break :" ++ label ++ " " ++ emitExprI(body, depth) ++ ";\n" ++
      i ++ "}"
    },
    BackendIR.If(cond, thenE, elseE) =>
      "if (" ++ emitExprI(cond, depth) ++ ".toBool()) " ++
      emitExprI(thenE, depth) ++ " else " ++ emitExprI(elseE, depth),
    BackendIR.Seq(first, second) => {
      let label = freshLabel()
      let i = indent(depth)
      label ++ ": {\n" ++
      i ++ "    _ = " ++ emitExprI(first, depth) ++ ";\n" ++
      i ++ "    break :" ++ label ++ " " ++ emitExprI(second, depth) ++ ";\n" ++
      i ++ "}"
    },
  }

and emitLiteral = (lit: BackendIR.Literal) =>
  match (lit) {
    BackendIR.IntLit(n) => "Value.initInt(" ++ toString(n) ++ ")",
    BackendIR.BoolLit(b) => if (b) { "Value.initBool(true)" } else { "Value.initBool(false)" },
    BackendIR.StringLit(s) => "Value.initString(\"" ++ s ++ "\")",
    BackendIR.VoidLit => "Value.initVoid()",
  }

and emitPrimI = (op: BackendIR.PrimOp, args: List<BackendIR.Expr>, depth: Number) => {
  match (op) {
    BackendIR.IntAdd => emitBinPrimI("intAdd", args, depth),
    BackendIR.IntSub => emitBinPrimI("intSub", args, depth),
    BackendIR.IntMul => emitBinPrimI("intMul", args, depth),
    BackendIR.IntDiv => emitBinPrimI("intDiv", args, depth),
    BackendIR.IntEq => emitBinPrimI("intEq", args, depth),
    BackendIR.IntNe => emitBinPrimI("intNe", args, depth),
    BackendIR.IntLt => emitBinPrimI("intLt", args, depth),
    BackendIR.IntGt => emitBinPrimI("intGt", args, depth),
    BackendIR.IntLe => emitBinPrimI("intLe", args, depth),
    BackendIR.IntGe => emitBinPrimI("intGe", args, depth),
    BackendIR.BoolAnd => emitBinPrimI("boolAnd", args, depth),
    BackendIR.BoolOr => emitBinPrimI("boolOr", args, depth),
    BackendIR.BoolNot => {
      match (args) {
        [a] => "rt.boolNot(" ++ emitExprI(a, depth) ++ ")",
        _ => "rt.boolNot(Value.initVoid())",
      }
    },
    BackendIR.Print => {
      match (args) {
        [a] => "rt.print(" ++ emitExprI(a, depth) ++ ")",
        _ => "rt.print(Value.initVoid())",
      }
    },
    BackendIR.Panic => {
      match (args) {
        [a] => "rt.panic_wm(" ++ emitExprI(a, depth) ++ ")",
        _ => "rt.panic_wm(Value.initVoid())",
      }
    },
  }
}

and emitBinPrimI = (fnName: String, args: List<BackendIR.Expr>, depth: Number) =>
  match (args) {
    [a, b] => "rt." ++ fnName ++ "(" ++ emitExprI(a, depth) ++ ", " ++ emitExprI(b, depth) ++ ")",
    _ => "rt." ++ fnName ++ "(Value.initVoid(), Value.initVoid())",
  }

let emitBinding = (binding: BackendIR.ValueBinding) =>
  "const wm_" ++ escapeIdent(binding.name) ++ " = " ++ emitExpr(binding.value) ++ ";\n"

let rec emitBindings = (bindings: List<BackendIR.ValueBinding>) =>
  match (bindings) {
    [] => "",
    [b, ...rest] => emitBinding(b) ++ emitBindings(rest),
  }

let runtime = () =>
  "const Value = union(enum) {\n" ++
  "    int: i64,\n" ++
  "    boolean: bool,\n" ++
  "    string: []const u8,\n" ++
  "    void_val: void,\n" ++
  "    func: WmFunc,\n\n" ++
  "    pub fn initInt(n: i64) Value { return .{ .int = n }; }\n" ++
  "    pub fn initBool(b: bool) Value { return .{ .boolean = b }; }\n" ++
  "    pub fn initString(s: []const u8) Value { return .{ .string = s }; }\n" ++
  "    pub fn initVoid() Value { return .{ .void_val = {} }; }\n" ++
  "    pub fn toBool(self: Value) bool {\n" ++
  "        return switch (self) {\n" ++
  "            .boolean => |b| b,\n" ++
  "            .int => |n| n != 0,\n" ++
  "            else => true,\n" ++
  "        };\n" ++
  "    }\n" ++
  "};\n\n" ++
  "const WmFunc = struct {\n" ++
  "    f: *const fn (Value) Value,\n" ++
  "    pub fn init(f: *const fn (Value) Value) Value { return .{ .func = .{ .f = f } }; }\n" ++
  "    pub fn call(self: WmFunc, args: anytype) Value { return self.f(args[0]); }\n" ++
  "};\n\n" ++
  "const rt = struct {\n" ++
  "    fn intAdd(a: Value, b: Value) Value { return Value.initInt(a.int + b.int); }\n" ++
  "    fn intSub(a: Value, b: Value) Value { return Value.initInt(a.int - b.int); }\n" ++
  "    fn intMul(a: Value, b: Value) Value { return Value.initInt(a.int * b.int); }\n" ++
  "    fn intDiv(a: Value, b: Value) Value { return Value.initInt(@divTrunc(a.int, b.int)); }\n" ++
  "    fn intEq(a: Value, b: Value) Value { return Value.initBool(a.int == b.int); }\n" ++
  "    fn intNe(a: Value, b: Value) Value { return Value.initBool(a.int != b.int); }\n" ++
  "    fn intLt(a: Value, b: Value) Value { return Value.initBool(a.int < b.int); }\n" ++
  "    fn intGt(a: Value, b: Value) Value { return Value.initBool(a.int > b.int); }\n" ++
  "    fn intLe(a: Value, b: Value) Value { return Value.initBool(a.int <= b.int); }\n" ++
  "    fn intGe(a: Value, b: Value) Value { return Value.initBool(a.int >= b.int); }\n" ++
  "    fn boolAnd(a: Value, b: Value) Value { return Value.initBool(a.toBool() and b.toBool()); }\n" ++
  "    fn boolOr(a: Value, b: Value) Value { return Value.initBool(a.toBool() or b.toBool()); }\n" ++
  "    fn boolNot(a: Value) Value { return Value.initBool(!a.toBool()); }\n" ++
  "    fn print(v: Value) Value {\n" ++
  "        switch (v) {\n" ++
  "            .int => |n| std.debug.print(\"{d}\\n\", .{n}),\n" ++
  "            .boolean => |b| std.debug.print(\"{s}\\n\", .{if (b) \"true\" else \"false\"}),\n" ++
  "            .string => |s| std.debug.print(\"{s}\\n\", .{s}),\n" ++
  "            .void_val => std.debug.print(\"void\\n\", .{}),\n" ++
  "            .func => std.debug.print(\"<function>\\n\", .{}),\n" ++
  "        }\n" ++
  "        return Value.initVoid();\n" ++
  "    }\n" ++
  "    fn panic_wm(v: Value) Value {\n" ++
  "        switch (v) {\n" ++
  "            .string => |s| @panic(s),\n" ++
  "            else => @panic(\"workman panic\"),\n" ++
  "        }\n" ++
  "    }\n" ++
  "};\n\n"

let emitMain = (entry: Option<String>) =>
  match (entry) {
    Some(name) =>
      "pub fn main() void {\n" ++
      "    _ = wm_" ++ escapeIdent(name) ++ ".func.f(Value.initVoid());\n" ++
      "}\n",
    None =>
      "pub fn main() void {}\n",
  }

provide let emit = (mod: BackendIR.Module) => {
  let rt = runtime()
  let bindings = emitBindings(mod.bindings)
  let mainFn = emitMain(mod.entry)
  "const std = @import(\"std\");\n\n" ++
  bindings ++ "\n" ++ mainFn ++ "\n" ++ rt
}
