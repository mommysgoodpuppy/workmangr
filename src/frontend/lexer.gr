module Lexer

from "char" include Char
from "string" include String
from "array" include Array
from "bytes" include Bytes
from "uint8" include Uint8
from "number" include Number
from "option" include Option
from "list" include List
from "wasi/time" include Time
from "int64" include Int64
from "runtime/unsafe/panic" include Panic
use Panic.{ panic }
from "../util.gr" include Util

from "../core/source.gr" include Source
from "../core/error.gr" include Error
from "../core/surface_ast.gr" include SurfaceAst

provide enum TokenKind {
  //special keywords
  KwVar, // Var
  KwAllErrors, // AllErrors
  //literals
  Wildcard, // _
  LitName(String), // strs
  ConstructorTok(String), // Strs
  LitNum(Number), //138510
  LitString(String), // "*"
  LitChar(Char), // '*'
  LitBool(Bool), // true false
  //symbols
  LParen, // (
  RParen, // )
  LBrace, // {
  RBrace, // }
  FatArrow, // =>
  Question, // ?
  Pipe, // |
  DPipe, // ||
  SemiColon, // ;
  Comma, // ,
  Colon, // :
  Star, // *
  PipeArrow, // :>
  Slash, // /
  DSlash, // //
  LineComment(String), // //...
  Opaque(String), // unknown text
  LAngle, // <
  Arrow, // >
  Period, // .
  DotBrace, // .{
  DPeriod, // ..
  //operators
  Eq, // =
  EqEq, // ==
  Plus, // +
  DPlus, // ++
  Dash, // -
  DDash, // --
  //other
  Directive, // @stuff;
  EOF, // eof
}

//the base token type
provide record Token {
  kind: TokenKind,
  span: Source.Span,
  mate: Option<Number>, //index
}

provide let tokenKindToString = kind => match (kind) {
  KwVar => "Var",
  KwAllErrors => "AllErrors",
  Wildcard => "_",
  LitName(name) => name,
  ConstructorTok(name) => name,
  LitNum(num) => "<number>",
  LitString(str) => "\"" ++ str ++ "\"",
  LitChar(ch) => "'" ++ Char.toString(ch) ++ "'",
  LitBool(b) => if (b) {
    "true"
  } else {
    "false"
  },
  LParen => "(",
  RParen => ")",
  LBrace => "{",
  RBrace => "}",
  FatArrow => "=>",
  Question => "?",
  Pipe => "|",
  DPipe => "||",
  SemiColon => ";",
  Comma => ",",
  Colon => ":",
  Star => "*",
  PipeArrow => ":>",
  Slash => "/",
  DSlash => "//",
  LineComment(text) => text,
  Opaque(text) => text,
  LAngle => "<",
  Arrow => ">",
  Period => ".",
  DotBrace => ".{",
  DPeriod => "..",
  Eq => "=",
  EqEq => "==",
  Plus => "+",
  DPlus => "++",
  Dash => "-",
  DDash => "--",
  Directive => "@",
  EOF => "EOF",
}

enum ReadValue {
  StringVal(String),
  NumVal(Number),
  CharVal(Char),
}

record Position {
  index: Number,
  line: Number,
  col: Number,
}

record ReadResult {
  value: ReadValue,
  position: Position,
}

let createDummyMark = (span: Source.Span) => {
  let node: SurfaceAst.Node = { id: 0, span }
  let mark: SurfaceAst.Mark = {
    node,
    kind: SurfaceAst.UnknownTopLevel("lexing error"),
    expected: SurfaceAst.ExpectToken,
  }
  mark
}

let nowNs = () => match (Time.monotonicTime()) {
  Ok(t) => t,
  Err(_) => 0L,
}

let nsDelta = (startNs: Int64, endNs: Int64) =>
  Int64.toNumber(endNs) - Int64.toNumber(startNs)

let nsToMsString = (ns: Number) => {
  toString(Number.trunc(ns / 1000000))
}

let lexInternal = (source, profiling: Bool) => {
  let totalStart = if (profiling) {
    nowNs()
  } else {
    0L
  }
  let mut tWhitespaceNs = 0.0
  let mut tNameNs = 0.0
  let mut tNumberNs = 0.0
  let mut tStringNs = 0.0
  let mut tCharNs = 0.0
  let mut tSymbolNs = 0.0
  let mut tCommentNs = 0.0
  let mut tOpaqueNs = 0.0
  let mut tNameScanNs = 0.0
  let mut tNameSliceNs = 0.0
  let mut tNameKindNs = 0.0
  let mut cWhitespace = 0
  let mut cName = 0
  let mut cNumber = 0
  let mut cString = 0
  let mut cChar = 0
  let mut cSymbol = 0
  let mut cComment = 0
  let mut cOpaque = 0

  // Build byte view once and require ASCII source in this lexer implementation.
  let sourceBytes = Bytes.fromString(source)
  let sourceByteLen = Bytes.length(sourceBytes)
  // source length in character offsets used by spans (ASCII => bytes == chars)
  let lenght = sourceByteLen

  let mut bi = 0
  let mut firstNonAsciiIndex = -1
  let mut firstNonAsciiByte = 0
  while (bi < sourceByteLen) {
    let b = Uint8.toNumber(Bytes.getUint8(bi, sourceBytes))
    if (b > 127) {
      firstNonAsciiIndex = bi
      firstNonAsciiByte = b
      bi = sourceByteLen
    } else {
      bi += 1
    }
  }
  if (firstNonAsciiIndex >= 0) {
    let mut line = 1
    let mut col = 1
    let mut i = 0
    while (i < firstNonAsciiIndex) {
      let b = Uint8.toNumber(Bytes.getUint8(i, sourceBytes))
      if (b == 10) {
        line += 1
        col = 1
      } else {
        col += 1
      }
      i += 1
    }
    let span = Source.makeSpan(
      line,
      col,
      firstNonAsciiIndex,
      firstNonAsciiIndex + 1
    )
    let mark = createDummyMark(span)
    ignore(
      Error.createMarkedError(
        Error.Lexing,
        mark,
        "Lexer currently supports ASCII source only"
          ++ " (line "
          ++ toString(line)
          ++ ", col "
          ++ toString(col)
          ++ ", byte offset "
          ++ toString(firstNonAsciiIndex)
          ++ ")",
        [],
        clues=[
          Error.Note("first non-ASCII byte value: " ++ toString(firstNonAsciiByte)),
          Error.Hint("replace non-ASCII characters in source for now"),
        ]
      )
    )
  }

  let asciiSlice = (start: Number, end_: Number) =>
    Bytes.toString(Bytes.slice(start, end_ - start, sourceBytes))

  let mut parenStack = []
  let mut braceStack = []
  let peek = index => {
    if (index < 0 || index >= lenght) {
      None
    } else {
      Some(Char.fromCode(Uint8.toNumber(Bytes.getUint8(index, sourceBytes))))
    }
  }

  // advance position based on character
  let advancePosition = (pos: Position, ch: Char) => {
    let newIndex = pos.index + 1
    let newLine = if (ch == '\n') {
      pos.line + 1
    } else {
      pos.line
    }
    let newCol = if (ch == '\n') {
      1
    } else {
      pos.col + 1
    }
    { index: newIndex, line: newLine, col: newCol }
  }

  // continue until not whitespace
  let skipWhitespace = position => {
    let mut idx = position.index
    let mut line = position.line
    let mut col = position.col
    while (idx < lenght) {
      match (peek(idx)) {
        Some(ch) when Char.Ascii.isWhitespace(ch) => {
          idx += 1
          if (ch == '\n') {
            line += 1
            col = 1
          } else {
            col += 1
          }
        },
        _ => break,
      }
    }
    { index: idx, line, col }
  }

  // name start
  let isAsciiDigit = (ch: Char) => {
    let code = Char.code(ch)
    code >= 48 && code <= 57
  }

  let isAsciiAlpha = (ch: Char) => {
    let code = Char.code(ch)
    code >= 97 && code <= 122 || code >= 65 && code <= 90
  }

  let isAsciiWhitespace = (ch: Char) => {
    ch == ' ' || ch == '\n' || ch == '\r' || ch == '\t'
  }

  let isNameStart = (ch: Char) => {
    isAsciiAlpha(ch) || ch == '_'
  }

  let isAsciiDigitN = (n: Number) => n >= 48 && n <= 57
  let isAsciiAlphaN = (n: Number) => n >= 97 && n <= 122 || n >= 65 && n <= 90
  let isNameStartN = (n: Number) => isAsciiAlphaN(n) || n == 95

  // check if uppercase
  let isUpper = (ch: Char) => {
    let code = Char.code(ch)
    code >= Char.code('A') && code <= Char.code('Z')
  }

  //read a name to end
  let readName = (startPosition: Position) => {
    let mut endIndex = startPosition.index
    while (endIndex < lenght) {
      let chNum = Uint8.toNumber(Bytes.getUint8(endIndex, sourceBytes))
      if (isNameStartN(chNum) || isAsciiDigitN(chNum)) {
        endIndex += 1
      } else {
        break
      }
    }
    let name = asciiSlice(startPosition.index, endIndex)
    {
      value: StringVal(name),
      position: {
        index: endIndex,
        line: startPosition.line,
        col: startPosition.col + (endIndex - startPosition.index),
      },
    }
  }

  //read a number to end
  let readNumber = (startPosition: Position) => {
    let mut idx = startPosition.index
    let mut acc = 0
    while (idx < lenght) {
      let chNum = Uint8.toNumber(Bytes.getUint8(idx, sourceBytes))
      if (isAsciiDigitN(chNum)) {
        acc = acc * 10 + (chNum - 48)
        idx += 1
      } else {
        break
      }
    }
    {
      value: NumVal(acc),
      position: {
        index: idx,
        line: startPosition.line,
        col: startPosition.col + (idx - startPosition.index),
      },
    }
  }

  //read string to end
  let readString = (startPosition: Position) => {
    let mut idx = startPosition.index
    let mut line = startPosition.line
    let mut col = startPosition.col
    let mut chunks: List<String> = []
    let mut done = false
    let mut outPos = startPosition

    while (idx < lenght && !done) {
      let b = Uint8.toNumber(Bytes.getUint8(idx, sourceBytes))
      if (b == 34) { // "
        outPos = { index: idx + 1, line, col: col + 1 }
        done = true
      } else if (b == 92) { // \
        if (idx + 1 >= lenght) {
          let span = Source.makeSpan(
            startPosition.line,
            startPosition.col,
            startPosition.index,
            idx
          )
          let mark = createDummyMark(span)
          let partial = Array.join("", Array.fromList(List.reverse(chunks)))
          outPos = { index: idx, line, col }
          done = true
          ignore(
            Error.createMarkedError(
              Error.Lexing,
              mark,
              "Unclosed escape sequence in string",
              { value: StringVal(partial), position: outPos },
              clues=[
                Error.Note(
                  "check for matching quotes and valid escape sequences",
                ),
              ]
            )
          )
        } else {
          let nextB = Uint8.toNumber(Bytes.getUint8(idx + 1, sourceBytes))
          let escaped = if (nextB == 34) {
            "\""
          } else if (nextB == 92) {
            "\\"
          } else if (nextB == 110) {
            "\n"
          } else if (nextB == 116) {
            "\t"
          } else if (nextB == 114) {
            "\r"
          } else {
            asciiSlice(idx + 1, idx + 2) // treat as literal
          }
          chunks = [escaped, ...chunks]
          idx += 2
          col += 2
        }
      } else {
        let segmentStart = idx
        let mut segLine = line
        let mut segCol = col
        while (idx < lenght) {
          let x = Uint8.toNumber(Bytes.getUint8(idx, sourceBytes))
          if (x == 34 || x == 92) {
            break
          }
          idx += 1
          if (x == 10) {
            segLine += 1
            segCol = 1
          } else {
            segCol += 1
          }
        }
        chunks = [asciiSlice(segmentStart, idx), ...chunks]
        line = segLine
        col = segCol
      }
    }

    if (done) {
      {
        value: StringVal(Array.join("", Array.fromList(List.reverse(chunks)))),
        position: outPos,
      }
    } else {
      let span = Source.makeSpan(
        startPosition.line,
        startPosition.col,
        startPosition.index,
        idx
      )
      let mark = createDummyMark(span)
      Error.createMarkedError(
        Error.Lexing,
        mark,
        "Unclosed string literal",
        { value: StringVal(""), position: startPosition },
        clues=[Error.Expected("closing quote")]
      )
    }
  }

  //read char to end
  let readChar = (startPosition: Position) => {
    match (peek(startPosition.index)) {
      Some(ch) => {
        if (ch == '\'') {
          let afterQuote = advancePosition(startPosition, '\'')
          let span = Source.makeSpan(
            startPosition.line,
            startPosition.col,
            startPosition.index,
            startPosition.index + 1
          )
          let mark = createDummyMark(span)
          Error.createMarkedError(
            Error.Lexing,
            mark,
            "Empty character literal",
            // Advance past the second quote to avoid re-lexing the same token forever.
            { value: CharVal(' '), position: afterQuote },
            clues=[
              Error.Note(
                "character literals must contain exactly one character",
              ),
            ]
          )
        } else if (ch == '\\') {
          let afterSlash = advancePosition(startPosition, '\\')
          match (peek(afterSlash.index)) {
            Some(escapedSourceChar) => {
              let decodedChar = if (escapedSourceChar == 'n') {
                '\n'
              } else if (escapedSourceChar == 't') {
                '\t'
              } else if (escapedSourceChar == 'r') {
                '\r'
              } else if (escapedSourceChar == '\\') {
                '\\'
              } else if (escapedSourceChar == '\'') {
                '\''
              } else if (escapedSourceChar == '0') {
                Char.fromCode(0)
              } else {
                escapedSourceChar
              }
              let afterEscaped = advancePosition(afterSlash, escapedSourceChar)
              match (peek(afterEscaped.index)) {
                Some('\'') => {
                  {
                    value: CharVal(decodedChar),
                    position: advancePosition(afterEscaped, '\''),
                  }
                },
                _ => {
                  let span = Source.makeSpan(
                    startPosition.line,
                    startPosition.col,
                    startPosition.index,
                    afterEscaped.index
                  )
                  let mark = createDummyMark(span)
                  Error.createMarkedError(
                    Error.Lexing,
                    mark,
                    "Unclosed character literal",
                    { value: CharVal(' '), position: afterEscaped },
                    clues=[Error.Expected("closing single quote")]
                  )
                },
              }
            },
            None => {
              let span = Source.makeSpan(
                startPosition.line,
                startPosition.col,
                startPosition.index,
                startPosition.index + 1
              )
              let mark = createDummyMark(span)
              Error.createMarkedError(
                Error.Lexing,
                mark,
                "Unclosed character literal",
                { value: CharVal(' '), position: afterSlash },
                clues=[Error.Expected("escaped character and closing quote")]
              )
            },
          }
        } else {
          let char = ch
          let afterChar = advancePosition(startPosition, ch)
          match (peek(afterChar.index)) {
            Some('\'') => {
              {
                value: CharVal(char),
                position: advancePosition(afterChar, '\''),
              }
            },
            _ => {
              let span = Source.makeSpan(
                startPosition.line,
                startPosition.col,
                startPosition.index,
                afterChar.index
              )
              let mark = createDummyMark(span)
              Error.createMarkedError(
                Error.Lexing,
                mark,
                "Unclosed character literal",
                { value: CharVal(' '), position: afterChar },
                clues=[Error.Expected("closing single quote")]
              )
            },
          }
        }
      },
      None => {
        let span = Source.makeSpan(
          startPosition.line,
          startPosition.col,
          startPosition.index,
          startPosition.index
        )
        let mark = createDummyMark(span)
        Error.createMarkedError(
          Error.Lexing,
          mark,
          "Unclosed character literal",
          { value: CharVal(' '), position: startPosition },
          clues=[Error.Expected("character and closing quote")]
        )
      },
    }
  }

  // determine token kind from name
  let tokenKindFromName = (name: String) => {
    match (name) {
      "Var" => KwVar,
      "AllErrors" => KwAllErrors,
      "_" => Wildcard,
      "true" => LitBool(true),
      "false" => LitBool(false),
      _ => {
        if (isUpper(String.charAt(0, name))) {
          ConstructorTok(name)
        } else {
          LitName(name)
        }
      },
    }
  }

  //create a Token
  let makeToken = (kind: TokenKind, line, col, start, end, mate) =>
    { kind, span: Source.makeSpan(line, col, start, end), mate }
  let mut tokens = []
  let mut pos = { index: 0, line: 1, col: 1 }
  while (pos.index < lenght) {
    if (profiling) {
      let t0 = nowNs()
      let mut idx = pos.index
      let mut line = pos.line
      let mut col = pos.col
      while (idx < lenght) {
        let chNum = Uint8.toNumber(Bytes.getUint8(idx, sourceBytes))
        if (chNum == 32 || chNum == 10 || chNum == 13 || chNum == 9) {
          idx += 1
          if (chNum == 10) {
            line += 1
            col = 1
          } else {
            col += 1
          }
        } else {
          break
        }
      }
      pos = { index: idx, line, col }
      let t1 = nowNs()
      tWhitespaceNs += nsDelta(t0, t1)
      cWhitespace += 1
    } else {
      let mut idx = pos.index
      let mut line = pos.line
      let mut col = pos.col
      while (idx < lenght) {
        let chNum = Uint8.toNumber(Bytes.getUint8(idx, sourceBytes))
        if (chNum == 32 || chNum == 10 || chNum == 13 || chNum == 9) {
          idx += 1
          if (chNum == 10) {
            line += 1
            col = 1
          } else {
            col += 1
          }
        } else {
          break
        }
      }
      pos = { index: idx, line, col }
    }
    if (pos.index >= lenght) break
    let chNum = Uint8.toNumber(Bytes.getUint8(pos.index, sourceBytes))
    let ch = Char.fromCode(chNum)
    match (ch) {
      _ when isNameStartN(chNum) => {
        let t0 = if (profiling) {
          nowNs()
        } else {
          0L
        }
        let nameScanStart = if (profiling) {
          nowNs()
        } else {
          0L
        }
        let mut endIndex = pos.index
        while (endIndex < lenght) {
          let nextNum = Uint8.toNumber(Bytes.getUint8(endIndex, sourceBytes))
          if (isNameStartN(nextNum) || isAsciiDigitN(nextNum)) {
            endIndex += 1
          } else {
            break
          }
        }
        if (profiling) {
          let nameScanEnd = nowNs()
          tNameScanNs += nsDelta(nameScanStart, nameScanEnd)
        }
        let nameSliceStart = if (profiling) {
          nowNs()
        } else {
          0L
        }
        let ident = asciiSlice(pos.index, endIndex)
        if (profiling) {
          let nameSliceEnd = nowNs()
          tNameSliceNs += nsDelta(nameSliceStart, nameSliceEnd)
        }
        let newPos = {
          index: endIndex,
          line: pos.line,
          col: pos.col + (endIndex - pos.index),
        }
        if (profiling) {
          let t1 = nowNs()
          tNameNs += nsDelta(t0, t1)
          cName += 1
        }
        let nameKindStart = if (profiling) {
          nowNs()
        } else {
          0L
        }
        let kind = tokenKindFromName(ident)
        if (profiling) {
          let nameKindEnd = nowNs()
          tNameKindNs += nsDelta(nameKindStart, nameKindEnd)
        }
        tokens = [
          makeToken(kind, pos.line, pos.col, pos.index, endIndex, None),
          ...tokens
        ]
        pos = newPos
      },
      _ when isAsciiDigitN(chNum) => {
        let t0 = if (profiling) {
          nowNs()
        } else {
          0L
        }
        let mut idx = pos.index
        let mut val = 0
        while (idx < lenght) {
          let nextNum = Uint8.toNumber(Bytes.getUint8(idx, sourceBytes))
          if (isAsciiDigitN(nextNum)) {
            val = val * 10 + (nextNum - 48)
            idx += 1
          } else {
            break
          }
        }
        let newPos = {
          index: idx,
          line: pos.line,
          col: pos.col + (idx - pos.index),
        }
        if (profiling) {
          let t1 = nowNs()
          tNumberNs += nsDelta(t0, t1)
          cNumber += 1
        }
        tokens = [
          makeToken(LitNum(val), pos.line, pos.col, pos.index, idx, None),
          ...tokens
        ]
        pos = newPos
      },
      '"' => {
        let t0 = if (profiling) {
          nowNs()
        } else {
          0L
        }
        let res = readString(advancePosition(pos, ch))
        if (profiling) {
          let t1 = nowNs()
          tStringNs += nsDelta(t0, t1)
          cString += 1
        }
        let str = match (res.value) {
          StringVal(s) => s,
          _ => {
            let span = Source.makeSpan(
              pos.line,
              pos.col,
              pos.index,
              res.position.index
            )
            let mark = createDummyMark(span)
            Error.createMarkedError(
              Error.Lexing,
              mark,
              "Invalid string literal",
              "",
              clues=[
                Error.Note(
                  "internal error: expected string value from string reader",
                ),
              ]
            )
          },
        }
        tokens = [
          makeToken(
            LitString(str),
            pos.line,
            pos.col,
            pos.index,
            res.position.index,
            None
          ),
          ...tokens
        ]
        pos = res.position
      },
      '\'' => {
        let t0 = if (profiling) {
          nowNs()
        } else {
          0L
        }
        let res = readChar(advancePosition(pos, ch))
        if (profiling) {
          let t1 = nowNs()
          tCharNs += nsDelta(t0, t1)
          cChar += 1
        }
        let chr = match (res.value) {
          CharVal(c) => c,
          _ => {
            let span = Source.makeSpan(
              pos.line,
              pos.col,
              pos.index,
              res.position.index
            )
            let mark = createDummyMark(span)
            Error.createMarkedError(
              Error.Lexing,
              mark,
              "Invalid character literal",
              ' ',
              clues=[
                Error.Note(
                  "internal error: expected character value from char reader",
                ),
              ]
            )
          },
        }
        tokens = [
          makeToken(
            LitChar(chr),
            pos.line,
            pos.col,
            pos.index,
            res.position.index,
            None
          ),
          ...tokens
        ]
        pos = res.position
      },
      ch => { //Var(ch)
        let t0 = if (profiling) {
          nowNs()
        } else {
          0L
        }
        match (ch) {
          '(' => {
            tokens = [
              makeToken(
                LParen,
                pos.line,
                pos.col,
                pos.index,
                pos.index + 1,
                None
              ),
              ...tokens
            ]
            parenStack = [pos.index, ...parenStack]
            pos = advancePosition(pos, ch)
          },
          ')' => {
            let mateIndex = List.head(parenStack)
            parenStack = match (mateIndex) {
              Some(_) => match (List.tail(parenStack)) {
                Some(tail) => tail,
                None => parenStack,
              },
              None => parenStack,
            }
            tokens = [
              makeToken(
                RParen,
                pos.line,
                pos.col,
                pos.index,
                pos.index + 1,
                mateIndex
              ),
              ...tokens
            ]
            pos = advancePosition(pos, ch)
          },
          '{' => {
            tokens = [
              makeToken(
                LBrace,
                pos.line,
                pos.col,
                pos.index,
                pos.index + 1,
                None
              ),
              ...tokens
            ]
            braceStack = [pos.index, ...braceStack]
            pos = advancePosition(pos, ch)
          },
          '}' => {
            let mateIndex = List.head(braceStack)
            braceStack = match (mateIndex) {
              Some(_) => match (List.tail(braceStack)) {
                Some(tail) => tail,
                None => braceStack,
              },
              None => braceStack,
            }
            tokens = [
              makeToken(
                RBrace,
                pos.line,
                pos.col,
                pos.index,
                pos.index + 1,
                mateIndex
              ),
              ...tokens
            ]
            pos = advancePosition(pos, ch)
          },
          '?' => {
            tokens = [
              makeToken(
                Question,
                pos.line,
                pos.col,
                pos.index,
                pos.index + 1,
                None
              ),
              ...tokens
            ]
            pos = advancePosition(pos, ch)
          },
          ';' => {
            tokens = [
              makeToken(
                SemiColon,
                pos.line,
                pos.col,
                pos.index,
                pos.index + 1,
                None
              ),
              ...tokens
            ]
            pos = advancePosition(pos, ch)
          },
          ':' => {
            match (peek(pos.index + 1)) {
              Some('>') => {
                tokens = [
                  makeToken(
                    PipeArrow,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 2,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(advancePosition(pos, ch), '>')
              },
              _ => {
                tokens = [
                  makeToken(
                    Colon,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 1,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(pos, ch)
              },
            }
          },
          '*' => {
            tokens = [
              makeToken(Star, pos.line, pos.col, pos.index, pos.index + 1, None),
              ...tokens
            ]
            pos = advancePosition(pos, ch)
          },
          ',' => {
            tokens = [
              makeToken(
                Comma,
                pos.line,
                pos.col,
                pos.index,
                pos.index + 1,
                None
              ),
              ...tokens
            ]
            pos = advancePosition(pos, ch)
          },
          '<' => {
            tokens = [
              makeToken(
                LAngle,
                pos.line,
                pos.col,
                pos.index,
                pos.index + 1,
                None
              ),
              ...tokens
            ]
            pos = advancePosition(pos, ch)
          },
          '>' => {
            tokens = [
              makeToken(
                Arrow,
                pos.line,
                pos.col,
                pos.index,
                pos.index + 1,
                None
              ),
              ...tokens
            ]
            pos = advancePosition(pos, ch)
          },
          //len2
          '|' => {
            match (peek(pos.index + 1)) {
              Some('-') => {
                tokens = [
                  makeToken(
                    DPipe,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 2,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(advancePosition(pos, ch), '-')
              },
              _ => {
                tokens = [
                  makeToken(
                    Pipe,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 1,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(pos, ch)
              },
            }
          },
          '-' => {
            match (peek(pos.index + 1)) {
              Some('-') => {
                let commentStart = if (profiling) {
                  nowNs()
                } else {
                  0L
                }
                let afterDashes = advancePosition(advancePosition(pos, ch), '-')
                let mut endPos = afterDashes
                while (endPos.index < lenght) {
                  let c = Char.fromCode(
                    Uint8.toNumber(Bytes.getUint8(endPos.index, sourceBytes))
                  )
                  if (c == '\n') {
                    break
                  }
                  endPos = advancePosition(endPos, c)
                }
                let commentText = asciiSlice(pos.index, endPos.index)
                tokens = [
                  makeToken(
                    LineComment(commentText),
                    pos.line,
                    pos.col,
                    pos.index,
                    endPos.index,
                    None
                  ),
                  ...tokens
                ]
                pos = endPos
                if (profiling) {
                  let commentEnd = nowNs()
                  tCommentNs += nsDelta(commentStart, commentEnd)
                  cComment += 1
                }
              },
              _ => {
                tokens = [
                  makeToken(
                    Dash,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 1,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(pos, ch)
              },
            }
          },
          '.' => {
            match (peek(pos.index + 1)) {
              Some('{') => {
                tokens = [
                  makeToken(
                    DotBrace,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 2,
                    None
                  ),
                  ...tokens
                ]
                braceStack = [pos.index, ...braceStack]
                pos = advancePosition(advancePosition(pos, ch), '{')
              },
              Some('.') => {
                tokens = [
                  makeToken(
                    DPeriod,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 2,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(advancePosition(pos, ch), '.')
              },
              _ => {
                tokens = [
                  makeToken(
                    Period,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 1,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(pos, ch)
              },
            }
          },
          '+' => {
            match (peek(pos.index + 1)) {
              Some('+') => {
                tokens = [
                  makeToken(
                    DPlus,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 2,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(advancePosition(pos, ch), '+')
              },
              _ => {
                tokens = [
                  makeToken(
                    Plus,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 1,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(pos, ch)
              },
            }
          },
          '=' => {
            match (peek(pos.index + 1)) {
              Some('>') => {
                tokens = [
                  makeToken(
                    FatArrow,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 2,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(advancePosition(pos, ch), '>')
              },
              Some('=') => {
                tokens = [
                  makeToken(
                    EqEq,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 2,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(advancePosition(pos, ch), '=')
              },
              _ => {
                tokens = [
                  makeToken(
                    Eq,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 1,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(pos, ch)
              },
            }
          },
          '/' => {
            match (peek(pos.index + 1)) {
              Some('/') => {
                let commentStart = if (profiling) {
                  nowNs()
                } else {
                  0L
                }
                let afterSlashes = advancePosition(
                  advancePosition(pos, ch),
                  '/'
                )
                let mut endPos = afterSlashes
                while (endPos.index < lenght) {
                  let c = Char.fromCode(
                    Uint8.toNumber(Bytes.getUint8(endPos.index, sourceBytes))
                  )
                  if (c == '\n') {
                    break
                  }
                  endPos = advancePosition(endPos, c)
                }
                let commentText = asciiSlice(pos.index, endPos.index)
                tokens = [
                  makeToken(
                    LineComment(commentText),
                    pos.line,
                    pos.col,
                    pos.index,
                    endPos.index,
                    None
                  ),
                  ...tokens
                ]
                pos = endPos
                if (profiling) {
                  let commentEnd = nowNs()
                  tCommentNs += nsDelta(commentStart, commentEnd)
                  cComment += 1
                }
              },
              _ => {
                tokens = [
                  makeToken(
                    Slash,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 1,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(pos, ch)
              },
            }
          },
          '@' => {
            tokens = [
              makeToken(
                Directive,
                pos.line,
                pos.col,
                pos.index,
                pos.index + 1,
                None
              ),
              ...tokens
            ]
            pos = advancePosition(pos, ch)
          },
          _ => {
            let opaqueStart = if (profiling) {
              nowNs()
            } else {
              0L
            }
            let startIndex = pos.index
            let mut endPos = pos
            while (true) {
              let nextChar = peek(endPos.index)
              match (nextChar) {
                None => break,
                Some('\n') => break,
                _ => {
                  endPos = advancePosition(
                    endPos,
                    Char.fromCode(
                      Uint8.toNumber(Bytes.getUint8(endPos.index, sourceBytes))
                    )
                  )
                },
              }
            }
            let text = asciiSlice(startIndex, endPos.index)
            tokens = [
              makeToken(
                Opaque(text),
                pos.line,
                pos.col,
                startIndex,
                endPos.index,
                None
              ),
              ...tokens
            ]
            pos = endPos
            if (profiling) {
              let opaqueEnd = nowNs()
              tOpaqueNs += nsDelta(opaqueStart, opaqueEnd)
              cOpaque += 1
            }
          },
        }
        if (profiling) {
          let t1 = nowNs()
          tSymbolNs += nsDelta(t0, t1)
          cSymbol += 1
        }
      },
    }
  }
  tokens = [
    makeToken(EOF, pos.line, pos.col, pos.index, pos.index, None),
    ...tokens
  ]
  let out = List.reverse(tokens)
  if (profiling) {
    let totalEnd = nowNs()
    let totalNs = nsDelta(totalStart, totalEnd)
    print("[LexerTiming] input length: " ++ toString(lenght))
    print("[LexerTiming] total: " ++ nsToMsString(totalNs) ++ "ms")
    print(
      "[LexerTiming] whitespace: "
        ++ nsToMsString(tWhitespaceNs)
        ++ "ms (calls="
        ++ toString(cWhitespace)
        ++ ")"
    )
    print(
      "[LexerTiming] names: "
        ++ nsToMsString(tNameNs)
        ++ "ms (tokens="
        ++ toString(cName)
        ++ ")"
    )
    print("[LexerTiming] names/scan: " ++ nsToMsString(tNameScanNs) ++ "ms")
    print("[LexerTiming] names/slice: " ++ nsToMsString(tNameSliceNs) ++ "ms")
    print("[LexerTiming] names/kind: " ++ nsToMsString(tNameKindNs) ++ "ms")
    print(
      "[LexerTiming] numbers: "
        ++ nsToMsString(tNumberNs)
        ++ "ms (tokens="
        ++ toString(cNumber)
        ++ ")"
    )
    print(
      "[LexerTiming] strings: "
        ++ nsToMsString(tStringNs)
        ++ "ms (tokens="
        ++ toString(cString)
        ++ ")"
    )
    print(
      "[LexerTiming] chars: "
        ++ nsToMsString(tCharNs)
        ++ "ms (tokens="
        ++ toString(cChar)
        ++ ")"
    )
    print(
      "[LexerTiming] symbols_total: "
        ++ nsToMsString(tSymbolNs)
        ++ "ms (dispatches="
        ++ toString(cSymbol)
        ++ ")"
    )
    print(
      "[LexerTiming] comments: "
        ++ nsToMsString(tCommentNs)
        ++ "ms (tokens="
        ++ toString(cComment)
        ++ ")"
    )
    print(
      "[LexerTiming] opaque: "
        ++ nsToMsString(tOpaqueNs)
        ++ "ms (tokens="
        ++ toString(cOpaque)
        ++ ")"
    )
    print("[LexerTiming] token count: " ++ toString(List.length(out)))
  }
  out
}

// lexer without profiling logs
provide let lex = source => lexInternal(source, false)

// lexer with phase timing logs
provide let lexProfile = source => lexInternal(source, true)
