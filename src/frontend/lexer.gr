module Lexer

from "char" include Char
from "string" include String
from "number" include Number
from "option" include Option
from "list" include List
from "runtime/unsafe/panic" include Panic
use Panic.{ panic }
from "../util.gr" include Util
use Util.{ testStr }

from "../core/source.gr" include Source
from "../core/error.gr" include Error

provide enum TokenKind {
  //special keywords
  KwVar, // Var
  KwAllErrors, // AllErrors
  //literals
  Wildcard, // _
  LitName(String), // strs
  ConstructorTok(String), // Strs
  LitNum(Number), //138510
  LitString(String), // "*"
  LitChar(Char), // '*'
  LitBool(Bool), // true false
  //symbols
  LParen, // (
  RParen, // )
  LBrace, // {
  RBrace, // }
  FatArrow, // =>
  Question, // ?
  Pipe, // |
  DPipe, // ||
  SemiColon, // ;
  Comma, // ,
  Colon, // :
  PipeArrow, // :>
  Slash, // /
  DSlash, // //
  LineComment(String), // //...
  Arrow, // >
  Period, // .
  DotBrace, // .{
  DPeriod, // ..
  //operators
  Eq, // =
  EqEq, // ==
  Plus, // +
  DPlus, // ++
  Dash, // -
  DDash, // --
  //other
  Directive, // @stuff;
  EOF, // eof
}

//the base token type
provide record Token {
  kind: TokenKind,
  span: Source.Span,
  mate: Option<Number>, //index
}

provide let tokenKindToString = kind => match (kind) {
  KwVar => "Var",
  KwAllErrors => "AllErrors",
  Wildcard => "_",
  LitName(name) => name,
  ConstructorTok(name) => name,
  LitNum(num) => "<number>",
  LitString(str) => "\"" ++ str ++ "\"",
  LitChar(ch) => "'" ++ Char.toString(ch) ++ "'",
  LitBool(b) => if (b) {
    "true"
  } else {
    "false"
  },
  LParen => "(",
  RParen => ")",
  LBrace => "{",
  RBrace => "}",
  FatArrow => "=>",
  Question => "?",
  Pipe => "|",
  DPipe => "||",
  SemiColon => ";",
  Comma => ",",
  Colon => ":",
  PipeArrow => ":>",
  Slash => "/",
  DSlash => "//",
  LineComment(text) => text,
  Arrow => ">",
  Period => ".",
  DotBrace => ".{",
  DPeriod => "..",
  Eq => "=",
  EqEq => "==",
  Plus => "+",
  DPlus => "++",
  Dash => "-",
  DDash => "--",
  Directive => "@",
  EOF => "EOF",
}

enum ReadValue {
  StringVal(String),
  NumVal(Number),
  CharVal(Char),
}

record Position {
  index: Number,
  line: Number,
  col: Number,
}

record ReadResult {
  value: ReadValue,
  position: Position,
}

//lexer function
provide let lex = source => {

  //source lenght
  let lenght = String.length(source)

  let mut parenStack = []
  let mut braceStack = []
  let peek = index => {
    if (index < 0 || index >= lenght) {
      None
    } else {
      Some(String.charAt(index, source))
    }
  }

  // advance position based on character
  let advancePosition = (pos: Position, ch: Char) => {
    let newIndex = pos.index + 1
    let newLine = if (ch == '\n') {
      pos.line + 1
    } else {
      pos.line
    }
    let newCol = if (ch == '\n') {
      1
    } else {
      pos.col + 1
    }
    { index: newIndex, line: newLine, col: newCol }
  }

  // continue until not whitespace
  let skipWhitespace = position => {
    let mut p = position
    while (true) {
      match (peek(p.index)) {
        Some(ch) when Char.Ascii.isWhitespace(ch) => {
          p = advancePosition(p, ch)
        },
        _ => break,
      }
    }
    p
  }

  // name start
  let isNameStart = (ch: Char) => {
    Char.Ascii.isAlpha(ch) || ch == '_'
  }

  // check if uppercase
  let isUpper = (ch: Char) => {
    let code = Char.code(ch)
    code >= Char.code('A') && code <= Char.code('Z')
  }

  //read a name to end
  let readName = (startPosition: Position) => {
    // name cont
    let isNameContinue = (ch: Char) => {
      isNameStart(ch) || Char.Ascii.isDigit(ch)
    }

    let rec loop = (currentPos: Position) => {
      match (peek(currentPos.index)) {
        Some(ch) => {
          if (isNameContinue(ch)) {
            let newPos = advancePosition(currentPos, ch)
            loop(newPos)
          } else {
            currentPos
          }
        },
        _ => currentPos,
      }
    }
    let endPos = loop(startPosition)
    let name = String.slice(startPosition.index, end=endPos.index, source)
    { value: StringVal(name), position: endPos }
  }

  //read a number to end
  let readNumber = (startPosition: Position) => {
    // number
    let digitValue = (ch: Char) => {
      Char.code(ch) - Char.code('0')
    }

    let firstCh = String.charAt(startPosition.index, source)
    let initialAcc = digitValue(firstCh)

    let rec loop = (currentPos: Position, acc: Number) => {
      match (peek(currentPos.index)) {
        Some(ch) => {
          if (Char.Ascii.isDigit(ch)) {
            let newAcc = acc * 10 + digitValue(ch)
            let newPos = advancePosition(currentPos, ch)
            loop(newPos, newAcc)
          } else {
            { value: NumVal(acc), position: currentPos }
          }
        },
        _ => { value: NumVal(acc), position: currentPos },
      }
    }
    let startAfterFirst = advancePosition(startPosition, firstCh)
    loop(startAfterFirst, initialAcc)
  }

  //read string to end
  let readString = (startPosition: Position) => {
    let rec loop = (currentPos: Position, acc: String) => {
      match (peek(currentPos.index)) {
        Some(ch) => {
          if (ch == '"') {
            // end of string
            { value: StringVal(acc), position: advancePosition(currentPos, ch) }
          } else if (ch == '\\') {
            // escape sequence
            match (peek(currentPos.index + 1)) {
              Some(nextCh) => {
                let escaped = if (nextCh == '"') {
                  "\""
                } else if (nextCh == '\\') {
                  "\\"
                } else if (nextCh == 'n') {
                  "\n"
                } else if (nextCh == 't') {
                  "\t"
                } else if (nextCh == 'r') {
                  "\r"
                } else {
                  String.slice(
                    currentPos.index + 1,
                    end=currentPos.index + 2,
                    source
                  ) // treat as literal
                }
                let newAcc = acc ++ escaped
                let newPos = advancePosition(
                  advancePosition(currentPos, ch),
                  nextCh
                )
                loop(newPos, newAcc)
              },
              None => {
                let span = Source.makeSpan(startPosition.line, startPosition.col, startPosition.index, currentPos.index)
                Error.createPanicError(Error.Lexing, span, "Unclosed escape sequence in string", [Error.Note("check for matching quotes and valid escape sequences")])
              },
            }
          } else {
            let charStr = String.slice(
              currentPos.index,
              end=currentPos.index + 1,
              source
            )
            let newAcc = acc ++ charStr
            let newPos = advancePosition(currentPos, ch)
            loop(newPos, newAcc)
          }
        },
        None => {
          let span = Source.makeSpan(startPosition.line, startPosition.col, startPosition.index, currentPos.index)
          Error.createPanicError(Error.Lexing, span, "Unclosed string literal", [Error.Expected("closing quote")])
        },
      }
    }
    loop(startPosition, "")
  }

  //read char to end
  let readChar = (startPosition: Position) => {
    match (peek(startPosition.index)) {
      Some(ch) => {
        if (ch == '\'') {
          let span = Source.makeSpan(startPosition.line, startPosition.col, startPosition.index, startPosition.index + 1)
          Error.createPanicError(Error.Lexing, span, "Empty character literal", [Error.Note("character literals must contain exactly one character")])
        } else {
          let char = ch
          let afterChar = advancePosition(startPosition, ch)
          match (peek(afterChar.index)) {
            Some('\'') => {
              {
                value: CharVal(char),
                position: advancePosition(afterChar, '\''),
              }
            },
            _ => {
              let span = Source.makeSpan(startPosition.line, startPosition.col, startPosition.index, afterChar.index)
              Error.createPanicError(Error.Lexing, span, "Unclosed character literal", [Error.Expected("closing single quote")])
            },
          }
        }
      },
      None => {
        let span = Source.makeSpan(startPosition.line, startPosition.col, startPosition.index, startPosition.index)
        Error.createPanicError(Error.Lexing, span, "Unclosed character literal", [Error.Expected("character and closing quote")])
      },
    }
  }

  // determine token kind from name
  let tokenKindFromName = (name: String) => {
    match (name) {
      "Var" => KwVar,
      "AllErrors" => KwAllErrors,
      "_" => Wildcard,
      "true" => LitBool(true),
      "false" => LitBool(false),
      _ => {
        if (isUpper(String.charAt(0, name))) {
          ConstructorTok(name)
        } else {
          LitName(name)
        }
      },
    }
  }

  //create a Token
  let makeToken = (kind: TokenKind, line, col, start, end, mate) =>
    { kind, span: Source.makeSpan(line, col, start, end), mate }
  let mut tokens = []
  let mut pos = { index: 0, line: 1, col: 1 }
  while (pos.index < lenght) {
    pos = skipWhitespace(pos)
    if (pos.index >= lenght) break
    let ch = String.charAt(pos.index, source)
    match (ch) {
      ch when isNameStart(ch) => {
        let res = readName(pos)
        let ident = match (res.value) {
          StringVal(s) => s,
          _ => {
            let span = Source.makeSpan(pos.line, pos.col, pos.index, res.position.index)
            Error.createPanicError(Error.Lexing, span, "Invalid identifier", [Error.Note("internal error: expected string value from name reader")])
          },
        }
        let kind = tokenKindFromName(ident)
        tokens = [
          makeToken(
            kind,
            pos.line,
            pos.col,
            pos.index,
            res.position.index,
            None
          ),
          ...tokens
        ]
        pos = res.position
      },
      ch when Char.Ascii.isDigit(ch) => {
        let res = readNumber(pos)
        let val = match (res.value) {
          NumVal(ident) => {
            ident
          },
          _ => {
            let span = Source.makeSpan(pos.line, pos.col, pos.index, res.position.index)
            Error.createPanicError(Error.Lexing, span, "Invalid constructor", [Error.Note("internal error: expected string value from constructor reader")])
          },
        }
        tokens = [
          makeToken(
            LitNum(val),
            pos.line,
            pos.col,
            pos.index,
            res.position.index,
            None
          ),
          ...tokens
        ]
        pos = res.position
      },
      '"' => {
        let res = readString(advancePosition(pos, ch))
        let str = match (res.value) {
          StringVal(s) => s,
          _ => {
            let span = Source.makeSpan(pos.line, pos.col, pos.index, res.position.index)
            Error.createPanicError(Error.Lexing, span, "Invalid string literal", [Error.Note("internal error: expected string value from string reader")])
          },
        }
        tokens = [
          makeToken(
            LitString(str),
            pos.line,
            pos.col,
            pos.index,
            res.position.index,
            None
          ),
          ...tokens
        ]
        pos = res.position
      },
      '\'' => {
        let res = readChar(advancePosition(pos, ch))
        let chr = match (res.value) {
          CharVal(c) => c,
          _ => {
            let span = Source.makeSpan(pos.line, pos.col, pos.index, res.position.index)
            Error.createPanicError(Error.Lexing, span, "Invalid character literal", [Error.Note("internal error: expected character value from char reader")])
          },
        }
        tokens = [
          makeToken(
            LitChar(chr),
            pos.line,
            pos.col,
            pos.index,
            res.position.index,
            None
          ),
          ...tokens
        ]
        pos = res.position
      },
      ch => { //Var(ch)
        match (ch) {
          '(' => {
            tokens = [
              makeToken(
                LParen,
                pos.line,
                pos.col,
                pos.index,
                pos.index + 1,
                None
              ),
              ...tokens
            ]
            parenStack = [pos.index, ...parenStack]
            pos = advancePosition(pos, ch)
          },
          ')' => {
            let mateIndex = List.head(parenStack)
            parenStack = match (mateIndex) {
              Some(_) =>
                match (List.tail(parenStack)) {
                  Some(tail) => tail,
                  None => parenStack,
                },
              None => parenStack,
            }
            tokens = [
              makeToken(
                RParen,
                pos.line,
                pos.col,
                pos.index,
                pos.index + 1,
                mateIndex
              ),
              ...tokens
            ]
            pos = advancePosition(pos, ch)
          },
          '{' => {
            tokens = [
              makeToken(
                LBrace,
                pos.line,
                pos.col,
                pos.index,
                pos.index + 1,
                None
              ),
              ...tokens
            ]
            braceStack = [pos.index, ...braceStack]
            pos = advancePosition(pos, ch)
          },
          '}' => {
            let mateIndex = List.head(braceStack)
            braceStack = match (mateIndex) {
              Some(_) =>
                match (List.tail(braceStack)) {
                  Some(tail) => tail,
                  None => braceStack,
                },
              None => braceStack,
            }
            tokens = [
              makeToken(
                RBrace,
                pos.line,
                pos.col,
                pos.index,
                pos.index + 1,
                mateIndex
              ),
              ...tokens
            ]
            pos = advancePosition(pos, ch)
          },
          '?' => {
            tokens = [
              makeToken(
                Question,
                pos.line,
                pos.col,
                pos.index,
                pos.index + 1,
                None
              ),
              ...tokens
            ]
            pos = advancePosition(pos, ch)
          },
          ';' => {
            tokens = [
              makeToken(
                SemiColon,
                pos.line,
                pos.col,
                pos.index,
                pos.index + 1,
                None
              ),
              ...tokens
            ]
            pos = advancePosition(pos, ch)
          },
          ':' => {
            match (peek(pos.index + 1)) {
              Some('>') => {
                tokens = [
                  makeToken(
                    PipeArrow,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 2,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(advancePosition(pos, ch), '>')
              },
              _ => {
                tokens = [
                  makeToken(
                    Colon,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 1,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(pos, ch)
              },
            }
          },
          ',' => {
            tokens = [
              makeToken(
                Comma,
                pos.line,
                pos.col,
                pos.index,
                pos.index + 1,
                None
              ),
              ...tokens
            ]
            pos = advancePosition(pos, ch)
          },
          '>' => {
            tokens = [
              makeToken(
                Arrow,
                pos.line,
                pos.col,
                pos.index,
                pos.index + 1,
                None
              ),
              ...tokens
            ]
            pos = advancePosition(pos, ch)
          },
          //len2
          '|' => {
            match (peek(pos.index + 1)) {
              Some('-') => {
                tokens = [
                  makeToken(
                    DPipe,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 2,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(advancePosition(pos, ch), '-')
              },
              _ => {
                tokens = [
                  makeToken(
                    Pipe,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 1,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(pos, ch)
              },
            }
          },
          '-' => {
            match (peek(pos.index + 1)) {
              Some('-') => {
                tokens = [
                  makeToken(
                    DDash,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 2,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(advancePosition(pos, ch), '-')
              },
              _ => {
                tokens = [
                  makeToken(
                    Dash,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 1,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(pos, ch)
              },
            }
          },
          '.' => {
            match (peek(pos.index + 1)) {
              Some('{') => {
                tokens = [
                  makeToken(
                    DotBrace,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 2,
                    None
                  ),
                  ...tokens
                ]
                braceStack = [pos.index, ...braceStack]
                pos = advancePosition(advancePosition(pos, ch), '{')
              },
              Some('.') => {
                tokens = [
                  makeToken(
                    DPeriod,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 2,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(advancePosition(pos, ch), '.')
              },
              _ => {
                tokens = [
                  makeToken(
                    Period,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 1,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(pos, ch)
              },
            }
          },
          '+' => {
            match (peek(pos.index + 1)) {
              Some('+') => {
                tokens = [
                  makeToken(
                    DPlus,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 2,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(advancePosition(pos, ch), '+')
              },
              _ => {
                tokens = [
                  makeToken(
                    Plus,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 1,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(pos, ch)
              },
            }
          },
          '=' => {
            match (peek(pos.index + 1)) {
              Some('>') => {
                tokens = [
                  makeToken(
                    FatArrow,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 2,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(advancePosition(pos, ch), '>')
              },
              Some('=') => {
                tokens = [
                  makeToken(
                    EqEq,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 2,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(advancePosition(pos, ch), '=')
              },
              _ => {
                tokens = [
                  makeToken(
                    Eq,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 1,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(pos, ch)
              },
            }
          },
          '/' => {
            match (peek(pos.index + 1)) {
              Some('/') => {
                let rec skipLine = (p: Position) => {
                  match (peek(p.index)) {
                    None => p,
                    Some('\n') => p,
                    Some(c) => skipLine(advancePosition(p, c)),
                  }
                }
                let afterSlashes = advancePosition(
                  advancePosition(pos, ch),
                  '/'
                )
                let endPos = skipLine(afterSlashes)
                let commentText = String.slice(pos.index, end=endPos.index, source)
                tokens = [
                  makeToken(
                    LineComment(commentText),
                    pos.line,
                    pos.col,
                    pos.index,
                    endPos.index,
                    None
                  ),
                  ...tokens
                ]
                pos = endPos
              },
              _ => {
                tokens = [
                  makeToken(
                    Slash,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 1,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(pos, ch)
              },
            }
          },
          _ => {
            let span = Source.makeSpan(pos.line, pos.col, pos.index, pos.index + 1)
            Error.createPanicError(
              Error.Lexing,
              span,
              "Unknown token",
              [Error.Received(Char.toString(ch)), Error.Hint("check for invalid characters or syntax errors")]
            )
          },
        }
      },
    }
  }
  tokens = [
    makeToken(EOF, pos.line, pos.col, pos.index, pos.index, None),
    ...tokens
  ]
  List.reverse(tokens)
}

// print(lex(testStr))
