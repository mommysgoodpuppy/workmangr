module Lexer

from "char" include Char
from "string" include String
from "array" include Array
from "bytes" include Bytes
from "uint8" include Uint8
from "number" include Number
from "option" include Option
from "list" include List
from "wasi/time" include Time
from "int64" include Int64
from "runtime/unsafe/panic" include Panic
use Panic.{ panic }
from "../util.gr" include Util

from "../core/source.gr" include Source
from "../core/error.gr" include Error

provide enum TokenKind {
  //special keywords
  KwVar, // Var
  KwAllErrors, // AllErrors
  //literals
  Wildcard, // _
  LitName(String), // strs
  ConstructorTok(String), // Strs
  LitNum(Number), //138510
  LitString(String), // "*"
  LitChar(Char), // '*'
  LitBool(Bool), // true false
  //symbols
  LParen, // (
  RParen, // )
  LBrace, // {
  RBrace, // }
  FatArrow, // =>
  Question, // ?
  Pipe, // |
  DPipe, // ||
  SemiColon, // ;
  Comma, // ,
  Colon, // :
  PipeArrow, // :>
  Slash, // /
  DSlash, // //
  LineComment(String), // //...
  Opaque(String), // unknown text
  Arrow, // >
  Period, // .
  DotBrace, // .{
  DPeriod, // ..
  //operators
  Eq, // =
  EqEq, // ==
  Plus, // +
  DPlus, // ++
  Dash, // -
  DDash, // --
  //other
  Directive, // @stuff;
  EOF, // eof
}

//the base token type
provide record Token {
  kind: TokenKind,
  span: Source.Span,
  mate: Option<Number>, //index
}

provide let tokenKindToString = kind => match (kind) {
  KwVar => "Var",
  KwAllErrors => "AllErrors",
  Wildcard => "_",
  LitName(name) => name,
  ConstructorTok(name) => name,
  LitNum(num) => "<number>",
  LitString(str) => "\"" ++ str ++ "\"",
  LitChar(ch) => "'" ++ Char.toString(ch) ++ "'",
  LitBool(b) => if (b) {
    "true"
  } else {
    "false"
  },
  LParen => "(",
  RParen => ")",
  LBrace => "{",
  RBrace => "}",
  FatArrow => "=>",
  Question => "?",
  Pipe => "|",
  DPipe => "||",
  SemiColon => ";",
  Comma => ",",
  Colon => ":",
  PipeArrow => ":>",
  Slash => "/",
  DSlash => "//",
  LineComment(text) => text,
  Opaque(text) => text,
  Arrow => ">",
  Period => ".",
  DotBrace => ".{",
  DPeriod => "..",
  Eq => "=",
  EqEq => "==",
  Plus => "+",
  DPlus => "++",
  Dash => "-",
  DDash => "--",
  Directive => "@",
  EOF => "EOF",
}

enum ReadValue {
  StringVal(String),
  NumVal(Number),
  CharVal(Char),
}

record Position {
  index: Number,
  line: Number,
  col: Number,
}

record ReadResult {
  value: ReadValue,
  position: Position,
}

let nowNs = () =>
  match (Time.monotonicTime()) {
    Ok(t) => t,
    Err(_) => 0L,
  }

let nsDelta = (startNs: Int64, endNs: Int64) =>
  Int64.toNumber(endNs) - Int64.toNumber(startNs)

let nsToMsString = (ns: Number) => {
  toString(Number.trunc(ns / 1000000))
}

let lexInternal = (source, profiling: Bool) => {
  let totalStart = if (profiling) { nowNs() } else { 0L }
  let mut tWhitespaceNs = 0.0
  let mut tNameNs = 0.0
  let mut tNumberNs = 0.0
  let mut tStringNs = 0.0
  let mut tCharNs = 0.0
  let mut tSymbolNs = 0.0
  let mut tCommentNs = 0.0
  let mut tOpaqueNs = 0.0
  let mut cWhitespace = 0
  let mut cName = 0
  let mut cNumber = 0
  let mut cString = 0
  let mut cChar = 0
  let mut cSymbol = 0
  let mut cComment = 0
  let mut cOpaque = 0

  // Build byte view once and require ASCII source in this lexer implementation.
  let sourceBytes = Bytes.fromString(source)
  let sourceByteLen = Bytes.length(sourceBytes)
  let mut bi = 0
  let mut hasNonAscii = false
  while (bi < sourceByteLen) {
    if (Uint8.toNumber(Bytes.getUint8(bi, sourceBytes)) > 127) {
      hasNonAscii = true
      bi = sourceByteLen
    } else {
      bi += 1
    }
  }
  if (hasNonAscii) {
    panic("Lexer currently supports ASCII source only")
  }

  // source length in character offsets used by spans (ASCII => bytes == chars)
  let lenght = sourceByteLen

  let mut parenStack = []
  let mut braceStack = []
  let peek = index => {
    if (index < 0 || index >= lenght) {
      None
    } else {
      Some(Char.fromCode(Uint8.toNumber(Bytes.getUint8(index, sourceBytes))))
    }
  }

  // advance position based on character
  let advancePosition = (pos: Position, ch: Char) => {
    let newIndex = pos.index + 1
    let newLine = if (ch == '\n') {
      pos.line + 1
    } else {
      pos.line
    }
    let newCol = if (ch == '\n') {
      1
    } else {
      pos.col + 1
    }
    { index: newIndex, line: newLine, col: newCol }
  }

  // continue until not whitespace
  let skipWhitespace = position => {
    let mut idx = position.index
    let mut line = position.line
    let mut col = position.col
    while (idx < lenght) {
      match (peek(idx)) {
        Some(ch) when Char.Ascii.isWhitespace(ch) => {
          idx += 1
          if (ch == '\n') {
            line += 1
            col = 1
          } else {
            col += 1
          }
        },
        _ => break,
      }
    }
    { index: idx, line, col }
  }

  // name start
  let isAsciiDigit = (ch: Char) => {
    let code = Char.code(ch)
    code >= 48 && code <= 57
  }

  let isAsciiAlpha = (ch: Char) => {
    let code = Char.code(ch)
    (code >= 97 && code <= 122) || (code >= 65 && code <= 90)
  }

  let isAsciiWhitespace = (ch: Char) => {
    ch == ' ' || ch == '\n' || ch == '\r' || ch == '\t'
  }

  let isNameStart = (ch: Char) => {
    isAsciiAlpha(ch) || ch == '_'
  }

  // check if uppercase
  let isUpper = (ch: Char) => {
    let code = Char.code(ch)
    code >= Char.code('A') && code <= Char.code('Z')
  }

  //read a name to end
  let readName = (startPosition: Position) => {
    // name cont
    let isNameContinue = (ch: Char) => {
      isNameStart(ch) || Char.Ascii.isDigit(ch)
    }

    let mut endIndex = startPosition.index
    while (endIndex < lenght) {
      let ch = Char.fromCode(Uint8.toNumber(Bytes.getUint8(endIndex, sourceBytes)))
      if (isNameContinue(ch)) {
        endIndex += 1
      } else {
        break
      }
    }
    let name = String.slice(startPosition.index, end=endIndex, source)
    {
      value: StringVal(name),
      position: {
        index: endIndex,
        line: startPosition.line,
        col: startPosition.col + (endIndex - startPosition.index),
      },
    }
  }

  //read a number to end
  let readNumber = (startPosition: Position) => {
    // number
    let digitValue = (ch: Char) => {
      Char.code(ch) - Char.code('0')
    }

    let mut idx = startPosition.index
    let mut acc = 0
    while (idx < lenght) {
      let ch = Char.fromCode(Uint8.toNumber(Bytes.getUint8(idx, sourceBytes)))
      if (Char.Ascii.isDigit(ch)) {
        acc = acc * 10 + digitValue(ch)
        idx += 1
      } else {
        break
      }
    }
    {
      value: NumVal(acc),
      position: {
        index: idx,
        line: startPosition.line,
        col: startPosition.col + (idx - startPosition.index),
      },
    }
  }

  //read string to end
  let readString = (startPosition: Position) => {
    let rec loop = (currentPos: Position, chunks: List<String>) => {
      match (peek(currentPos.index)) {
        Some(ch) => {
          if (ch == '"') {
            // end of string
            let value = Array.join("", Array.fromList(List.reverse(chunks)))
            { value: StringVal(value), position: advancePosition(currentPos, ch) }
          } else if (ch == '\\') {
            // escape sequence
            match (peek(currentPos.index + 1)) {
              Some(nextCh) => {
                let escaped = if (nextCh == '"') {
                  "\""
                } else if (nextCh == '\\') {
                  "\\"
                } else if (nextCh == 'n') {
                  "\n"
                } else if (nextCh == 't') {
                  "\t"
                } else if (nextCh == 'r') {
                  "\r"
                } else {
                  String.slice(
                    currentPos.index + 1,
                    end=currentPos.index + 2,
                    source
                  ) // treat as literal
                }
                let newPos = advancePosition(
                  advancePosition(currentPos, ch),
                  nextCh
                )
                loop(newPos, [escaped, ...chunks])
              },
              None => {
                let span = Source.makeSpan(startPosition.line, startPosition.col, startPosition.index, currentPos.index)
                Error.createPanicError(Error.Lexing, span, "Unclosed escape sequence in string", [Error.Note("check for matching quotes and valid escape sequences")])
              },
            }
          } else {
            let charStr = String.slice(
              currentPos.index,
              end=currentPos.index + 1,
              source
            )
            let newPos = advancePosition(currentPos, ch)
            loop(newPos, [charStr, ...chunks])
          }
        },
        None => {
          let span = Source.makeSpan(startPosition.line, startPosition.col, startPosition.index, currentPos.index)
          Error.createPanicError(Error.Lexing, span, "Unclosed string literal", [Error.Expected("closing quote")])
        },
      }
    }
    loop(startPosition, [])
  }

  //read char to end
  let readChar = (startPosition: Position) => {
    match (peek(startPosition.index)) {
      Some(ch) => {
        if (ch == '\'') {
          let span = Source.makeSpan(startPosition.line, startPosition.col, startPosition.index, startPosition.index + 1)
          Error.createPanicError(Error.Lexing, span, "Empty character literal", [Error.Note("character literals must contain exactly one character")])
        } else {
          let char = ch
          let afterChar = advancePosition(startPosition, ch)
          match (peek(afterChar.index)) {
            Some('\'') => {
              {
                value: CharVal(char),
                position: advancePosition(afterChar, '\''),
              }
            },
            _ => {
              let span = Source.makeSpan(startPosition.line, startPosition.col, startPosition.index, afterChar.index)
              Error.createPanicError(Error.Lexing, span, "Unclosed character literal", [Error.Expected("closing single quote")])
            },
          }
        }
      },
      None => {
        let span = Source.makeSpan(startPosition.line, startPosition.col, startPosition.index, startPosition.index)
        Error.createPanicError(Error.Lexing, span, "Unclosed character literal", [Error.Expected("character and closing quote")])
      },
    }
  }

  // determine token kind from name
  let tokenKindFromName = (name: String) => {
    match (name) {
      "Var" => KwVar,
      "AllErrors" => KwAllErrors,
      "_" => Wildcard,
      "true" => LitBool(true),
      "false" => LitBool(false),
      _ => {
        if (isUpper(String.charAt(0, name))) {
          ConstructorTok(name)
        } else {
          LitName(name)
        }
      },
    }
  }

  //create a Token
  let makeToken = (kind: TokenKind, line, col, start, end, mate) =>
    { kind, span: Source.makeSpan(line, col, start, end), mate }
  let mut tokens = []
  let mut pos = { index: 0, line: 1, col: 1 }
  while (pos.index < lenght) {
    if (profiling) {
      let t0 = nowNs()
      let mut idx = pos.index
      let mut line = pos.line
      let mut col = pos.col
      while (idx < lenght) {
        let ch = Char.fromCode(Uint8.toNumber(Bytes.getUint8(idx, sourceBytes)))
        if (isAsciiWhitespace(ch)) {
          idx += 1
          if (ch == '\n') {
            line += 1
            col = 1
          } else {
            col += 1
          }
        } else {
          break
        }
      }
      pos = { index: idx, line, col }
      let t1 = nowNs()
      tWhitespaceNs += nsDelta(t0, t1)
      cWhitespace += 1
    } else {
      let mut idx = pos.index
      let mut line = pos.line
      let mut col = pos.col
      while (idx < lenght) {
        let ch = Char.fromCode(Uint8.toNumber(Bytes.getUint8(idx, sourceBytes)))
        if (isAsciiWhitespace(ch)) {
          idx += 1
          if (ch == '\n') {
            line += 1
            col = 1
          } else {
            col += 1
          }
        } else {
          break
        }
      }
      pos = { index: idx, line, col }
    }
    if (pos.index >= lenght) break
    let ch = Char.fromCode(Uint8.toNumber(Bytes.getUint8(pos.index, sourceBytes)))
    match (ch) {
      ch when isNameStart(ch) => {
        let t0 = if (profiling) { nowNs() } else { 0L }
        let mut endIndex = pos.index
        while (endIndex < lenght) {
          let ch = Char.fromCode(Uint8.toNumber(Bytes.getUint8(endIndex, sourceBytes)))
          if (isNameStart(ch) || isAsciiDigit(ch)) {
            endIndex += 1
          } else {
            break
          }
        }
        let ident = String.slice(pos.index, end=endIndex, source)
        let newPos = {
          index: endIndex,
          line: pos.line,
          col: pos.col + (endIndex - pos.index),
        }
        if (profiling) {
          let t1 = nowNs()
          tNameNs += nsDelta(t0, t1)
          cName += 1
        }
        let kind = tokenKindFromName(ident)
        tokens = [
          makeToken(
            kind,
            pos.line,
            pos.col,
            pos.index,
            endIndex,
            None
          ),
          ...tokens
        ]
        pos = newPos
      },
      ch when isAsciiDigit(ch) => {
        let t0 = if (profiling) { nowNs() } else { 0L }
        let mut idx = pos.index
        let mut val = 0
        while (idx < lenght) {
          let ch = Char.fromCode(Uint8.toNumber(Bytes.getUint8(idx, sourceBytes)))
          if (isAsciiDigit(ch)) {
            val = val * 10 + (Char.code(ch) - 48)
            idx += 1
          } else {
            break
          }
        }
        let newPos = {
          index: idx,
          line: pos.line,
          col: pos.col + (idx - pos.index),
        }
        if (profiling) {
          let t1 = nowNs()
          tNumberNs += nsDelta(t0, t1)
          cNumber += 1
        }
        tokens = [
          makeToken(
            LitNum(val),
            pos.line,
            pos.col,
            pos.index,
            idx,
            None
          ),
          ...tokens
        ]
        pos = newPos
      },
      '"' => {
        let t0 = if (profiling) { nowNs() } else { 0L }
        let res = readString(advancePosition(pos, ch))
        if (profiling) {
          let t1 = nowNs()
          tStringNs += nsDelta(t0, t1)
          cString += 1
        }
        let str = match (res.value) {
          StringVal(s) => s,
          _ => {
            let span = Source.makeSpan(pos.line, pos.col, pos.index, res.position.index)
            Error.createPanicError(Error.Lexing, span, "Invalid string literal", [Error.Note("internal error: expected string value from string reader")])
          },
        }
        tokens = [
          makeToken(
            LitString(str),
            pos.line,
            pos.col,
            pos.index,
            res.position.index,
            None
          ),
          ...tokens
        ]
        pos = res.position
      },
      '\'' => {
        let t0 = if (profiling) { nowNs() } else { 0L }
        let res = readChar(advancePosition(pos, ch))
        if (profiling) {
          let t1 = nowNs()
          tCharNs += nsDelta(t0, t1)
          cChar += 1
        }
        let chr = match (res.value) {
          CharVal(c) => c,
          _ => {
            let span = Source.makeSpan(pos.line, pos.col, pos.index, res.position.index)
            Error.createPanicError(Error.Lexing, span, "Invalid character literal", [Error.Note("internal error: expected character value from char reader")])
          },
        }
        tokens = [
          makeToken(
            LitChar(chr),
            pos.line,
            pos.col,
            pos.index,
            res.position.index,
            None
          ),
          ...tokens
        ]
        pos = res.position
      },
      ch => { //Var(ch)
        let t0 = if (profiling) { nowNs() } else { 0L }
        match (ch) {
          '(' => {
            tokens = [
              makeToken(
                LParen,
                pos.line,
                pos.col,
                pos.index,
                pos.index + 1,
                None
              ),
              ...tokens
            ]
            parenStack = [pos.index, ...parenStack]
            pos = advancePosition(pos, ch)
          },
          ')' => {
            let mateIndex = List.head(parenStack)
            parenStack = match (mateIndex) {
              Some(_) =>
                match (List.tail(parenStack)) {
                  Some(tail) => tail,
                  None => parenStack,
                },
              None => parenStack,
            }
            tokens = [
              makeToken(
                RParen,
                pos.line,
                pos.col,
                pos.index,
                pos.index + 1,
                mateIndex
              ),
              ...tokens
            ]
            pos = advancePosition(pos, ch)
          },
          '{' => {
            tokens = [
              makeToken(
                LBrace,
                pos.line,
                pos.col,
                pos.index,
                pos.index + 1,
                None
              ),
              ...tokens
            ]
            braceStack = [pos.index, ...braceStack]
            pos = advancePosition(pos, ch)
          },
          '}' => {
            let mateIndex = List.head(braceStack)
            braceStack = match (mateIndex) {
              Some(_) =>
                match (List.tail(braceStack)) {
                  Some(tail) => tail,
                  None => braceStack,
                },
              None => braceStack,
            }
            tokens = [
              makeToken(
                RBrace,
                pos.line,
                pos.col,
                pos.index,
                pos.index + 1,
                mateIndex
              ),
              ...tokens
            ]
            pos = advancePosition(pos, ch)
          },
          '?' => {
            tokens = [
              makeToken(
                Question,
                pos.line,
                pos.col,
                pos.index,
                pos.index + 1,
                None
              ),
              ...tokens
            ]
            pos = advancePosition(pos, ch)
          },
          ';' => {
            tokens = [
              makeToken(
                SemiColon,
                pos.line,
                pos.col,
                pos.index,
                pos.index + 1,
                None
              ),
              ...tokens
            ]
            pos = advancePosition(pos, ch)
          },
          ':' => {
            match (peek(pos.index + 1)) {
              Some('>') => {
                tokens = [
                  makeToken(
                    PipeArrow,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 2,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(advancePosition(pos, ch), '>')
              },
              _ => {
                tokens = [
                  makeToken(
                    Colon,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 1,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(pos, ch)
              },
            }
          },
          ',' => {
            tokens = [
              makeToken(
                Comma,
                pos.line,
                pos.col,
                pos.index,
                pos.index + 1,
                None
              ),
              ...tokens
            ]
            pos = advancePosition(pos, ch)
          },
          '>' => {
            tokens = [
              makeToken(
                Arrow,
                pos.line,
                pos.col,
                pos.index,
                pos.index + 1,
                None
              ),
              ...tokens
            ]
            pos = advancePosition(pos, ch)
          },
          //len2
          '|' => {
            match (peek(pos.index + 1)) {
              Some('-') => {
                tokens = [
                  makeToken(
                    DPipe,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 2,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(advancePosition(pos, ch), '-')
              },
              _ => {
                tokens = [
                  makeToken(
                    Pipe,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 1,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(pos, ch)
              },
            }
          },
          '-' => {
            match (peek(pos.index + 1)) {
              Some('-') => {
                tokens = [
                  makeToken(
                    DDash,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 2,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(advancePosition(pos, ch), '-')
              },
              _ => {
                tokens = [
                  makeToken(
                    Dash,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 1,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(pos, ch)
              },
            }
          },
          '.' => {
            match (peek(pos.index + 1)) {
              Some('{') => {
                tokens = [
                  makeToken(
                    DotBrace,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 2,
                    None
                  ),
                  ...tokens
                ]
                braceStack = [pos.index, ...braceStack]
                pos = advancePosition(advancePosition(pos, ch), '{')
              },
              Some('.') => {
                tokens = [
                  makeToken(
                    DPeriod,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 2,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(advancePosition(pos, ch), '.')
              },
              _ => {
                tokens = [
                  makeToken(
                    Period,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 1,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(pos, ch)
              },
            }
          },
          '+' => {
            match (peek(pos.index + 1)) {
              Some('+') => {
                tokens = [
                  makeToken(
                    DPlus,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 2,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(advancePosition(pos, ch), '+')
              },
              _ => {
                tokens = [
                  makeToken(
                    Plus,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 1,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(pos, ch)
              },
            }
          },
          '=' => {
            match (peek(pos.index + 1)) {
              Some('>') => {
                tokens = [
                  makeToken(
                    FatArrow,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 2,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(advancePosition(pos, ch), '>')
              },
              Some('=') => {
                tokens = [
                  makeToken(
                    EqEq,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 2,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(advancePosition(pos, ch), '=')
              },
              _ => {
                tokens = [
                  makeToken(
                    Eq,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 1,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(pos, ch)
              },
            }
          },
          '/' => {
            match (peek(pos.index + 1)) {
              Some('/') => {
                let commentStart = if (profiling) { nowNs() } else { 0L }
                let afterSlashes = advancePosition(
                  advancePosition(pos, ch),
                  '/'
                )
                let mut endPos = afterSlashes
                while (endPos.index < lenght) {
                  let c = Char.fromCode(Uint8.toNumber(Bytes.getUint8(endPos.index, sourceBytes)))
                  if (c == '\n') {
                    break
                  }
                  endPos = advancePosition(endPos, c)
                }
                let commentText = String.slice(pos.index, end=endPos.index, source)
                tokens = [
                  makeToken(
                    LineComment(commentText),
                    pos.line,
                    pos.col,
                    pos.index,
                    endPos.index,
                    None
                  ),
                  ...tokens
                ]
                pos = endPos
                if (profiling) {
                  let commentEnd = nowNs()
                  tCommentNs += nsDelta(commentStart, commentEnd)
                  cComment += 1
                }
              },
              _ => {
                tokens = [
                  makeToken(
                    Slash,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 1,
                    None
                  ),
                  ...tokens
                ]
                pos = advancePosition(pos, ch)
              },
            }
          },
          _ => {
            let opaqueStart = if (profiling) { nowNs() } else { 0L }
            let startIndex = pos.index
            let mut endPos = pos
            while (true) {
              let nextChar = peek(endPos.index)
              match (nextChar) {
                None => break,
                Some('\n') => break,
                _ => {
                  endPos = advancePosition(
                    endPos,
                    Char.fromCode(Uint8.toNumber(Bytes.getUint8(endPos.index, sourceBytes)))
                  )
                },
              }
            }
            let text = String.slice(startIndex, end=endPos.index, source)
            tokens = [
              makeToken(
                Opaque(text),
                pos.line,
                pos.col,
                startIndex,
                endPos.index,
                None
              ),
              ...tokens
            ]
            pos = endPos
            if (profiling) {
              let opaqueEnd = nowNs()
              tOpaqueNs += nsDelta(opaqueStart, opaqueEnd)
              cOpaque += 1
            }
          },
        }
        if (profiling) {
          let t1 = nowNs()
          tSymbolNs += nsDelta(t0, t1)
          cSymbol += 1
        }
      },
    }
  }
  tokens = [
    makeToken(EOF, pos.line, pos.col, pos.index, pos.index, None),
    ...tokens
  ]
  let out = List.reverse(tokens)
  if (profiling) {
    let totalEnd = nowNs()
    let totalNs = nsDelta(totalStart, totalEnd)
    print("[LexerTiming] input length: " ++ toString(lenght))
    print("[LexerTiming] total: " ++ nsToMsString(totalNs) ++ "ms")
    print(
      "[LexerTiming] whitespace: "
        ++ nsToMsString(tWhitespaceNs)
        ++ "ms (calls="
        ++ toString(cWhitespace)
        ++ ")"
    )
    print(
      "[LexerTiming] names: "
        ++ nsToMsString(tNameNs)
        ++ "ms (tokens="
        ++ toString(cName)
        ++ ")"
    )
    print(
      "[LexerTiming] numbers: "
        ++ nsToMsString(tNumberNs)
        ++ "ms (tokens="
        ++ toString(cNumber)
        ++ ")"
    )
    print(
      "[LexerTiming] strings: "
        ++ nsToMsString(tStringNs)
        ++ "ms (tokens="
        ++ toString(cString)
        ++ ")"
    )
    print(
      "[LexerTiming] chars: "
        ++ nsToMsString(tCharNs)
        ++ "ms (tokens="
        ++ toString(cChar)
        ++ ")"
    )
    print(
      "[LexerTiming] symbols_total: "
        ++ nsToMsString(tSymbolNs)
        ++ "ms (dispatches="
        ++ toString(cSymbol)
        ++ ")"
    )
    print(
      "[LexerTiming] comments: "
        ++ nsToMsString(tCommentNs)
        ++ "ms (tokens="
        ++ toString(cComment)
        ++ ")"
    )
    print(
      "[LexerTiming] opaque: "
        ++ nsToMsString(tOpaqueNs)
        ++ "ms (tokens="
        ++ toString(cOpaque)
        ++ ")"
    )
    print("[LexerTiming] token count: " ++ toString(List.length(out)))
  }
  out
}

// lexer without profiling logs
provide let lex = source => lexInternal(source, false)

// lexer with phase timing logs
provide let lexProfile = source => lexInternal(source, true)
