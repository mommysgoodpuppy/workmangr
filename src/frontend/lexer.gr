module Lexer

from "char" include Char
from "string" include String
from "option" include Option
from "runtime/unsafe/panic" include Panic
from "../util.gr" include Util
use Util.{ testStr }

use Panic.{ panic }

from "../core/source.gr" include Source

provide enum TokenKind {
  LetKw, // let
  NameTok(String),
  IntTok(Number),
  StringTok(String), // "*"
  QuoteTok(Char), // '*'
  LParen, // (
  RParen, // )
  LBrace, // {
  RBrace, // }
  Eq, // =
  FatArrow, // =>
  Question, // ?
  Pipe, // |
  SemiColon, // ;
  Comma, // ,
  Colon, // :
  Slash, // /
  DSlash, // //
  EOF, // eof
}

//the base token type
provide record Token {
  kind: TokenKind,
  span: Source.Span,
}

enum ReadValue {
  StringVal(String),
  NumVal(Number),
}

record Position {
  index: Number,
  line: Number,
  col: Number,
}

record ReadResult {
  value: ReadValue,
  position: Position,
}

//lexer function
provide let lex = source => {

  //source lenght
  let lenght = String.length(source)

  //peek a token
  let peek = index => {
    if (index < 0 || index >= lenght) {
      None
    } else {
      Some(String.charAt(index, source))
    }
  }

  // advance position based on character
  let advancePosition = (pos: Position, ch: Char) => {
    let newIndex = pos.index + 1
    let newLine = if (ch == '\n') {
      pos.line + 1
    } else {
      pos.line
    }
    let newCol = if (ch == '\n') {
      1
    } else {
      pos.col + 1
    }
    { index: newIndex, line: newLine, col: newCol }
  }

  // continue until not whitespace
  let rec skipWhitespace = position => {
    match (peek(position.index)) {
      Some(ch) => {
        if (Char.Ascii.isWhitespace(ch)) {
          let newPos = advancePosition(position, ch)
          skipWhitespace(newPos)
        } else {
          position
        }
      },
      None => {
        position
      },
    }
  }

  // name start
  let isNameStart = (ch: Char) => {
    Char.Ascii.isAlpha(ch) || ch == '_'
  }

  //read a name to end
  let readName = (startPosition: Position) => {
    // name cont
    let isNameContinue = (ch: Char) => {
      isNameStart(ch) || Char.Ascii.isDigit(ch)
    }

    let rec loop = (currentPos: Position) => {
      match (peek(currentPos.index)) {
        Some(ch) => {
          if (isNameContinue(ch)) {
            let newPos = advancePosition(currentPos, ch)
            loop(newPos)
          } else {
            currentPos
          }
        },
        _ => currentPos,
      }
    }
    let endPos = loop(startPosition)
    let name = String.slice(startPosition.index, end=endPos.index, source)
    { value: StringVal(name), position: endPos }
  }

  //read a number to end
  let readNumber = (startPosition: Position) => {
    // number
    let digitValue = (ch: Char) => {
      Char.code(ch) - Char.code('0')
    }

    let firstCh = String.charAt(startPosition.index, source)
    let initialAcc = digitValue(firstCh)

    let rec loop = (currentPos: Position, acc: Number) => {
      match (peek(currentPos.index)) {
        Some(ch) => {
          if (Char.Ascii.isDigit(ch)) {
            let newAcc = acc * 10 + digitValue(ch)
            let newPos = advancePosition(currentPos, ch)
            loop(newPos, newAcc)
          } else {
            { value: NumVal(acc), position: currentPos }
          }
        },
        _ => { value: NumVal(acc), position: currentPos },
      }
    }
    let startAfterFirst = advancePosition(startPosition, firstCh)
    loop(startAfterFirst, initialAcc)
  }

  //read string to end
  let readString = (startPosition: Position) => {
    let rec loop = (currentPos: Position, acc: String) => {
      match (peek(currentPos.index)) {
        Some(ch) => {
          if (ch == '"') {
            // end of string
            { value: StringVal(acc), position: advancePosition(currentPos, ch) }
          } else if (ch == '\\') {
            // escape sequence
            match (peek(currentPos.index + 1)) {
              Some(nextCh) => {
                let escaped = if (nextCh == '"') {
                  "\""
                } else if (nextCh == '\\') {
                  "\\"
                } else if (nextCh == 'n') {
                  "\n"
                } else if (nextCh == 't') {
                  "\t"
                } else if (nextCh == 'r') {
                  "\r"
                } else {
                  String.slice(
                    currentPos.index + 1,
                    end=currentPos.index + 2,
                    source
                  ) // treat as literal
                }
                let newAcc = acc ++ escaped
                let newPos = advancePosition(
                  advancePosition(currentPos, ch),
                  nextCh
                )
                loop(newPos, newAcc)
              },
              None => panic("Unclosed escape sequence"),
            }
          } else {
            let charStr = String.slice(
              currentPos.index,
              end=currentPos.index + 1,
              source
            )
            let newAcc = acc ++ charStr
            let newPos = advancePosition(currentPos, ch)
            loop(newPos, newAcc)
          }
        },
        None => panic("Unclosed string literal"),
      }
    }
    loop(startPosition, "")
  }

  //create a Token
  let makeToken = (kind: TokenKind, line, col, start, end) =>
    { kind, span: Source.makeSpan(line, col, start, end) }

  let rec loop = (position: Position) => {
    let pos = skipWhitespace(position)

    let val = if (pos.index >= lenght) {
      [makeToken(EOF, pos.line, pos.col, pos.index, pos.index)]
    } else {
      let ch = String.charAt(pos.index, source)

      match (ch) {
        ch when isNameStart(ch) => {
          let res = readName(pos)
          let kind = if (res.value == StringVal("let")) {
            LetKw
          } else {
            match (res.value) {
              StringVal(ident) => {
                NameTok(ident)
              },
              _ => {
                panic("WTF")
              },
            }
          }
          [
            makeToken(kind, pos.line, pos.col, pos.index, res.position.index),
            ...loop(res.position)
          ]
        },
        ch when Char.Ascii.isDigit(ch) => {
          let res = readNumber(pos)
          let val = match (res.value) {
            NumVal(ident) => {
              ident
            },
            _ => {
              panic("WTF")
            },
          }
          [
            makeToken(
              IntTok(val),
              pos.line,
              pos.col,
              pos.index,
              res.position.index
            ),
            ...loop(res.position)
          ]
        },
        '"' => {
          let res = readString(advancePosition(pos, ch))
          let str = match (res.value) {
            StringVal(s) => s,
            _ => panic("Unexpected value type"),
          }
          [
            makeToken(
              StringTok(str),
              pos.line,
              pos.col,
              pos.index,
              res.position.index
            ),
            ...loop(res.position)
          ]
        },
        ch => { //Var(ch)
          match (ch) {
            '(' =>
              [
                makeToken(LParen, pos.line, pos.col, pos.index, pos.index + 1),
                ...loop(advancePosition(pos, ch))
              ],
            ')' =>
              [
                makeToken(RParen, pos.line, pos.col, pos.index, pos.index + 1),
                ...loop(advancePosition(pos, ch))
              ],
            '{' =>
              [
                makeToken(LBrace, pos.line, pos.col, pos.index, pos.index + 1),
                ...loop(advancePosition(pos, ch))
              ],
            '}' =>
              [
                makeToken(RBrace, pos.line, pos.col, pos.index, pos.index + 1),
                ...loop(advancePosition(pos, ch))
              ],
            '?' =>
              [
                makeToken(Question, pos.line, pos.col, pos.index, pos.index + 1),
                ...loop(advancePosition(pos, ch))
              ],
            '|' =>
              [
                makeToken(Pipe, pos.line, pos.col, pos.index, pos.index + 1),
                ...loop(advancePosition(pos, ch))
              ],
            ';' => 
              [
                makeToken(SemiColon, pos.line, pos.col, pos.index, pos.index + 1),
                ...loop(advancePosition(pos, ch))
              ],
            ':' => 
              [
                makeToken(Colon, pos.line, pos.col, pos.index, pos.index + 1),
                ...loop(advancePosition(pos, ch))
              ],
            ',' => 
              [
                makeToken(Comma, pos.line, pos.col, pos.index, pos.index + 1),
                ...loop(advancePosition(pos, ch))
              ],  
            '=' => {
              match (peek(pos.index + 1)) {
                Some('>') =>
                  [
                    makeToken(
                      FatArrow,
                      pos.line,
                      pos.col,
                      pos.index,
                      pos.index + 2
                    ),
                    ...loop(advancePosition(advancePosition(pos, ch), '>'))
                  ],
                _ =>
                  [
                    makeToken(Eq, pos.line, pos.col, pos.index, pos.index + 1),
                    ...loop(advancePosition(pos, ch))
                  ],
              }
            },
            '/' => {
              match (peek(pos.index + 1)) {
                Some('/') =>
                  [
                    makeToken(
                      DSlash,
                      pos.line,
                      pos.col,
                      pos.index,
                      pos.index + 2
                    ),
                    ...loop(advancePosition(advancePosition(pos, ch), '>'))
                  ],
                _ =>
                  [
                    makeToken(Slash, pos.line, pos.col, pos.index, pos.index + 1),
                    ...loop(advancePosition(pos, ch))
                  ],
              }
            },
            _ => {
              let msg = "unknown tok: \"" ++ Char.toString(ch) ++ "\""
              panic(msg)
            }
          }
        },
      }
    }
    print(val)
    val
  }
  loop({ index: 0, line: 1, col: 1 })
}

print(lex(testStr))
