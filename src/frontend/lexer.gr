module Lexer

from "char" include Char
from "string" include String
from "option" include Option
from "list" include List
from "runtime/unsafe/panic" include Panic
from "../util.gr" include Util
use Util.{ testStr }

use Panic.{ panic }

from "../core/source.gr" include Source

provide enum TokenKind {
  //keywords
  KwIf, // if
  KwElse, // else
  KwElseIf, //ban xD
  KwMatch, //match
  KwWhen, // when
  KwLet, // let
  KwMut, // mut
  KwRec, // rec
  KwAnd, // and
  KwType, // type
  KwRecord, // record
  KwFrom, // from
  KwImport, // import
  KwExport, // export
  KwAs, // as
  KwInfectious, // infectious
  KwDomain, // domain
  KwPolicy, // policy
  KwOp, // op
  KwAnnotate, // annotate
  KwVoid, // void
  KwPanic, // panic
  KwVar, // Var
  KwAllErrors, // AllErrors
  //literals
  NameTok(String), // strs
  ConstructorTok(String), // Strs
  LitNum(Number), //138510
  LitString(String), // "*"
  LitChar(Char), // '*'
  LitBool(Bool), // true false
  //symbols
  LParen, // (
  RParen, // )
  LBrace, // {
  RBrace, // }
  FatArrow, // =>
  Question, // ?
  Pipe, // |
  DPipe, // ||
  SemiColon, // ;
  Comma, // ,
  Colon, // :
  Slash, // /
  DSlash, // //
  Arrow, // >
  Period, // .
  DPeriod, // ..
  //operators
  Eq, // =
  EqEq, // ==
  Plus, // +
  DPlus, // ++
  Dash, // -
  DDash, // --
  //other
  Directive, // @stuff;
  EOF, // eof
}

//the base token type
provide record Token {
  kind: TokenKind,
  span: Source.Span,
  mate: Option<Number> //index
}

enum ReadValue {
  StringVal(String),
  NumVal(Number),
  CharVal(Char),
}

record Position {
  index: Number,
  line: Number,
  col: Number,
}

record ReadResult {
  value: ReadValue,
  position: Position,
}

//lexer function
provide let lex = source => {

  //source lenght
  let lenght = String.length(source)

  //peek a token
  let peek = index => {
    if (index < 0 || index >= lenght) {
      None
    } else {
      Some(String.charAt(index, source))
    }
  }

  // advance position based on character
  let advancePosition = (pos: Position, ch: Char) => {
    let newIndex = pos.index + 1
    let newLine = if (ch == '\n') {
      pos.line + 1
    } else {
      pos.line
    }
    let newCol = if (ch == '\n') {
      1
    } else {
      pos.col + 1
    }
    { index: newIndex, line: newLine, col: newCol }
  }

  // continue until not whitespace
  let skipWhitespace = position => {
    let mut p = position
    while (true) {
      match (peek(p.index)) {
        Some(ch) when Char.Ascii.isWhitespace(ch) => {
          p = advancePosition(p, ch)
        },
        _ => break,
      }
    }
    p
  }

  // name start
  let isNameStart = (ch: Char) => {
    Char.Ascii.isAlpha(ch) || ch == '_'
  }

  // check if uppercase
  let isUpper = (ch: Char) => {
    let code = Char.code(ch)
    code >= Char.code('A') && code <= Char.code('Z')
  }

  //read a name to end
  let readName = (startPosition: Position) => {
    // name cont
    let isNameContinue = (ch: Char) => {
      isNameStart(ch) || Char.Ascii.isDigit(ch)
    }

    let rec loop = (currentPos: Position) => {
      match (peek(currentPos.index)) {
        Some(ch) => {
          if (isNameContinue(ch)) {
            let newPos = advancePosition(currentPos, ch)
            loop(newPos)
          } else {
            currentPos
          }
        },
        _ => currentPos,
      }
    }
    let endPos = loop(startPosition)
    let name = String.slice(startPosition.index, end=endPos.index, source)
    { value: StringVal(name), position: endPos }
  }

  //read a number to end
  let readNumber = (startPosition: Position) => {
    // number
    let digitValue = (ch: Char) => {
      Char.code(ch) - Char.code('0')
    }

    let firstCh = String.charAt(startPosition.index, source)
    let initialAcc = digitValue(firstCh)

    let rec loop = (currentPos: Position, acc: Number) => {
      match (peek(currentPos.index)) {
        Some(ch) => {
          if (Char.Ascii.isDigit(ch)) {
            let newAcc = acc * 10 + digitValue(ch)
            let newPos = advancePosition(currentPos, ch)
            loop(newPos, newAcc)
          } else {
            { value: NumVal(acc), position: currentPos }
          }
        },
        _ => { value: NumVal(acc), position: currentPos },
      }
    }
    let startAfterFirst = advancePosition(startPosition, firstCh)
    loop(startAfterFirst, initialAcc)
  }

  //read string to end
  let readString = (startPosition: Position) => {
    let rec loop = (currentPos: Position, acc: String) => {
      match (peek(currentPos.index)) {
        Some(ch) => {
          if (ch == '"') {
            // end of string
            { value: StringVal(acc), position: advancePosition(currentPos, ch) }
          } else if (ch == '\\') {
            // escape sequence
            match (peek(currentPos.index + 1)) {
              Some(nextCh) => {
                let escaped = if (nextCh == '"') {
                  "\""
                } else if (nextCh == '\\') {
                  "\\"
                } else if (nextCh == 'n') {
                  "\n"
                } else if (nextCh == 't') {
                  "\t"
                } else if (nextCh == 'r') {
                  "\r"
                } else {
                  String.slice(
                    currentPos.index + 1,
                    end=currentPos.index + 2,
                    source
                  ) // treat as literal
                }
                let newAcc = acc ++ escaped
                let newPos = advancePosition(
                  advancePosition(currentPos, ch),
                  nextCh
                )
                loop(newPos, newAcc)
              },
              None => panic("Unclosed escape sequence"),
            }
          } else {
            let charStr = String.slice(
              currentPos.index,
              end=currentPos.index + 1,
              source
            )
            let newAcc = acc ++ charStr
            let newPos = advancePosition(currentPos, ch)
            loop(newPos, newAcc)
          }
        },
        None => panic("Unclosed string literal"),
      }
    }
    loop(startPosition, "")
  }

  //read char to end
  let readChar = (startPosition: Position) => {
    match (peek(startPosition.index)) {
      Some(ch) => {
        if (ch == '\'') {
          panic("Empty char literal")
        } else {
          let char = ch
          let afterChar = advancePosition(startPosition, ch)
          match (peek(afterChar.index)) {
            Some('\'') => {
              {
                value: CharVal(char),
                position: advancePosition(afterChar, '\''),
              }
            },
            _ => panic("Unclosed char literal"),
          }
        }
      },
      None => panic("Unclosed char literal"),
    }
  }

  // determine token kind from name
  let tokenKindFromName = (name: String) => {
    match (name) {
      "if" => KwIf,
      "else" => KwElse,
      "elseif" => KwElseIf,
      "match" => KwMatch,
      "when" => KwWhen,
      "let" => KwLet,
      "mut" => KwMut,
      "rec" => KwRec,
      "and" => KwAnd,
      "type" => KwType,
      "record" => KwRecord,
      "from" => KwFrom,
      "import" => KwImport,
      "export" => KwExport,
      "as" => KwAs,
      "infectious" => KwInfectious,
      "domain" => KwDomain,
      "policy" => KwPolicy,
      "op" => KwOp,
      "annotate" => KwAnnotate,
      "void" => KwVoid,
      "panic" => KwPanic,
      "Var" => KwVar,
      "AllErrors" => KwAllErrors,
      "true" => LitBool(true),
      "false" => LitBool(false),
      _ => {
        if (isUpper(String.charAt(0, name))) {
          ConstructorTok(name)
        } else {
          NameTok(name)
        }
      },
    }
  }

  //create a Token
  let makeToken = (kind: TokenKind, line, col, start, end) =>
    { kind, span: Source.makeSpan(line, col, start, end) }

  let mut tokens = []
  let mut pos = { index: 0, line: 1, col: 1 }
  while (pos.index < lenght) {
    pos = skipWhitespace(pos)
    if (pos.index >= lenght) break
    let ch = String.charAt(pos.index, source)
    match (ch) {
      ch when isNameStart(ch) => {
        let res = readName(pos)
        let ident = match (res.value) {
          StringVal(s) => s,
          _ => panic("WTF"),
        }
        let kind = tokenKindFromName(ident)
        tokens = [
          makeToken(kind, pos.line, pos.col, pos.index, res.position.index),
          ...tokens
        ]
        pos = res.position
      },
      ch when Char.Ascii.isDigit(ch) => {
        let res = readNumber(pos)
        let val = match (res.value) {
          NumVal(ident) => {
            ident
          },
          _ => {
            panic("WTF")
          },
        }
        tokens = [
          makeToken(
            LitNum(val),
            pos.line,
            pos.col,
            pos.index,
            res.position.index
          ),
          ...tokens
        ]
        pos = res.position
      },
      '"' => {
        let res = readString(advancePosition(pos, ch))
        let str = match (res.value) {
          StringVal(s) => s,
          _ => panic("Unexpected value type"),
        }
        tokens = [
          makeToken(
            LitString(str),
            pos.line,
            pos.col,
            pos.index,
            res.position.index
          ),
          ...tokens
        ]
        pos = res.position
      },
      '\'' => {
        let res = readChar(advancePosition(pos, ch))
        let chr = match (res.value) {
          CharVal(c) => c,
          _ => panic("Unexpected value type"),
        }
        tokens = [
          makeToken(
            LitChar(chr),
            pos.line,
            pos.col,
            pos.index,
            res.position.index
          ),
          ...tokens
        ]
        pos = res.position
      },
      ch => { //Var(ch)
        match (ch) {
          '(' => {
            tokens = [
              makeToken(LParen, pos.line, pos.col, pos.index, pos.index + 1),
              ...tokens
            ]
            pos = advancePosition(pos, ch)
          },
          ')' => {
            tokens = [
              makeToken(RParen, pos.line, pos.col, pos.index, pos.index + 1),
              ...tokens
            ]
            pos = advancePosition(pos, ch)
          },
          '{' => {
            tokens = [
              makeToken(LBrace, pos.line, pos.col, pos.index, pos.index + 1),
              ...tokens
            ]
            pos = advancePosition(pos, ch)
          },
          '}' => {
            tokens = [
              makeToken(RBrace, pos.line, pos.col, pos.index, pos.index + 1),
              ...tokens
            ]
            pos = advancePosition(pos, ch)
          },
          '?' => {
            tokens = [
              makeToken(Question, pos.line, pos.col, pos.index, pos.index + 1),
              ...tokens
            ]
            pos = advancePosition(pos, ch)
          },
          ';' => {
            tokens = [
              makeToken(SemiColon, pos.line, pos.col, pos.index, pos.index + 1),
              ...tokens
            ]
            pos = advancePosition(pos, ch)
          },
          ':' => {
            tokens = [
              makeToken(Colon, pos.line, pos.col, pos.index, pos.index + 1),
              ...tokens
            ]
            pos = advancePosition(pos, ch)
          },
          ',' => {
            tokens = [
              makeToken(Comma, pos.line, pos.col, pos.index, pos.index + 1),
              ...tokens
            ]
            pos = advancePosition(pos, ch)
          },
          '>' => {
            tokens = [
              makeToken(Arrow, pos.line, pos.col, pos.index, pos.index + 1),
              ...tokens
            ]
            pos = advancePosition(pos, ch)
          },
          //len2
          '|' => {
            match (peek(pos.index + 1)) {
              Some('-') => {
                tokens = [
                  makeToken(DPipe, pos.line, pos.col, pos.index, pos.index + 2),
                  ...tokens
                ]
                pos = advancePosition(advancePosition(pos, ch), '-')
              },
              _ => {
                tokens = [
                  makeToken(Pipe, pos.line, pos.col, pos.index, pos.index + 1),
                  ...tokens
                ]
                pos = advancePosition(pos, ch)
              },
            }
          },
          '-' => {
            match (peek(pos.index + 1)) {
              Some('-') => {
                tokens = [
                  makeToken(DDash, pos.line, pos.col, pos.index, pos.index + 2),
                  ...tokens
                ]
                pos = advancePosition(advancePosition(pos, ch), '-')
              },
              _ => {
                tokens = [
                  makeToken(Dash, pos.line, pos.col, pos.index, pos.index + 1),
                  ...tokens
                ]
                pos = advancePosition(pos, ch)
              },
            }
          },
          '.' => {
            match (peek(pos.index + 1)) {
              Some('.') => {
                tokens = [
                  makeToken(
                    DPeriod,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 2
                  ),
                  ...tokens
                ]
                pos = advancePosition(advancePosition(pos, ch), '.')
              },
              _ => {
                tokens = [
                  makeToken(Period, pos.line, pos.col, pos.index, pos.index + 1),
                  ...tokens
                ]
                pos = advancePosition(pos, ch)
              },
            }
          },
          '+' => {
            match (peek(pos.index + 1)) {
              Some('+') => {
                tokens = [
                  makeToken(DPlus, pos.line, pos.col, pos.index, pos.index + 2),
                  ...tokens
                ]
                pos = advancePosition(advancePosition(pos, ch), '+')
              },
              _ => {
                tokens = [
                  makeToken(Plus, pos.line, pos.col, pos.index, pos.index + 1),
                  ...tokens
                ]
                pos = advancePosition(pos, ch)
              },
            }
          },
          '=' => {
            match (peek(pos.index + 1)) {
              Some('>') => {
                tokens = [
                  makeToken(
                    FatArrow,
                    pos.line,
                    pos.col,
                    pos.index,
                    pos.index + 2
                  ),
                  ...tokens
                ]
                pos = advancePosition(advancePosition(pos, ch), '>')
              },
              Some('=') => {
                tokens = [
                  makeToken(EqEq, pos.line, pos.col, pos.index, pos.index + 2),
                  ...tokens
                ]
                pos = advancePosition(advancePosition(pos, ch), '>')
              },
              _ => {
                tokens = [
                  makeToken(Eq, pos.line, pos.col, pos.index, pos.index + 1),
                  ...tokens
                ]
                pos = advancePosition(pos, ch)
              },
            }
          },
          '/' => {
            match (peek(pos.index + 1)) {
              Some('/') => {
                tokens = [
                  makeToken(DSlash, pos.line, pos.col, pos.index, pos.index + 2),
                  ...tokens
                ]
                pos = advancePosition(advancePosition(pos, ch), '/')
              },
              _ => {
                tokens = [
                  makeToken(Slash, pos.line, pos.col, pos.index, pos.index + 1),
                  ...tokens
                ]
                pos = advancePosition(pos, ch)
              },
            }
          },
          _ => {
            let msg = "unknown tok: \"" ++ Char.toString(ch) ++ "\""
            panic(msg)
          },
        }
      },
    }
  }
  tokens = [makeToken(EOF, pos.line, pos.col, pos.index, pos.index), ...tokens]
  List.reverse(tokens)
}

print(lex(testStr))
