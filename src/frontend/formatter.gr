module Formatter

from "array" include Array
from "list" include List
from "string" include String
from "char" include Char
from "../util.gr" include Util

use Util.{ (|>), testStr }

from "./frontend.gr" include Frontend
from "../core/ast.gr" include Ast
use Ast.*

let rec formatExpr = (expr: Ast.Expr) => {
  match (expr.kind) {
    Ast.IntLit(n) => toString(n),
    Ast.StrLit(s) => "\"" ++ s ++ "\"",
    Ast.CharLit(c) => "'" ++ Char.toString(c) ++ "'",
    Ast.Ident(name) => name,
    Ast.Lambda(param, body) => {
      let paramStr = match (param) {
        Some(p) => p,
        None => "_",
      }
      paramStr ++ " => " ++ formatExpr(body)
    },
    Ast.Infix(Ast.OpFatArrow, left, right) => {
      // This shouldn't happen after lowering, but just in case
      formatExpr(left) ++ " => " ++ formatExpr(right)
    },
    Ast.Block(inner) => {
      "{ " ++ formatExpr(inner) ++ " }"
    },
    Ast.Paren(inner) => {
      "(" ++ formatExpr(inner) ++ ")"
    },
    Ast.Tuple(exprs) => {
      let formatted = List.map(formatExpr, exprs)
      "(" ++ Array.join(", ", Array.fromList(formatted)) ++ ")"
    },
    Ast.Unit => "()",
    Ast.Unknown => "<unknown>",
  }
}

let formatBinding = (b: Ast.Binding) => {
  "let " ++ b.name ++ " = " ++ formatExpr(b.value)
}

let formatTopLevel = (tl: Ast.TopLevel) => {
  let base = match (tl.kind) {
    Ast.LetBinding(b) => formatBinding(b),
    Ast.TypeDef(name, def) => "type " ++ name ++ " = " ++ def,
  }
  if (tl.exported) {
    "export " ++ base
  } else {
    base
  }
}

let formatProgram = (program: Ast.Program) => {
  let items = List.map(formatTopLevel, program.topLevels)
  Array.join("\n\n", Array.fromList(items))
}

provide let format = (source: String) => {
  let program = Frontend.parseAndLower(source)
  formatProgram(program)
}

print(format(testStr))
