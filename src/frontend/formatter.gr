module Formatter

from "array" include Array
from "list" include List
from "string" include String
from "char" include Char

from "../core/surface_ast.gr" include SurfaceAst
from "../core/source.gr" include Source
from "../core/error.gr" include Error
from "./parser.gr" include Parser
from "./lexer.gr" include Lexer

let join = (sep: String, xs: List<String>) =>
  Array.join(sep, Array.fromList(xs))

let canonicalNonWs = (text: String) => {
  let noSpace = String.replaceAll(" ", "", text)
  let noTab = String.replaceAll("\t", "", noSpace)
  let noLf = String.replaceAll("\n", "", noTab)
  String.replaceAll("\r", "", noLf)
}

let truncate = (text: String, max: Number) => {
  if (String.length(text) <= max) {
    text
  } else {
    String.slice(0, end=max, text) ++ "..."
  }
}

let sliceWithContext = (
  text: String,
  start: Number,
  end: Number,
  context: Number,
) => {
  let len = String.length(text)
  let left = if (start > context) {
    start - context
  } else {
    0
  }
  let right = if (end + context < len) {
    end + context
  } else {
    len
  }
  let prefix = if (left > 0) {
    "..."
  } else {
    ""
  }
  let suffix = if (right < len) {
    "..."
  } else {
    ""
  }
  prefix ++ String.slice(left, end=right, text) ++ suffix
}

provide enum Mode {
  Real,
  RealFix,
  Virtual,
}

provide record VirtualArtifact {
  kind: String,
  text: String,
  start: Number,
  end: Number,
  reason: String,
}

provide record FormatResult {
  text: String,
  virtualArtifacts: List<VirtualArtifact>,
}

record Settings {
  allowVirtualInsertions: Bool,
  insertSemis: Bool,
}

let realSettings = { allowVirtualInsertions: false, insertSemis: false }
let realFixSettings = { allowVirtualInsertions: false, insertSemis: true }
let virtualSettings = {
  allowVirtualInsertions: true,
  insertSemis: false,
}

let rec spaces = (n: Number) => {
  if (n <= 0) {
    ""
  } else {
    " " ++ spaces(n - 1)
  }
}

let artifactFromVirtual = (text: String, anchor: Number, reason: String) => {
  { kind: "ghostToken", text, start: anchor, end: anchor, reason }
}

let renderWithSettings = (
  program: SurfaceAst.Program,
  source: String,
  mode: Mode,
  settings: Settings,
) => {
  let tokens: List<Lexer.Token> = Lexer.lex(source)
  let tokensNoComments: List<Lexer.Token> = List.filter(
    (tok: Lexer.Token) => match (tok.kind) {
      Lexer.LineComment(_) => false,
      _ => true,
    },
    tokens
  )
  let hasConcreteTokenEndingAt = (endIndex: Number) => {
    let rec find = (tokens: List<Lexer.Token>) => {
      match (tokens) {
        [] => false,
        [tok, ...tail] => if (tok.span.end == endIndex) {
          match (tok.kind) {
            Lexer.EOF => false,
            _ => true,
          }
        } else {
          find(tail)
        },
      }
    }
    find(tokens)
  }
  let hasTerminatorAfter = (endIndex: Number) => {
    let rec find = (tokens: List<Lexer.Token>) => {
      match (tokens) {
        [] => false,
        [tok, ...tail] => if (tok.span.start < endIndex) {
          find(tail)
        } else {
          match (tok.kind) {
            Lexer.SemiColon => true,
            _ => false,
          }
        },
      }
    }
    find(tokensNoComments)
  }

  let topItemSpan = (item: SurfaceAst.TopItem) => match (item) {
    SurfaceAst.DeclGroup(group) => group.node.span,
    SurfaceAst.Import(importDecl) => importDecl.node.span,
    SurfaceAst.Reexport(reexportDecl) => reexportDecl.node.span,
    SurfaceAst.Export(exportDecl) => exportDecl.node.span,
    SurfaceAst.Directive(directive) => directive.name.node.span,
    SurfaceAst.Mark(mark) => mark.node.span,
    SurfaceAst.Trivia(trivia) => trivia.node.span,
  }

  let rec patternHasHole = (pat: SurfaceAst.Pattern) => match (pat.kind) {
    SurfaceAst.Hole(_) => true,
    SurfaceAst.Wildcard |
    SurfaceAst.Var(_) |
    SurfaceAst.Pin(_) |
    SurfaceAst.Lit(_) => false,
    SurfaceAst.Constructor(_, args) => anyPattern(args),
    SurfaceAst.Tuple(items) => anyPattern(items),
    SurfaceAst.List(items, restOpt) => anyPattern(items) || match (restOpt) {
      Some(r) => patternHasHole(r),
      None => false,
    },
    SurfaceAst.AllErrors => false,
  }
  and anyPattern = (items: List<SurfaceAst.Pattern>) => match (items) {
    [] => false,
    [x, ...xs] => patternHasHole(x) || anyPattern(xs),
  }
  and fnItemHasHole = (item: SurfaceAst.FnItem) => match (item.kind) {
    SurfaceAst.Clause(clause) =>
      patternHasHole(clause.param)
        || match (clause.guard) {
          Some(g) => exprHasHole(g),
          None => false,
        }
        || exprHasHole(clause.body.body),
    SurfaceAst.Hole(_) => true,
    _ => false,
  }
  and fnHasHole = (fn: SurfaceAst.FnExpr) => anyFnItemList(fn.items)
  and anyFnItemList = (items: List<SurfaceAst.FnItem>) => match (items) {
    [] => false,
    [x, ...xs] => fnItemHasHole(x) || anyFnItemList(xs),
  }
  and exprHasHole = (expr: SurfaceAst.Expr) => match (expr.kind) {
    SurfaceAst.Hole(_) => true,
    SurfaceAst.Lit(_) | SurfaceAst.Ident(_) => false,
    SurfaceAst.Fn(fn) => fnHasHole(fn),
    SurfaceAst.Match(matchExpr) =>
      match (matchExpr.scrutinee) {
        Some(e) => exprHasHole(e),
        None => false,
      } || fnHasHole(matchExpr.bundle),
    SurfaceAst.Apply(callee, arg) => exprHasHole(callee) || exprHasHole(arg),
    SurfaceAst.InfixChain(chain) =>
      exprHasHole(chain.first) || anyInfixRest(chain.rest),
    SurfaceAst.Postfix(postfix) =>
      exprHasHole(postfix.target) || anyPostfixSegments(postfix.segments),
    SurfaceAst.Block(block) =>
      exprHasHole(block.body) || anyBlockItems(block.items),
    SurfaceAst.Paren(inner) => exprHasHole(inner),
    SurfaceAst.Seq(items) => anyExprList(items),
    SurfaceAst.Tuple(items) => anyExprList(items),
    SurfaceAst.RecordLit(items) => anyRecordItems(items),
    SurfaceAst.If(cond, thenExpr, elseExprOpt) =>
      exprHasHole(cond) || exprHasHole(thenExpr) || match (elseExprOpt) {
        Some(e) => exprHasHole(e),
        None => false,
      },
    SurfaceAst.Let(binding, body) =>
      patternHasHole(binding.name)
        || match (binding.annotation) {
          Some(t) => typeHasHole(t),
          None => false,
        }
        || exprHasHole(binding.value)
        || exprHasHole(body),
    SurfaceAst.Assign(assignExpr) =>
      exprHasHole(assignExpr.target) || exprHasHole(assignExpr.value),
  }
  and anyExprList = (items: List<SurfaceAst.Expr>) => match (items) {
    [] => false,
    [x, ...xs] => exprHasHole(x) || anyExprList(xs),
  }
  and anyInfixRest = (items: List<(SurfaceAst.Name, SurfaceAst.Expr)>) =>
    match (items) {
      [] => false,
      [(_op, rhs), ...xs] => exprHasHole(rhs) || anyInfixRest(xs),
    }
  and anyPostfixSegments = (items: List<SurfaceAst.PostfixSegment>) =>
    match (items) {
      [] => false,
      [seg, ...xs] => {
        let hasHole = match (seg) {
          SurfaceAst.Call(args) => anyExprList(args),
          SurfaceAst.Project(_) => false,
          SurfaceAst.Index(idx) => exprHasHole(idx),
        }
        hasHole || anyPostfixSegments(xs)
      },
    }
  and anyRecordItems = (items: List<SurfaceAst.RecordItem>) => match (items) {
    [] => false,
    [item, ...xs] => {
      let hasHole = match (item) {
        SurfaceAst.Field(_, value) => exprHasHole(value),
        SurfaceAst.Spread(value) => exprHasHole(value),
      }
      hasHole || anyRecordItems(xs)
    },
  }
  and anyBlockItems = (items: List<SurfaceAst.BlockItem>) => match (items) {
    [] => false,
    [item, ...xs] => {
      let hasHole = match (item) {
        SurfaceAst.ExprItem(e) => exprHasHole(e),
        SurfaceAst.LetItem(b) =>
          patternHasHole(b.name)
            || match (b.annotation) {
              Some(t) => typeHasHole(t),
              None => false,
            }
            || exprHasHole(b.value),
        SurfaceAst.DeclGroup(group) => match (group.kind) {
          SurfaceAst.LetGroup(_) => {
            let bindings = List.flatMap(
              (decl: SurfaceAst.Decl) => match (decl) {
                SurfaceAst.LetDecl(ld) => ld.bindings,
                _ => [],
              },
              group.decls
            )
            let rec anyBindingHole = (items: List<SurfaceAst.LetBinding>) =>
              match (items) {
                [] => false,
                [binding, ...rest] =>
                  patternHasHole(binding.name)
                    || match (binding.annotation) {
                      Some(t) => typeHasHole(t),
                      None => false,
                    }
                    || exprHasHole(binding.value)
                    || anyBindingHole(rest),
              }
            anyBindingHole(bindings)
          },
          _ => false,
        },
        SurfaceAst.Semicolon => false,
        _ => false,
      }
      hasHole || anyBlockItems(xs)
    },
  }
  and typeHasHole = (ty: SurfaceAst.TypeExpr) => match (ty.kind) {
    SurfaceAst.Hole(_) => true,
    SurfaceAst.Var(_) => false,
    SurfaceAst.Ref(_, args) => anyTypeList(args),
    SurfaceAst.Tuple(items) => anyTypeList(items),
    SurfaceAst.Record(fields) => anyTypeFieldList(fields),
    SurfaceAst.Arrow(params, ret) => anyTypeList(params) || typeHasHole(ret),
    SurfaceAst.Ptr(inner, _) => typeHasHole(inner),
    SurfaceAst.EffectRow(cases, _hasTail) => anyEffectCases(cases),
    SurfaceAst.UnitType => false,
  }
  and anyTypeList = (items: List<SurfaceAst.TypeExpr>) => match (items) {
    [] => false,
    [x, ...xs] => typeHasHole(x) || anyTypeList(xs),
  }
  and anyTypeFieldList = (items: List<(SurfaceAst.Name, SurfaceAst.TypeExpr)>) =>
    match (items) {
      [] => false,
      [(_name, ty), ...xs] => typeHasHole(ty) || anyTypeFieldList(xs),
    }
  and anyEffectCases = (items: List<SurfaceAst.EffectCase>) => match (items) {
    [] => false,
    [ecase, ...xs] => {
      let hasHole = match (ecase.payload) {
        Some(p) => typeHasHole(p),
        None => false,
      }
      hasHole || anyEffectCases(xs)
    },
  }

  let rec blockHasMissingRBrace = (items: List<SurfaceAst.BlockItem>) =>
    match (items) {
      [] => false,
      [item, ...rest] => match (item) {
        SurfaceAst.MarkItem(mark) => match (mark.kind) {
          SurfaceAst.MissingRBrace => true,
          _ => blockHasMissingRBrace(rest),
        },
        _ => blockHasMissingRBrace(rest),
      },
    }

  let rec exprHasMissingRBrace = (expr: SurfaceAst.Expr) => match (expr.kind) {
    SurfaceAst.Block(block) =>
      blockHasMissingRBrace(block.items) || exprHasMissingRBrace(block.body),
    SurfaceAst.Fn(fnExpr) => anyFnItemMissingRBrace(fnExpr.items),
    SurfaceAst.Match(matchExpr) =>
      match (matchExpr.scrutinee) {
        Some(e) => exprHasMissingRBrace(e),
        None => false,
      }
        || anyFnItemMissingRBrace(matchExpr.bundle.items),
    SurfaceAst.Apply(callee, arg) =>
      exprHasMissingRBrace(callee) || exprHasMissingRBrace(arg),
    SurfaceAst.InfixChain(chain) =>
      exprHasMissingRBrace(chain.first) || anyInfixMissingRBrace(chain.rest),
    SurfaceAst.Postfix(postfix) =>
      exprHasMissingRBrace(postfix.target)
        || anyPostfixMissingRBrace(postfix.segments),
    SurfaceAst.Paren(inner) => exprHasMissingRBrace(inner),
    SurfaceAst.Seq(items) => anyExprMissingRBrace(items),
    SurfaceAst.Tuple(items) => anyExprMissingRBrace(items),
    SurfaceAst.RecordLit(items) => anyRecordItemsMissingRBrace(items),
    SurfaceAst.If(cond, thenExpr, elseExprOpt) =>
      exprHasMissingRBrace(cond)
        || exprHasMissingRBrace(thenExpr)
        || match (elseExprOpt) {
          Some(e) => exprHasMissingRBrace(e),
          None => false,
        },
    SurfaceAst.Let(binding, body) =>
      exprHasMissingRBrace(binding.value) || exprHasMissingRBrace(body),
    SurfaceAst.Assign(assignExpr) =>
      exprHasMissingRBrace(assignExpr.target)
        || exprHasMissingRBrace(assignExpr.value),
    _ => false,
  }
  and anyFnItemMissingRBrace = (items: List<SurfaceAst.FnItem>) =>
    match (items) {
      [] => false,
      [item, ...rest] => {
        let hasMissing = match (item.kind) {
          SurfaceAst.Clause(clause) =>
            match (clause.guard) {
              Some(g) => exprHasMissingRBrace(g),
              None => false,
            } || exprHasMissingRBrace(clause.body.body),
          _ => false,
        }
        hasMissing || anyFnItemMissingRBrace(rest)
      },
    }
  and anyInfixMissingRBrace = (items: List<(SurfaceAst.Name, SurfaceAst.Expr)>) =>
    match (items) {
      [] => false,
      [(_op, rhs), ...xs] =>
        exprHasMissingRBrace(rhs) || anyInfixMissingRBrace(xs),
    }
  and anyPostfixMissingRBrace = (items: List<SurfaceAst.PostfixSegment>) =>
    match (items) {
      [] => false,
      [seg, ...xs] => {
        let hasMissing = match (seg) {
          SurfaceAst.Call(args) => anyExprMissingRBrace(args),
          SurfaceAst.Project(_) => false,
          SurfaceAst.Index(idx) => exprHasMissingRBrace(idx),
        }
        hasMissing || anyPostfixMissingRBrace(xs)
      },
    }
  and anyExprMissingRBrace = (items: List<SurfaceAst.Expr>) => match (items) {
    [] => false,
    [x, ...xs] => exprHasMissingRBrace(x) || anyExprMissingRBrace(xs),
  }
  and anyRecordItemsMissingRBrace = (items: List<SurfaceAst.RecordItem>) =>
    match (items) {
      [] => false,
      [item, ...xs] => {
        let hasMissing = match (item) {
          SurfaceAst.Field(_, value) => exprHasMissingRBrace(value),
          SurfaceAst.Spread(value) => exprHasMissingRBrace(value),
        }
        hasMissing || anyRecordItemsMissingRBrace(xs)
      },
    }
  let mut chunks: List<String> = []
  let mut artifacts: List<VirtualArtifact> = []
  let mut indent = 0
  let mut atLineStart = true

  let write = (text: String) => {
    if (atLineStart) {
      chunks = [spaces(indent), ...chunks]
      atLineStart = false
    }
    chunks = [text, ...chunks]
  }

  let newline = () => {
    chunks = ["\n", ...chunks]
    atLineStart = true
  }

  let space = () => {
    if (!atLineStart) {
      chunks = [" ", ...chunks]
    }
  }

  let emitVirtual = (text: String, anchor: Number, reason: String) => {
    if (mode == Virtual && settings.allowVirtualInsertions) {
      write(text)
      artifacts = [artifactFromVirtual(text, anchor, reason), ...artifacts]
    }
  }

  let rec emitTrivia = (trivia: SurfaceAst.Trivia) => {
    match (trivia.kind) {
      SurfaceAst.LineComment(text) => write(text),
      SurfaceAst.BlockComment(text) => write(text),
      SurfaceAst.Opaque(text) => write(text),
    }
  }

  let rec emitTriviaInline = (triviaList: List<SurfaceAst.Trivia>) => {
    match (triviaList) {
      [] => void,
      [single] => emitTrivia(single),
      [head, ...tail] => {
        emitTrivia(head)
        space()
        emitTriviaInline(tail)
      },
    }
  }

  let rec emitTriviaLines = (triviaList: List<SurfaceAst.Trivia>) => {
    match (triviaList) {
      [] => void,
      [single] => emitTrivia(single),
      [head, ...tail] => {
        emitTrivia(head)
        newline()
        emitTriviaLines(tail)
      },
    }
  }

  let withAttachments = (attach: SurfaceAst.Attachments, emitCore) => {
    if (attach.leading != []) {
      emitTriviaLines(attach.leading)
      newline()
    }
    emitCore()
    if (attach.trailing != []) {
      space()
      emitTriviaInline(attach.trailing)
    }
    if (attach.dangling != []) {
      newline()
      emitTriviaLines(attach.dangling)
    }
  }

  let rec emitCommaSeparated = (emitOne, items) => {
    match (items) {
      [] => void,
      [single] => emitOne(single),
      [head, ...tail] => {
        emitOne(head)
        write(",")
        space()
        emitCommaSeparated(emitOne, tail)
      },
    }
  }

  let shouldEmitInferredHole = () => mode == Virtual

  let emitHole = (hole: SurfaceAst.Hole) => match (hole.origin) {
    SurfaceAst.UserTyped => write("?"),
    SurfaceAst.Inferred => if (shouldEmitInferredHole()) {
      write("?")
    } else {
      void
    },
  }

  let rec emitPattern = (pattern: SurfaceAst.Pattern) => {
    withAttachments(pattern.attach, () => {
      match (pattern.kind) {
        SurfaceAst.Hole(hole) => emitHole(hole),
        SurfaceAst.Wildcard => write("_"),
        SurfaceAst.Var(name) => write(name.text),
        SurfaceAst.Pin(name) => {
          write(name.text)
        },
        SurfaceAst.Lit(SurfaceAst.Int(n)) => write(toString(n)),
        SurfaceAst.Lit(SurfaceAst.Bool(b)) => write(if (b) {
          "true"
        } else {
          "false"
        }),
        SurfaceAst.Lit(SurfaceAst.Char(c)) => write("'" ++ toString(c) ++ "'"),
        SurfaceAst.Lit(SurfaceAst.Str(s)) => write("\"" ++ s ++ "\""),
        SurfaceAst.Lit(SurfaceAst.Unit) => write("()"),
        SurfaceAst.Lit(_) => write("<lit>"),
        SurfaceAst.Constructor(name, args) => {
          write(name.text)
          if (args != []) {
            write("(")
            emitCommaSeparated(emitPattern, args)
            write(")")
          }
        },
        SurfaceAst.Tuple(items) => {
          write("(")
          emitCommaSeparated(emitPattern, items)
          write(")")
        },
        SurfaceAst.List(items, rest) => {
          write("[")
          emitCommaSeparated(emitPattern, items)
          match (rest) {
            None => void,
            Some(r) => {
              if (items != []) {
                write(",")
                space()
              }
              write("..")
              space()
              emitPattern(r)
            },
          }
          write("]")
        },
        SurfaceAst.AllErrors => write("AllErrors"),
      }
    })
  }

  let rec emitTypeExpr = (typeExpr: SurfaceAst.TypeExpr) => {
    match (typeExpr.kind) {
      SurfaceAst.Hole(hole) => emitHole(hole),
      SurfaceAst.Var(name) => write(name.text),
      SurfaceAst.Ref(name, args) => {
        write(name.text)
        if (args != []) {
          write("<")
          emitCommaSeparated(emitTypeExpr, args)
          write(">")
        }
      },
      SurfaceAst.Tuple(items) => {
        write("(")
        emitCommaSeparated(emitTypeExpr, items)
        write(")")
      },
      SurfaceAst.Record(fields) => {
        write("{")
        if (fields != []) {
          space()
          emitCommaSeparated(
            (pair: (SurfaceAst.Name, SurfaceAst.TypeExpr)) => {
              let (name, ty) = pair
              write(name.text)
              space()
              write(":")
              space()
              emitTypeExpr(ty)
            },
            fields
          )
          space()
        }
        write("}")
      },
      SurfaceAst.Arrow(params, result) => {
        write("(")
        emitCommaSeparated(emitTypeExpr, params)
        write(")")
        space()
        write("=>")
        space()
        emitTypeExpr(result)
      },
      SurfaceAst.Ptr(inner, stateOpt) => {
        write("Ptr")
        write("<")
        emitTypeExpr(inner)
        match (stateOpt) {
          None => void,
          Some(name) => {
            write(",")
            space()
            write(name.text)
          },
        }
        write(">")
      },
      SurfaceAst.EffectRow(cases, hasTailWildcard) => {
        write("[")
        emitCommaSeparated((effectCase: SurfaceAst.EffectCase) => {
          write(effectCase.name.text)
          match (effectCase.payload) {
            None => void,
            Some(payload) => {
              write("(")
              emitTypeExpr(payload)
              write(")")
            },
          }
        }, cases)
        if (hasTailWildcard) {
          if (cases != []) {
            write(",")
            space()
          }
          write("..")
        }
        write("]")
      },
      SurfaceAst.UnitType => write("Void"),
    }
  }

  let emitTypeParams = (params: List<SurfaceAst.Name>) => {
    if (params != []) {
      write("<")
      emitCommaSeparated((name: SurfaceAst.Name) => write(name.text), params)
      write(">")
    }
  }

  let emitTypeConstructor = (
    entry: (
      SurfaceAst.Name,
      Option<SurfaceAst.TypeExpr>,
      Option<SurfaceAst.Annotation>
    ),
  ) => {
    let (name, payload, annotation) = entry
    write(name.text)
    match (payload) {
      None => void,
      Some(ty) => {
        write("(")
        emitTypeExpr(ty)
        write(")")
      },
    }
    match (annotation) {
      None => void,
      Some(text) => {
        space()
        write(text)
      },
    }
  }

  let emitTypeDeclBody = (body: SurfaceAst.TypeDeclBody) => {
    match (body) {
      SurfaceAst.Alias(typeExpr) => {
        space()
        write("=")
        space()
        emitTypeExpr(typeExpr)
      },
      SurfaceAst.Variant(cases) => {
        space()
        write("=")
        space()
        match (cases) {
          [] => void,
          [single] => {
            write("|")
            space()
            emitTypeConstructor(single)
          },
          [first, ...tail] => {
            emitTypeConstructor(first)
            let rec emitTail = (
              rest: List<
                (
                  SurfaceAst.Name,
                  Option<SurfaceAst.TypeExpr>,
                  Option<SurfaceAst.Annotation>
                )
              >,
            ) => {
              match (rest) {
                [] => void,
                [head, ...restTail] => {
                  space()
                  write("|")
                  space()
                  emitTypeConstructor(head)
                  emitTail(restTail)
                },
              }
            }
            emitTail(tail)
          },
        }
      },
    }
  }

  let rec emitExpr = (expr: SurfaceAst.Expr) => {
    withAttachments(expr.attach, () => {
      let emitRecordItems = (items: List<SurfaceAst.RecordItem>) => {
        if (items != []) {
          space()
          emitCommaSeparated(item => match (item) {
            SurfaceAst.Field(name, value) => {
              match (value.kind) {
                SurfaceAst.Ident({ text, _ }) when text == name.text =>
                  write(name.text),
                _ => {
                  write(name.text)
                  space()
                  write("=")
                  space()
                  emitExpr(value)
                },
              }
            },
            SurfaceAst.Spread(e) => {
              write("..")
              emitExpr(e)
            },
          }, items)
          space()
        }
      }

      let isConstructorName = (text: String) => {
        if (String.length(text) == 0) {
          false
        } else {
          let ch = String.charAt(0, text)
          let code = Char.code(ch)
          code >= Char.code('A') && code <= Char.code('Z')
        }
      }

      match (expr.kind) {
        SurfaceAst.Lit(SurfaceAst.Int(n)) => write(toString(n)),
        SurfaceAst.Lit(SurfaceAst.Bool(b)) => write(if (b) {
          "true"
        } else {
          "false"
        }),
        SurfaceAst.Lit(SurfaceAst.Str(s)) => write("\"" ++ s ++ "\""),
        SurfaceAst.Lit(SurfaceAst.Char(c)) => write("'" ++ toString(c) ++ "'"),
        SurfaceAst.Lit(SurfaceAst.Unit) => write("()"),
        SurfaceAst.Lit(_) => write("<lit>"),
        SurfaceAst.Ident(name) => write(name.text),
        SurfaceAst.Paren(inner) => {
          write("(")
          emitExpr(inner)
          write(")")
        },
        SurfaceAst.Tuple(items) => {
          write("(")
          emitCommaSeparated(emitExpr, items)
          write(")")
        },
        SurfaceAst.Seq(items) => {
          write("(")
          let rec emitSeq = (seqItems: List<SurfaceAst.Expr>) => {
            match (seqItems) {
              [] => void,
              [single] => emitExpr(single),
              [head, ...tail] => {
                emitExpr(head)
                write(";")
                space()
                emitSeq(tail)
              },
            }
          }
          emitSeq(items)
          write(")")
        },
        SurfaceAst.Hole(hole) => emitHole(hole),
        SurfaceAst.RecordLit(items) => {
          write(".{")
          emitRecordItems(items)
          write("}")
        },
        SurfaceAst.Postfix(postfix) => {
          emitExpr(postfix.target)
          let rec emitSegments = (segments: List<SurfaceAst.PostfixSegment>) => {
            match (segments) {
              [] => void,
              [segment, ...tail] => {
                match (segment) {
                  SurfaceAst.Call(args) => {
                    write("(")
                    emitCommaSeparated(emitExpr, args)
                    write(")")
                  },
                  SurfaceAst.Project(name) => {
                    write(".")
                    write(name.text)
                  },
                  SurfaceAst.Index(indexExpr) => {
                    write("[")
                    emitExpr(indexExpr)
                    write("]")
                  },
                }
                emitSegments(tail)
              },
            }
          }
          emitSegments(postfix.segments)
        },
        SurfaceAst.InfixChain(chain) => {
          emitExpr(chain.first)
          let rec emitRest = (rest: List<(SurfaceAst.Name, SurfaceAst.Expr)>) => {
            match (rest) {
              [] => void,
              [(op, rhs), ...tail] => {
                space()
                write(op.text)
                space()
                emitExpr(rhs)
                emitRest(tail)
              },
            }
          }
          emitRest(chain.rest)
        },
        SurfaceAst.Apply(callee, arg) => {
          match ((callee.kind, arg.kind)) {
            (SurfaceAst.Ident(name), SurfaceAst.RecordLit(items))
              when isConstructorName(name.text) => {
              write(name.text)
              write("{")
              emitRecordItems(items)
              write("}")
            },
            (SurfaceAst.Ident(name), SurfaceAst.Tuple(items))
              when isConstructorName(name.text) => {
              write(name.text)
              write("(")
              emitCommaSeparated(emitExpr, items)
              write(")")
            },
            _ => {
              emitExpr(callee)
              write("(")
              emitExpr(arg)
              write(")")
            },
          }
        },
        SurfaceAst.Block(block) => emitBlock(block),
        SurfaceAst.If(cond, thenExpr, elseExpr) => {
          write("if")
          space()
          emitExpr(cond)
          space()
          emitExpr(thenExpr)
          match (elseExpr) {
            None => void,
            Some(e) => {
              space()
              write("else")
              space()
              emitExpr(e)
            },
          }
        },
        SurfaceAst.Fn(fnExpr) => {
          match (fnExpr.items) {
            [
              {
                kind: SurfaceAst.Clause(
                  {
                    param: { node: paramNode, kind: SurfaceAst.Wildcard, _ },
                    guard: None,
                    body,
                    _
                  },
                ),
                _
              },
            ] => {
              if (mode == Virtual && settings.allowVirtualInsertions) {
                emitVirtual(
                  "()",
                  paramNode.span.start,
                  "inferred unit parameter"
                )
                space()
              }
              write("=>")
              space()
              emitBlock(body)
            },
            _ => {
              write("match")
              space()
              write("{")
              if (fnExpr.items != []) {
                space()
                emitCommaSeparated(emitFnItem, fnExpr.items)
                space()
              }
              write("}")
            },
          }
        },
        SurfaceAst.Match(matchExpr) => {
          write("match")
          match (matchExpr.scrutinee) {
            None => {
              space()
            },
            Some(scrutinee) => {
              match (scrutinee.kind) {
                SurfaceAst.Tuple(_) => emitExpr(scrutinee),
                _ => {
                  write("(")
                  emitExprUnparen(scrutinee)
                  write(")")
                },
              }
              space()
              if (matchExpr.arrowSugar) {
                write("=>")
                space()
              }
            },
          }
          write("{")
          if (matchExpr.bundle.items != []) {
            space()
            emitCommaSeparated(emitFnItem, matchExpr.bundle.items)
            space()
          }
          write("}")
        },
        SurfaceAst.Let(binding, body) => {
          match (binding.name.kind) {
            SurfaceAst.Wildcard => {
              emitExpr(binding.value)
              write(";")
              space()
              emitExpr(body)
            },
            _ => {
              write("{")
              space()
              emitBinding(binding)
              write(";")
              space()
              emitExpr(body)
              space()
              write("}")
            },
          }
        },
        SurfaceAst.Assign(assignStmt) => {
          emitExpr(assignStmt.target)
          space()
          write("=")
          space()
          emitExpr(assignStmt.value)
        },
      }
    })
  }
  and emitExprUnparen = (expr: SurfaceAst.Expr) => {
    match (expr.kind) {
      SurfaceAst.Paren(inner) => emitExprUnparen(inner),
      _ => emitExpr(expr),
    }
  }
  and emitDirective = (directive: SurfaceAst.Directive) => {
    write("@")
    write(directive.name.text)
    write("(")
    emitCommaSeparated(emitExpr, directive.args)
    write(")")
  }
  and emitBlock = (block: SurfaceAst.Block) => {
    write("{")
    let hasBody = block.items != []
    let rec hasMissingRBrace = (items: List<SurfaceAst.BlockItem>) =>
      match (items) {
        [] => false,
        [item, ...rest] => match (item) {
          SurfaceAst.MarkItem(mark) => match (mark.kind) {
            SurfaceAst.MissingRBrace => true,
            _ => hasMissingRBrace(rest),
          },
          _ => hasMissingRBrace(rest),
        },
      }
    let missingRBrace = hasMissingRBrace(block.items)
    let canFixSemicolonAfter = (prevOpt: Option<SurfaceAst.BlockItem>) =>
      match (prevOpt) {
        Some(SurfaceAst.ExprItem(expr)) => !exprHasHole(expr),
        Some(SurfaceAst.LetItem(binding)) =>
          !patternHasHole(binding.name)
            && match (binding.annotation) {
              Some(t) => !typeHasHole(t),
              None => true,
            }
            && !exprHasHole(binding.value),
        Some(SurfaceAst.DeclGroup(group)) => {
          let bindingIsDecidableLocal = (binding: SurfaceAst.LetBinding) =>
            binding.hasEq
              && !patternHasHole(binding.name)
              && match (binding.annotation) {
                Some(t) => !typeHasHole(t),
                None => true,
              }
              && !exprHasHole(binding.value)
              && !exprHasMissingRBrace(binding.value)
          let rec anyBindingUndecidable = (items: List<SurfaceAst.LetBinding>) =>
            match (items) {
              [] => false,
              [binding, ...rest] =>
                !bindingIsDecidableLocal(binding) || anyBindingUndecidable(rest),
            }
          match (group.kind) {
            SurfaceAst.LetGroup(_) => {
              let bindings = List.flatMap(
                (decl: SurfaceAst.Decl) => match (decl) {
                  SurfaceAst.LetDecl(ld) => ld.bindings,
                  _ => [],
                },
                group.decls
              )
              !anyBindingUndecidable(bindings)
            },
            _ => false,
          }
        },
        _ => false,
      }
    let prevStmtIsConcrete = (prevOpt: Option<SurfaceAst.BlockItem>) =>
      match (prevOpt) {
        Some(SurfaceAst.ExprItem(expr)) =>
          hasConcreteTokenEndingAt(expr.node.span.end),
        Some(SurfaceAst.LetItem(binding)) =>
          hasConcreteTokenEndingAt(binding.node.span.end),
        Some(SurfaceAst.DeclGroup(group)) =>
          hasConcreteTokenEndingAt(group.node.span.end),
        _ => false,
      }
    let prevStmtEnd = (prevOpt: Option<SurfaceAst.BlockItem>) =>
      match (prevOpt) {
        Some(SurfaceAst.ExprItem(expr)) => Some(expr.node.span.end),
        Some(SurfaceAst.LetItem(binding)) => Some(binding.node.span.end),
        Some(SurfaceAst.DeclGroup(group)) => Some(group.node.span.end),
        _ => None,
      }
    if (hasBody) {
      newline()
      indent += 2

      let mut first = true
      let emitSep = () => {
        if (!first) {
          newline()
        } else {
          first = false
        }
      }

      let rec hasNextConcrete = (items: List<SurfaceAst.BlockItem>) =>
        match (items) {
          [] => false,
          [item, ...rest] => match (item) {
            SurfaceAst.ExprItem(_) |
            SurfaceAst.LetItem(_) |
            SurfaceAst.DeclGroup(_) |
            SurfaceAst.TriviaItem(_) |
            SurfaceAst.Directive(_) |
            SurfaceAst.Semicolon => true,
            SurfaceAst.MarkItem(_) => hasNextConcrete(rest),
          },
        }
      let rec emitItems = (
        items: List<SurfaceAst.BlockItem>,
        prevStmt: Option<SurfaceAst.BlockItem>,
      ) => {
        match (items) {
          [] => void,
          [item, ...tail] => {
            match (item) {
              SurfaceAst.ExprItem(expr) => {
                emitSep()
                emitExpr(expr)
                emitItems(tail, Some(item))
              },
              SurfaceAst.LetItem(binding) => {
                emitSep()
                emitBinding(binding)
                emitItems(tail, Some(item))
              },
              SurfaceAst.DeclGroup(group) => {
                emitSep()
                match (group.kind) {
                  SurfaceAst.LetGroup(mods) => {
                    write("let")
                    match (mods) {
                      SurfaceAst.Plain => void,
                      SurfaceAst.Rec => {
                        space()
                        write("rec")
                      },
                      SurfaceAst.Mut => {
                        space()
                        write("mut")
                      },
                    }
                    space()
                    let bindings = List.flatMap(
                      (decl: SurfaceAst.Decl) => match (decl) {
                        SurfaceAst.LetDecl(ld) => ld.bindings,
                        _ => [],
                      },
                      group.decls
                    )
                    match (bindings) {
                      [] => void,
                      [first, ...rest] => {
                        emitLetBindingBare(first)
                        let rec emitAnd = (items: List<SurfaceAst.LetBinding>) => {
                          match (items) {
                            [] => void,
                            [binding, ...tailBindings] => {
                              newline()
                              write("and")
                              space()
                              emitLetBindingBare(binding)
                              emitAnd(tailBindings)
                            },
                          }
                        }
                        emitAnd(rest)
                      },
                    }
                  },
                  _ => void,
                }
                emitItems(tail, Some(item))
              },
              SurfaceAst.Semicolon => {
                write(";")
                emitItems(tail, prevStmt)
              },
              SurfaceAst.MarkItem(mark) => {
                match (mark.kind) {
                  SurfaceAst.MissingSemicolon => {
                    if (mode == Virtual && settings.allowVirtualInsertions) {
                      if (hasNextConcrete(tail)) {
                        write(";")
                      }
                    } else if (settings.insertSemis) {
                      if (
                        canFixSemicolonAfter(prevStmt)
                        && hasNextConcrete(tail)
                        && prevStmtIsConcrete(prevStmt)
                      ) {
                        write(";")
                      }
                    }
                  },
                  SurfaceAst.MissingRBrace => void,
                  _ => void,
                }
                emitItems(tail, prevStmt)
              },
              SurfaceAst.TriviaItem(trivia) => {
                emitSep()
                emitTrivia(trivia)
                emitItems(tail, prevStmt)
              },
              SurfaceAst.Directive(d) => {
                emitSep()
                emitDirective(d)
                emitItems(tail, prevStmt)
              },
            }
          },
        }
      }
      emitItems(block.items, None)

      indent -= 2
      if (!(missingRBrace && mode != Virtual)) {
        newline()
      }
    }
    if (!(missingRBrace && mode != Virtual)) {
      write("}")
    }
  }
  and emitFnItem = (item: SurfaceAst.FnItem) => {
    withAttachments(item.attach, () => {
      match (item.kind) {
        SurfaceAst.Clause(clause) => {
          emitPattern(clause.param)
          match (clause.guard) {
            None => void,
            Some(guardExpr) => {
              space()
              write("when")
              space()
              emitExpr(guardExpr)
            },
          }
          space()
          write("=>")
          space()
          emitBlock(clause.body)
        },
        SurfaceAst.Include(name) => write(name.text),
        SurfaceAst.Trivia(trivia) => emitTrivia(trivia),
        SurfaceAst.Hole(hole) => emitHole(hole),
      }
    })
  }
  and emitLetBindingBare = (binding: SurfaceAst.LetBinding) => {
    emitPattern(binding.name)
    match (binding.annotation) {
      None => void,
      Some(ty) => {
        space()
        write(":")
        space()
        emitTypeExpr(ty)
      },
    }
    if (binding.hasEq || mode == Virtual) {
      space()
      write("=")
      space()
      emitExpr(binding.value)
    }
  }
  and emitBinding = (binding: SurfaceAst.LetBinding) => {
    write("let")
    space()
    emitLetBindingBare(binding)
  }

  let emitTypeDecl = (typeDecl: SurfaceAst.TypeDecl) => {
    write(typeDecl.name.text)
    emitTypeParams(typeDecl.typeParams)
    match (typeDecl.infection) {
      None => void,
      Some(domain) => {
        space()
        write("infectious")
        space()
        write(domain.text)
      },
    }
    emitTypeDeclBody(typeDecl.body)
  }

  let emitRecordDecl = (recordDecl: SurfaceAst.RecordDecl) => {
    write(recordDecl.name.text)
    emitTypeParams(recordDecl.typeParams)
    space()
    write("=")
    space()
    write("{")
    if (recordDecl.fields != []) {
      space()
      emitCommaSeparated(
        (pair: (SurfaceAst.Name, SurfaceAst.TypeExpr)) => {
          let (name, ty) = pair
          write(name.text)
          space()
          write(":")
          space()
          emitTypeExpr(ty)
        },
        recordDecl.fields
      )
      space()
    }
    write("}")
  }

  let emitDecl = (decl: SurfaceAst.Decl) => {
    match (decl) {
      SurfaceAst.LetDecl(letDecl) => {
        match (letDecl.bindings) {
          [] => void,
          [first, ...tail] => {
            emitBinding(first)
            List.forEach((binding: SurfaceAst.LetBinding) => {
              newline()
              emitBinding(binding)
            }, tail)
          },
        }
      },
      SurfaceAst.TypeDecl(typeDecl) => {
        write("type")
        space()
        emitTypeDecl(typeDecl)
      },
      SurfaceAst.RecordDecl(recordDecl) => {
        write("record")
        space()
        emitRecordDecl(recordDecl)
      },
      SurfaceAst.InfixDecl(infixDecl) => {
        match (infixDecl.associativity) {
          SurfaceAst.Left => write("infixl"),
          SurfaceAst.Right => write("infixr"),
          SurfaceAst.NonAssoc => write("infix"),
        }
        space()
        write(toString(infixDecl.precedence))
        space()
        write(infixDecl.name.text)
      },
      SurfaceAst.PrefixDecl(prefixDecl) => {
        write("prefix")
        space()
        write(prefixDecl.name.text)
      },
    }
  }

  let emitTopItem = (item: SurfaceAst.TopItem) => {
    match (item) {
      SurfaceAst.DeclGroup(group) => {
        if (group.exported) {
          write("export")
          space()
        }
        match (group.kind) {
          SurfaceAst.LetGroup(mods) => {
            write("let")
            match (mods) {
              SurfaceAst.Plain => void,
              SurfaceAst.Rec => {
                space()
                write("rec")
              },
              SurfaceAst.Mut => {
                space()
                write("mut")
              },
            }
            space()
            let bindings = List.flatMap(
              (decl: SurfaceAst.Decl) => match (decl) {
                SurfaceAst.LetDecl(ld) => ld.bindings,
                _ => [],
              },
              group.decls
            )
            match (bindings) {
              [] => void,
              [first, ...rest] => {
                emitLetBindingBare(first)
                let rec emitAnd = (items: List<SurfaceAst.LetBinding>) => {
                  match (items) {
                    [] => void,
                    [binding, ...tail] => {
                      newline()
                      write("and")
                      space()
                      emitLetBindingBare(binding)
                      emitAnd(tail)
                    },
                  }
                }
                emitAnd(rest)
              },
            }
          },
          SurfaceAst.TypeGroup(mods) => {
            write("type")
            match (mods) {
              SurfaceAst.Plain => void,
              SurfaceAst.Rec => {
                space()
                write("rec")
              },
            }
            space()
            let types = List.filterMap(
              (decl: SurfaceAst.Decl) => match (decl) {
                SurfaceAst.TypeDecl(td) => Some(td),
                _ => None,
              },
              group.decls
            )
            match (types) {
              [] => void,
              [first, ...rest] => {
                emitTypeDecl(first)
                let rec emitAnd = (items: List<SurfaceAst.TypeDecl>) => {
                  match (items) {
                    [] => void,
                    [decl, ...tail] => {
                      newline()
                      write("and")
                      space()
                      emitTypeDecl(decl)
                      emitAnd(tail)
                    },
                  }
                }
                emitAnd(rest)
              },
            }
          },
          SurfaceAst.RecordGroup(mods) => {
            write("record")
            match (mods) {
              SurfaceAst.Plain => void,
              SurfaceAst.Rec => {
                space()
                write("rec")
              },
            }
            space()
            let records = List.filterMap(
              (decl: SurfaceAst.Decl) => match (decl) {
                SurfaceAst.RecordDecl(rd) => Some(rd),
                _ => None,
              },
              group.decls
            )
            match (records) {
              [] => void,
              [first, ...rest] => {
                emitRecordDecl(first)
                let rec emitAnd = (items: List<SurfaceAst.RecordDecl>) => {
                  match (items) {
                    [] => void,
                    [decl, ...tail] => {
                      newline()
                      write("and")
                      space()
                      emitRecordDecl(decl)
                      emitAnd(tail)
                    },
                  }
                }
                emitAnd(rest)
              },
            }
          },
          SurfaceAst.OpGroup => {
            let mut first = true
            let rec emitDecls = (decls: List<SurfaceAst.Decl>) => {
              match (decls) {
                [] => void,
                [decl, ...tail] => {
                  if (!first) {
                    newline()
                  } else {
                    first = false
                  }
                  emitDecl(decl)
                  emitDecls(tail)
                },
              }
            }
            emitDecls(group.decls)
          },
          SurfaceAst.RuleGroup(kind) => {
            match (kind) {
              SurfaceAst.Domain => write("domain"),
              SurfaceAst.Policy => write("policy"),
              SurfaceAst.Op => write("op"),
              SurfaceAst.Annotate => write("annotate"),
            }
          },
        }
      },
      SurfaceAst.Import(importDecl) => {
        write("import")
        space()
        write(importDecl.modulePath)
      },
      SurfaceAst.Reexport(reexportDecl) => {
        write("reexport")
        space()
        write(reexportDecl.modulePath)
      },
      SurfaceAst.Export(_) => void,
      SurfaceAst.Directive(directive) => emitDirective(directive),
      SurfaceAst.Mark(mark) => match (mark.kind) {
        SurfaceAst.UnknownTopLevel(text) => write(text),
        SurfaceAst.InvalidTopLevel(text) => write(text),
        SurfaceAst.MissingSemicolon => void,
        SurfaceAst.MissingRBrace => void,
        SurfaceAst.MissingToken(text) => write(text),
        SurfaceAst.MissingExpr(text) => write(text),
        SurfaceAst.MissingPattern(text) => write(text),
        SurfaceAst.MissingTypeExpr(text) => write(text),
        SurfaceAst.MissingBlock(text) => write(text),
        SurfaceAst.FormattingMismatch(text) => write(text),
        SurfaceAst.UnexpectedToken(text) => write(text),
      },
      SurfaceAst.Trivia(trivia) => emitTrivia(trivia),
    }
  }

  let bindingIsDecidable = (binding: SurfaceAst.LetBinding) =>
    binding.hasEq
      && !patternHasHole(binding.name)
      && match (binding.annotation) {
        Some(t) => !typeHasHole(t),
        None => true,
      }
      && !exprHasHole(binding.value)
      && !exprHasMissingRBrace(binding.value)

  let bindingHasMissingRBrace = (binding: SurfaceAst.LetBinding) =>
    exprHasMissingRBrace(binding.value)

  let typeDeclIsDecidable = (decl: SurfaceAst.TypeDecl) => match (decl.body) {
    SurfaceAst.Alias(ty) => !typeHasHole(ty),
    SurfaceAst.Variant(cases) => {
      let rec anyCaseHole = (
        items: List<
          (
            SurfaceAst.Name,
            Option<SurfaceAst.TypeExpr>,
            Option<SurfaceAst.Annotation>
          )
        >,
      ) => match (items) {
        [] => false,
        [(_name, payloadOpt, _ann), ...rest] => {
          let hasHole = match (payloadOpt) {
            Some(t) => typeHasHole(t),
            None => false,
          }
          hasHole || anyCaseHole(rest)
        },
      }
      !anyCaseHole(cases)
    },
  }

  let recordDeclIsDecidable = (decl: SurfaceAst.RecordDecl) => {
    let rec anyFieldHole = (items: List<(SurfaceAst.Name, SurfaceAst.TypeExpr)>) =>
      match (items) {
        [] => false,
        [(_name, ty), ...rest] => typeHasHole(ty) || anyFieldHole(rest),
      }
    !anyFieldHole(decl.fields)
  }

  let declIsDecidable = (decl: SurfaceAst.Decl) => match (decl) {
    SurfaceAst.LetDecl(letDecl) => {
      let rec anyBindingUndecidable = (items: List<SurfaceAst.LetBinding>) =>
        match (items) {
          [] => false,
          [binding, ...rest] =>
            !bindingIsDecidable(binding) || anyBindingUndecidable(rest),
        }
      !anyBindingUndecidable(letDecl.bindings)
    },
    SurfaceAst.TypeDecl(typeDecl) => typeDeclIsDecidable(typeDecl),
    SurfaceAst.RecordDecl(recordDecl) => recordDeclIsDecidable(recordDecl),
    SurfaceAst.InfixDecl(_) => true,
    SurfaceAst.PrefixDecl(_) => true,
  }

  let declHasMissingRBrace = (decl: SurfaceAst.Decl) => match (decl) {
    SurfaceAst.LetDecl(letDecl) => {
      let rec anyBindingMissing = (items: List<SurfaceAst.LetBinding>) =>
        match (items) {
          [] => false,
          [binding, ...rest] =>
            bindingHasMissingRBrace(binding) || anyBindingMissing(rest),
        }
      anyBindingMissing(letDecl.bindings)
    },
    _ => false,
  }

  let declGroupIsDecidable = (group: SurfaceAst.DeclGroup) => {
    let rec anyDeclUndecidable = (items: List<SurfaceAst.Decl>) =>
      match (items) {
        [] => false,
        [decl, ...rest] => !declIsDecidable(decl) || anyDeclUndecidable(rest),
      }
    !anyDeclUndecidable(group.decls)
  }

  let declGroupHasMissingRBrace = (group: SurfaceAst.DeclGroup) => {
    let rec anyDeclMissing = (items: List<SurfaceAst.Decl>) => match (items) {
      [] => false,
      [decl, ...rest] => declHasMissingRBrace(decl) || anyDeclMissing(rest),
    }
    anyDeclMissing(group.decls)
  }

  let topItemIsDecidable = (item: SurfaceAst.TopItem) => match (item) {
    SurfaceAst.DeclGroup(group) => declGroupIsDecidable(group),
    SurfaceAst.Import(_) => true,
    SurfaceAst.Reexport(_) => true,
    SurfaceAst.Directive(_) => true,
    _ => false,
  }

  let topItemHasMissingRBrace = (item: SurfaceAst.TopItem) => match (item) {
    SurfaceAst.DeclGroup(group) => declGroupHasMissingRBrace(group),
    _ => false,
  }

  let mut firstTop = true
  let rec emitProgramItems = (items: List<SurfaceAst.TopItem>) => {
    match (items) {
      [] => void,
      [item, ...tail] => {
        if (!firstTop) {
          newline()
          newline()
        } else {
          firstTop = false
        }
        emitTopItem(item)
        let endSpan = topItemSpan(item)
        let missingRBrace = topItemHasMissingRBrace(item)
        let needsTerminator = match (item) {
          SurfaceAst.DeclGroup(_) |
          SurfaceAst.Import(_) |
          SurfaceAst.Reexport(_) |
          SurfaceAst.Directive(_) => true,
          _ => false,
        }
        if (needsTerminator) {
          if (hasTerminatorAfter(endSpan.end) && !missingRBrace) {
            write(";")
          } else if (mode == Virtual && settings.allowVirtualInsertions) {
            write(";")
          } else if (
            settings.insertSemis
            && topItemIsDecidable(item)
            && !missingRBrace
            && hasConcreteTokenEndingAt(endSpan.end)
          ) {
            write(";")
          }
        }
        emitProgramItems(tail)
      },
    }
  }

  emitProgramItems(program.items)

  {
    text: join("", List.reverse(chunks)),
    virtualArtifacts: List.reverse(artifacts),
  }
}

let normalizeTokensForAlignment = (tokens: List<Lexer.Token>) =>
  List.filter((tok: Lexer.Token) => match (tok.kind) {
    Lexer.LineComment(_) => false,
    _ => true,
  }, tokens)

let tokensEqualForAlignment = (a: Lexer.Token, b: Lexer.Token) => a.kind == b.kind

let alignOnce = (sourceText: String, formattedText: String) => {
  let sourceTokens = Array.fromList(normalizeTokensForAlignment(Lexer.lex(sourceText)))
  let formattedTokens = Array.fromList(
    normalizeTokensForAlignment(Lexer.lex(formattedText))
  )
  let sourceLen = Array.length(sourceTokens)
  let formattedLen = Array.length(formattedTokens)

  let mut prefix = 0
  while (
    prefix < sourceLen
    && prefix < formattedLen
    && tokensEqualForAlignment(
      Array.get(prefix, sourceTokens),
      Array.get(prefix, formattedTokens)
    )
  ) {
    prefix += 1
  }

  let mut suffix = 0
  while (suffix < sourceLen - prefix && suffix < formattedLen - prefix) {
    let srcTok = Array.get(sourceLen - 1 - suffix, sourceTokens)
    let fmtTok = Array.get(formattedLen - 1 - suffix, formattedTokens)
    if (tokensEqualForAlignment(srcTok, fmtTok)) {
      suffix += 1
    } else {
      suffix = suffix
      break
    }
  }

  if (prefix == sourceLen && prefix == formattedLen) {
    (formattedText, false, 0, 0, 0, 0)
  } else {
    let sourceStart = if (prefix < sourceLen) {
      Array.get(prefix, sourceTokens).span.start
    } else {
      String.length(sourceText)
    }
    let sourceEnd = if (sourceLen - suffix - 1 >= prefix) {
      Array.get(sourceLen - suffix - 1, sourceTokens).span.end
    } else {
      sourceStart
    }
    let formattedStart = if (prefix < formattedLen) {
      Array.get(prefix, formattedTokens).span.start
    } else {
      String.length(formattedText)
    }
    let formattedEnd = if (formattedLen - suffix - 1 >= prefix) {
      Array.get(formattedLen - suffix - 1, formattedTokens).span.end
    } else {
      formattedStart
    }

    let prefixText = String.slice(0, end=formattedStart, formattedText)
    let middleText = String.slice(sourceStart, end=sourceEnd, sourceText)
    let suffixText = String.slice(
      formattedEnd,
      end=String.length(formattedText),
      formattedText
    )
    let merged = prefixText ++ middleText ++ suffixText
    (merged, true, sourceStart, sourceEnd, formattedStart, formattedEnd)
  }
}

let alignWithOpaqueFallback = (
  sourceText: String,
  formattedText: String,
) => {
  let mut current = formattedText
  let mut changed = false
  let mut lastStart = 0
  let mut lastEnd = 0
  let mut lastFormattedStart = 0
  let mut lastFormattedEnd = 0
  let mut spans: List<(Number, Number, Number, Number)> = []
  let mut attempts = 0
  while (attempts < 32) {
    let (next, didChange, start, end, fmtStart, fmtEnd) = alignOnce(sourceText, current)
    if (!didChange) {
      break
    }
    current = next
    changed = true
    lastStart = start
    lastEnd = end
    lastFormattedStart = fmtStart
    lastFormattedEnd = fmtEnd
    spans = [(start, end, fmtStart, fmtEnd), ...spans]
    attempts += 1
  }
  (
    current,
    changed,
    lastStart,
    lastEnd,
    lastFormattedStart,
    lastFormattedEnd,
    List.reverse(spans),
  )
}

provide record OpaqueSpan {
  sourceStart: Number,
  sourceEnd: Number,
  formattedStart: Number,
  formattedEnd: Number,
}

provide let opaqueSpansFor = (source: String, formattedText: String) => {
  let (_aligned, _changed, _s1, _s2, _f1, _f2, spans) = alignWithOpaqueFallback(
    source,
    formattedText
  )
  List.map(((a, b, c, d)) => {
    { sourceStart: a, sourceEnd: b, formattedStart: c, formattedEnd: d }
  }, spans)
}

provide let opaqueSpansForModeRaw = (source: String, mode: Mode) => {
  let settings = match (mode) {
    Real => realSettings,
    RealFix => realFixSettings,
    Virtual => virtualSettings,
  }
  let raw = renderWithSettings(Parser.parse(source), source, mode, settings)
  opaqueSpansFor(source, raw.text)
}

let alignRealIfNeeded = (source: String, rendered: FormatResult) => {

  let (
    aligned,
    didChange,
    mismatchStart,
    mismatchEnd,
    mismatchFmtStart,
    mismatchFmtEnd,
    _mismatchSpans,
  ) = alignWithOpaqueFallback(source, rendered.text)
  if (didChange) {
    let lc = Source.offsetToLineCol(source, mismatchStart)
    let span = Source.makeSpan(lc.line, lc.col, mismatchStart, mismatchEnd)
    let mark: SurfaceAst.Mark = {
      node: { id: 0, span },
      kind: SurfaceAst.FormattingMismatch("real formatter divergence"),
      expected: SurfaceAst.ExpectToken,
    }
    let expectedSlice = sliceWithContext(source, mismatchStart, mismatchEnd, 5)
    let actualSlice = sliceWithContext(
      rendered.text,
      mismatchFmtStart,
      mismatchFmtEnd,
      5
    )
    let expectedRaw = if (String.length(expectedSlice) == 0) {
      "<empty>"
    } else {
      expectedSlice
    }
    let actualRaw = if (String.length(actualSlice) == 0) {
      "<empty>"
    } else {
      actualSlice
    }
    let expected = truncate(expectedRaw, 120)
    let actual = truncate(actualRaw, 120)
    let diff = "\n-   " ++ actual ++ "\n+   " ++ expected
    let _ = Error.createMarkedError(
      Error.Parsing,
      mark,
      "Formatter could not preserve all tokens; left opaque segment" ++ diff,
      void
    )
    { ...rendered, text: aligned }
  } else {
    rendered
  }
}

record SemicolonAddition {
  anchorOffset: Number,
  text: String,
}

let tokenIsIgnoredForSemis = (tok: Lexer.Token) => match (tok.kind) {
  Lexer.LineComment(_) => true,
  Lexer.Opaque(_) => true,
  Lexer.EOF => true,
  _ => false,
}

let semicolonAdditionsFromRendered = (source: String, renderedText: String) => {
  let sourceTokens = Array.fromList(
    List.filter(tok => !tokenIsIgnoredForSemis(tok), Lexer.lex(source))
  )
  let renderedTokens = Array.fromList(
    List.filter(tok => !tokenIsIgnoredForSemis(tok), Lexer.lex(renderedText))
  )
  let sourceLen = Array.length(sourceTokens)
  let renderedLen = Array.length(renderedTokens)
  let mut si = 0
  let mut ri = 0
  let mut prevSourceEnd = 0
  let mut out: List<SemicolonAddition> = []
  while (si < sourceLen && ri < renderedLen) {
    let src = Array.get(si, sourceTokens)
    let rnd = Array.get(ri, renderedTokens)
    if (src.kind == rnd.kind) {
      prevSourceEnd = src.span.end
      si += 1
      ri += 1
    } else if (rnd.kind == Lexer.SemiColon) {
      let runStart = ri
      while (ri < renderedLen) {
        let tok = Array.get(ri, renderedTokens)
        if (tok.kind == Lexer.SemiColon) {
          ri += 1
        } else {
          break
        }
      }
      let safeToKeep = if (ri >= renderedLen) {
        true
      } else {
        let afterRun = Array.get(ri, renderedTokens)
        afterRun.kind == src.kind
      }
      if (safeToKeep) {
        let count = ri - runStart
        let mut n = 0
        while (n < count) {
          out = [{ anchorOffset: prevSourceEnd, text: ";" }, ...out]
          n += 1
        }
      }
    } else {
      let canDropRendered = if (ri + 1 < renderedLen) {
        let nextRendered = Array.get(ri + 1, renderedTokens)
        nextRendered.kind == src.kind
      } else {
        false
      }
      let canAdvanceSource = if (si + 1 < sourceLen) {
        let nextSource = Array.get(si + 1, sourceTokens)
        rnd.kind == nextSource.kind
      } else {
        false
      }
      if (canDropRendered) {
        ri += 1
      } else if (canAdvanceSource) {
        prevSourceEnd = src.span.end
        si += 1
      } else {
        ri += 1
      }
    }
  }
  if (si >= sourceLen) {
    while (ri < renderedLen) {
      let tok = Array.get(ri, renderedTokens)
      if (tok.kind == Lexer.SemiColon) {
        out = [{ anchorOffset: prevSourceEnd, text: ";" }, ...out]
      }
      ri += 1
    }
  }
  List.reverse(out)
}

let applySemicolonAdditions = (
  source: String,
  additions: List<SemicolonAddition>,
) => {
  let rec takeAtOffset = (
    offset: Number,
    items: List<SemicolonAddition>,
    acc: List<String>,
  ) => match (items) {
    [] => (List.reverse(acc), []),
    [item, ...rest] => if (item.anchorOffset == offset) {
      takeAtOffset(offset, rest, [item.text, ...acc])
    } else {
      (List.reverse(acc), items)
    },
  }
  let len = String.length(source)
  let mut i = 0
  let mut remaining = additions
  let mut out: List<String> = []
  while (i <= len) {
    let (ins, rest) = takeAtOffset(i, remaining, [])
    remaining = rest
    if (ins != []) {
      out = [Array.join("", Array.fromList(ins)), ...out]
    }
    if (i < len) {
      out = [toString(String.charAt(i, source)), ...out]
    }
    i += 1
  }
  Array.join("", Array.fromList(List.reverse(out)))
}

let normalizeRealFixIfNeeded = (source: String, rendered: FormatResult) => {
  let additions = semicolonAdditionsFromRendered(source, rendered.text)
  { ...rendered, text: applySemicolonAdditions(source, additions) }
}

let finalizeRendered = (source: String, mode: Mode, rendered: FormatResult) => {
  if (mode == Real) {
    alignRealIfNeeded(source, rendered)
  } else if (mode == RealFix) {
    normalizeRealFixIfNeeded(source, rendered)
  } else {
    rendered
  }
}

let formatResultWithSettings = (source: String, mode: Mode, settings: Settings) => {
  let program = Parser.parse(source)
  let rendered = renderWithSettings(program, source, mode, settings)
  finalizeRendered(source, mode, rendered)
}

let formatResultWithProgram = (
  program: SurfaceAst.Program,
  source: String,
  mode: Mode,
  settings: Settings,
) => {
  let rendered = renderWithSettings(program, source, mode, settings)
  finalizeRendered(source, mode, rendered)
}

provide let formatResultWithMode = (source: String, mode: Mode) =>
  match (mode) {
    Real => formatResultWithSettings(source, mode, realSettings),
    RealFix => formatResultWithSettings(source, mode, realFixSettings),
    Virtual => formatResultWithSettings(source, mode, virtualSettings),
  }

provide let formatResultWithProgramMode = (
  program: SurfaceAst.Program,
  source: String,
  mode: Mode,
) => match (mode) {
  Real => formatResultWithProgram(program, source, mode, realSettings),
  RealFix => formatResultWithProgram(program, source, mode, realFixSettings),
  Virtual => formatResultWithProgram(program, source, mode, virtualSettings),
}

provide let formatWithMode = (source: String, mode: Mode) => {
  let result = formatResultWithMode(source, mode)
  result.text
}

provide let format = (source: String) => formatWithMode(source, Real)
