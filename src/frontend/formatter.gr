module Formatter

from "array" include Array
from "list" include List
from "../frontend/frontend.gr" include Frontend
from "../core/ast.gr" include Ast

let rec formatExpr = (expr: Ast.Expr) => {
  match (expr.kind) {
    Ast.Lit(Ast.Int(n)) => toString(n),
    Ast.Lit(Ast.Bool(b)) => if (b) { "true" } else { "false" },
    Ast.Lit(Ast.Str(s)) => "\"" ++ s ++ "\"",
    Ast.Lit(Ast.Char(c)) => "'" ++ toString(c) ++ "'",
    Ast.Lit(Ast.Unit) => "()",
    Ast.Ident(name) => name.text,
    Ast.Paren(inner) => "(" ++ formatExpr(inner) ++ ")",
    Ast.Tuple(items) => {
      let rendered = List.map(formatExpr, items)
      "(" ++ Array.join(", ", Array.fromList(rendered)) ++ ")"
    },
    Ast.Block(_) => "{ ... }",
    Ast.Fn(_) => "<fn>",
    Ast.Apply(callee, arg) => formatExpr(callee) ++ "(" ++ formatExpr(arg) ++ ")",
    Ast.InfixChain(_) => "<infix>",
    Ast.Postfix(_) => "<postfix>",
    Ast.RecordLit(_) => "{ ... }",
    Ast.If(cond, thenExpr, elseExpr) => {
      let elsePart = match (elseExpr) {
        None => "",
        Some(e) => " else " ++ formatExpr(e),
      }
      "if " ++ formatExpr(cond) ++ " " ++ formatExpr(thenExpr) ++ elsePart
    },
    Ast.Hole(_) => "?",
    Ast.Lit(_) => "<lit>",
  }
}

let formatBinding = (b: Ast.LetBinding) => {
  "let <pat> = " ++ formatExpr(b.value)
}

let formatTopItem = (item: Ast.TopItem) => {
  match (item) {
    Ast.DeclGroup(dg) => {
      match (dg.decls) {
        [Ast.LetDecl(ld), ..._] => {
          let bindings = List.map(formatBinding, ld.bindings)
          Array.join("\n", Array.fromList(bindings))
        },
        _ => "<decl-group>",
      }
    },
    _ => "<top-item>",
  }
}

let formatProgram = (program: Ast.Program) => {
  let items = List.map(formatTopItem, program.items)
  Array.join("\n\n", Array.fromList(items))
}

provide let format = (source: String) => {
  let program = Frontend.parseAndLower(source)
  formatProgram(program)
}
