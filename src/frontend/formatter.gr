module Formatter

from "array" include Array
from "list" include List
from "string" include String
from "char" include Char

from "../core/surface_ast.gr" include SurfaceAst
from "../core/source.gr" include Source
from "./parser.gr" include Parser
from "./lexer.gr" include Lexer

let join = (sep: String, xs: List<String>) => Array.join(sep, Array.fromList(xs))

let canonicalNonWs = (text: String) => {
  let noSpace = String.replaceAll(" ", "", text)
  let noTab = String.replaceAll("\t", "", noSpace)
  let noLf = String.replaceAll("\n", "", noTab)
  String.replaceAll("\r", "", noLf)
}

provide enum Mode {
  Real,
  Virtual,
}

provide record VirtualArtifact {
  kind: String,
  text: String,
  start: Number,
  end: Number,
  reason: String,
}

provide record FormatResult {
  text: String,
  virtualArtifacts: List<VirtualArtifact>,
}

record Settings {
  allowVirtualInsertions: Bool,
}

let realSettings = { allowVirtualInsertions: false }
let virtualSettings = { allowVirtualInsertions: true }

let rec spaces = (n: Number) => {
  if (n <= 0) {
    ""
  } else {
    " " ++ spaces(n - 1)
  }
}

let artifactFromVirtual = (text: String, anchor: Number, reason: String) => {
  {
    kind: "ghostToken",
    text,
    start: anchor,
    end: anchor,
    reason,
  }
}

let renderWithSettings = (
  program: SurfaceAst.Program,
  source: String,
  mode: Mode,
  settings: Settings,
) => {
  let tokens: List<Lexer.Token> = Lexer.lex(source)
  let tokensNoComments: List<Lexer.Token> = List.filter(
    (tok: Lexer.Token) =>
      match (tok.kind) {
        Lexer.LineComment(_) => false,
        _ => true,
      },
    tokens,
  )
  let hasTerminatorAfter = (endIndex: Number) => {
    let rec find = (tokens: List<Lexer.Token>) => {
      match (tokens) {
        [] => false,
        [tok, ...tail] =>
          if (tok.span.start < endIndex) {
            find(tail)
          } else {
            match (tok.kind) {
              Lexer.SemiColon => true,
              _ => false,
            }
          },
      }
    }
    find(tokensNoComments)
  }

  let topItemSpan = (item: SurfaceAst.TopItem) =>
    match (item) {
      SurfaceAst.DeclGroup(group) => group.node.span,
      SurfaceAst.Import(importDecl) => importDecl.node.span,
      SurfaceAst.Reexport(reexportDecl) => reexportDecl.node.span,
      SurfaceAst.Export(exportDecl) => exportDecl.node.span,
      SurfaceAst.Directive(directive) => directive.name.node.span,
      SurfaceAst.Mark(mark) => mark.node.span,
      SurfaceAst.Trivia(trivia) => trivia.node.span,
    }
  let mut chunks: List<String> = []
  let mut artifacts: List<VirtualArtifact> = []
  let mut indent = 0
  let mut atLineStart = true

  let write = (text: String) => {
    if (atLineStart) {
      chunks = [spaces(indent), ...chunks]
      atLineStart = false
    }
    chunks = [text, ...chunks]
  }

  let newline = () => {
    chunks = ["\n", ...chunks]
    atLineStart = true
  }

  let space = () => {
    if (!atLineStart) {
      chunks = [" ", ...chunks]
    }
  }

  let emitVirtual = (text: String, anchor: Number, reason: String) => {
    if (mode == Virtual && settings.allowVirtualInsertions) {
      write(text)
      artifacts = [artifactFromVirtual(text, anchor, reason), ...artifacts]
    }
  }

  let rec emitTrivia = (trivia: SurfaceAst.Trivia) => {
    match (trivia.kind) {
      SurfaceAst.LineComment(text) => write(text),
      SurfaceAst.BlockComment(text) => write(text),
      SurfaceAst.Opaque(text) => write(text),
    }
  }

  let rec emitTriviaInline = (triviaList: List<SurfaceAst.Trivia>) => {
    match (triviaList) {
      [] => void,
      [single] => emitTrivia(single),
      [head, ...tail] => {
        emitTrivia(head)
        space()
        emitTriviaInline(tail)
      },
    }
  }

  let rec emitTriviaLines = (triviaList: List<SurfaceAst.Trivia>) => {
    match (triviaList) {
      [] => void,
      [single] => emitTrivia(single),
      [head, ...tail] => {
        emitTrivia(head)
        newline()
        emitTriviaLines(tail)
      },
    }
  }

  let withAttachments = (attach: SurfaceAst.Attachments, emitCore) => {
    if (attach.leading != []) {
      emitTriviaLines(attach.leading)
      newline()
    }
    emitCore()
    if (attach.trailing != []) {
      space()
      emitTriviaInline(attach.trailing)
    }
    if (attach.dangling != []) {
      newline()
      emitTriviaLines(attach.dangling)
    }
  }

  let rec emitCommaSeparated = (emitOne, items) => {
    match (items) {
      [] => void,
      [single] => emitOne(single),
      [head, ...tail] => {
        emitOne(head)
        write(",")
        space()
        emitCommaSeparated(emitOne, tail)
      },
    }
  }

let rec emitPattern = (pattern: SurfaceAst.Pattern) => {
    withAttachments(
      pattern.attach,
      () => {
        match (pattern.kind) {
          SurfaceAst.Hole(_) => write("?"),
          SurfaceAst.Wildcard => write("_"),
          SurfaceAst.Var(name) => write(name.text),
          SurfaceAst.Pin(name) => {
            write(name.text)
          },
          SurfaceAst.Lit(SurfaceAst.Int(n)) => write(toString(n)),
          SurfaceAst.Lit(SurfaceAst.Bool(b)) => write(if (b) { "true" } else { "false" }),
          SurfaceAst.Lit(SurfaceAst.Char(c)) => write("'" ++ toString(c) ++ "'"),
          SurfaceAst.Lit(SurfaceAst.Str(s)) => write("\"" ++ s ++ "\""),
          SurfaceAst.Lit(SurfaceAst.Unit) => write("()"),
          SurfaceAst.Lit(_) => write("<lit>"),
          SurfaceAst.Constructor(name, args) => {
            write(name.text)
            if (args != []) {
              write("(")
              emitCommaSeparated(emitPattern, args)
              write(")")
            }
          },
          SurfaceAst.Tuple(items) => {
            write("(")
            emitCommaSeparated(emitPattern, items)
            write(")")
          },
          SurfaceAst.List(items, rest) => {
            write("[")
            emitCommaSeparated(emitPattern, items)
            match (rest) {
              None => void,
              Some(r) => {
                if (items != []) {
                  write(",")
                  space()
                }
                write("..")
                space()
                emitPattern(r)
              },
            }
            write("]")
          },
          SurfaceAst.AllErrors => write("AllErrors"),
        }
      },
    )
  }

  let rec emitTypeExpr = (typeExpr: SurfaceAst.TypeExpr) => {
    match (typeExpr.kind) {
      SurfaceAst.Hole(_) => write("?"),
      SurfaceAst.Var(name) => write(name.text),
      SurfaceAst.Ref(name, args) => {
        write(name.text)
        if (args != []) {
          write("<")
          emitCommaSeparated(emitTypeExpr, args)
          write(">")
        }
      },
      SurfaceAst.Tuple(items) => {
        write("(")
        emitCommaSeparated(emitTypeExpr, items)
        write(")")
      },
      SurfaceAst.Record(fields) => {
        write("{")
        if (fields != []) {
          space()
          emitCommaSeparated(
            (pair: (SurfaceAst.Name, SurfaceAst.TypeExpr)) => {
              let (name, ty) = pair
              write(name.text)
              space()
              write(":")
              space()
              emitTypeExpr(ty)
            },
            fields,
          )
          space()
        }
        write("}")
      },
      SurfaceAst.Arrow(params, result) => {
        write("(")
        emitCommaSeparated(emitTypeExpr, params)
        write(")")
        space()
        write("=>")
        space()
        emitTypeExpr(result)
      },
      SurfaceAst.Ptr(inner, stateOpt) => {
        write("Ptr")
        write("<")
        emitTypeExpr(inner)
        match (stateOpt) {
          None => void,
          Some(name) => {
            write(",")
            space()
            write(name.text)
          },
        }
        write(">")
      },
      SurfaceAst.EffectRow(cases, hasTailWildcard) => {
        write("[")
        emitCommaSeparated(
          (effectCase: SurfaceAst.EffectCase) => {
            write(effectCase.name.text)
            match (effectCase.payload) {
              None => void,
              Some(payload) => {
                write("(")
                emitTypeExpr(payload)
                write(")")
              },
            }
          },
          cases,
        )
        if (hasTailWildcard) {
          if (cases != []) {
            write(",")
            space()
          }
          write("..")
        }
        write("]")
      },
      SurfaceAst.UnitType => write("Void"),
    }
  }

  let emitTypeParams = (params: List<SurfaceAst.Name>) => {
    if (params != []) {
      write("<")
      emitCommaSeparated((name: SurfaceAst.Name) => write(name.text), params)
      write(">")
    }
  }

  let emitTypeConstructor = (entry: (SurfaceAst.Name, Option<SurfaceAst.TypeExpr>, Option<SurfaceAst.Annotation>)) => {
    let (name, payload, annotation) = entry
    write(name.text)
    match (payload) {
      None => void,
      Some(ty) => {
        write("(")
        emitTypeExpr(ty)
        write(")")
      },
    }
    match (annotation) {
      None => void,
      Some(text) => {
        space()
        write(text)
      },
    }
  }

  let emitTypeDeclBody = (body: SurfaceAst.TypeDeclBody) => {
    match (body) {
      SurfaceAst.Alias(typeExpr) => {
        space()
        write("=")
        space()
        emitTypeExpr(typeExpr)
      },
      SurfaceAst.Variant(cases) => {
        space()
        write("=")
        space()
        match (cases) {
          [] => void,
          [single] => {
            write("|")
            space()
            emitTypeConstructor(single)
          },
          [first, ...tail] => {
            emitTypeConstructor(first)
            let rec emitTail = (rest: List<(SurfaceAst.Name, Option<SurfaceAst.TypeExpr>, Option<SurfaceAst.Annotation>)>) => {
              match (rest) {
                [] => void,
                [head, ...restTail] => {
                  space()
                  write("|")
                  space()
                  emitTypeConstructor(head)
                  emitTail(restTail)
                },
              }
            }
            emitTail(tail)
          },
        }
      },
    }
  }

  let rec emitExpr = (expr: SurfaceAst.Expr) => {
    withAttachments(
      expr.attach,
      () => {
        let emitRecordItems = (items: List<SurfaceAst.RecordItem>) => {
          if (items != []) {
            space()
            emitCommaSeparated(
              (item) =>
                match (item) {
                  SurfaceAst.Field(name, value) => {
                    match (value.kind) {
                      SurfaceAst.Ident({ _, text }) when text == name.text =>
                        write(name.text),
                      _ => {
                        write(name.text)
                        space()
                        write("=")
                        space()
                        emitExpr(value)
                      },
                    }
                  },
                  SurfaceAst.Spread(e) => {
                    write("..")
                    emitExpr(e)
                  },
                },
              items,
            )
            space()
          }
        }

        let isConstructorName = (text: String) => {
          if (String.length(text) == 0) {
            false
          } else {
            let ch = String.charAt(0, text)
            let code = Char.code(ch)
            code >= Char.code('A') && code <= Char.code('Z')
          }
        }

        match (expr.kind) {
          SurfaceAst.Lit(SurfaceAst.Int(n)) => write(toString(n)),
          SurfaceAst.Lit(SurfaceAst.Bool(b)) => write(if (b) { "true" } else { "false" }),
          SurfaceAst.Lit(SurfaceAst.Str(s)) => write("\"" ++ s ++ "\""),
          SurfaceAst.Lit(SurfaceAst.Char(c)) => write("'" ++ toString(c) ++ "'"),
          SurfaceAst.Lit(SurfaceAst.Unit) => write("()"),
          SurfaceAst.Lit(_) => write("<lit>"),
          SurfaceAst.Ident(name) => write(name.text),
          SurfaceAst.Paren(inner) => {
            write("(")
            emitExpr(inner)
            write(")")
          },
          SurfaceAst.Tuple(items) => {
            write("(")
            emitCommaSeparated(emitExpr, items)
            write(")")
          },
          SurfaceAst.Hole(_) => write("?"),
          SurfaceAst.RecordLit(items) => {
            write(".{")
            emitRecordItems(items)
            write("}")
          },
          SurfaceAst.Postfix(postfix) => {
            emitExpr(postfix.target)
            let rec emitSegments = (segments: List<SurfaceAst.PostfixSegment>) => {
              match (segments) {
                [] => void,
                [segment, ...tail] => {
                  match (segment) {
                    SurfaceAst.Call(args) => {
                      write("(")
                      emitCommaSeparated(emitExpr, args)
                      write(")")
                    },
                    SurfaceAst.Project(name) => {
                      write(".")
                      write(name.text)
                    },
                    SurfaceAst.Index(indexExpr) => {
                      write("[")
                      emitExpr(indexExpr)
                      write("]")
                    },
                  }
                  emitSegments(tail)
                },
              }
            }
            emitSegments(postfix.segments)
          },
          SurfaceAst.InfixChain(chain) => {
            emitExpr(chain.first)
            let rec emitRest = (rest: List<(SurfaceAst.Name, SurfaceAst.Expr)>) => {
              match (rest) {
                [] => void,
                [(op, rhs), ...tail] => {
                  space()
                  write(op.text)
                  space()
                  emitExpr(rhs)
                  emitRest(tail)
                },
              }
            }
            emitRest(chain.rest)
          },
          SurfaceAst.Apply(callee, arg) => {
            match ((callee.kind, arg.kind)) {
              (SurfaceAst.Ident(name), SurfaceAst.RecordLit(items))
                when isConstructorName(name.text) => {
                  write(name.text)
                  write("{")
                  emitRecordItems(items)
                  write("}")
                },
              (SurfaceAst.Ident(name), SurfaceAst.Tuple(items))
                when isConstructorName(name.text) => {
                  write(name.text)
                  write("(")
                  emitCommaSeparated(emitExpr, items)
                  write(")")
                },
              _ => {
                emitExpr(callee)
                write("(")
                emitExpr(arg)
                write(")")
              },
            }
          },
          SurfaceAst.Block(block) => emitBlock(block),
          SurfaceAst.If(cond, thenExpr, elseExpr) => {
            write("if")
            space()
            emitExpr(cond)
            space()
            emitExpr(thenExpr)
            match (elseExpr) {
              None => void,
              Some(e) => {
                space()
                write("else")
                space()
                emitExpr(e)
              },
            }
          },
          SurfaceAst.Fn(fnExpr) => {
            match (fnExpr.items) {
              [{
                kind: SurfaceAst.Clause({
                  param: { kind: SurfaceAst.Wildcard, _ },
                  guard: None,
                  body,
                  _
                }),
                _
              }] => {
                write("=>")
                space()
                emitBlock(body)
              },
              _ => {
                write("match")
                space()
                write("{")
                if (fnExpr.items != []) {
                  space()
                  emitCommaSeparated(emitFnItem, fnExpr.items)
                  space()
                }
                write("}")
              },
            }
          },
          SurfaceAst.Match(matchExpr) => {
            write("match")
            match (matchExpr.scrutinee) {
              None => {
                space()
              },
              Some(scrutinee) => {
                match (scrutinee.kind) {
                  SurfaceAst.Tuple(_) => emitExpr(scrutinee),
                  _ => {
                    write("(")
                    emitExprUnparen(scrutinee)
                    write(")")
                  },
                }
                space()
                if (matchExpr.arrowSugar) {
                  write("=>")
                  space()
                }
              },
            }
            write("{")
            if (matchExpr.bundle.items != []) {
              space()
              emitCommaSeparated(emitFnItem, matchExpr.bundle.items)
              space()
            }
            write("}")
          },
          SurfaceAst.Let(binding, body) => {
            match (binding.name.kind) {
              SurfaceAst.Wildcard => {
                emitExpr(binding.value)
                write(";")
                space()
                emitExpr(body)
              },
              _ => {
                write("{")
                space()
                emitBinding(binding)
                write(";")
                space()
                emitExpr(body)
                space()
                write("}")
              },
            }
          },
          SurfaceAst.Assign(assignStmt) => {
            emitExpr(assignStmt.target)
            space()
            write("=")
            space()
            emitExpr(assignStmt.value)
          },
        }
      },
    )
  }

  and emitExprUnparen = (expr: SurfaceAst.Expr) => {
    match (expr.kind) {
      SurfaceAst.Paren(inner) => emitExprUnparen(inner),
      _ => emitExpr(expr),
    }
  }

  and emitDirective = (directive: SurfaceAst.Directive) => {
    write("@")
    write(directive.name.text)
    write("(")
    emitCommaSeparated(emitExpr, directive.args)
    write(")")
  }

  and emitBlock = (block: SurfaceAst.Block) => {
    write("{")
    let hasBody = block.items != []
    if (hasBody) {
      newline()
      indent = indent + 2

      let mut first = true
      let emitSep = () => {
        if (!first) {
          newline()
        } else {
          first = false
        }
      }

      let rec emitItems = (items: List<SurfaceAst.BlockItem>) => {
        match (items) {
          [] => void,
          [item, ...tail] => {
            emitSep()
            match (item) {
              SurfaceAst.ExprItem(expr, terminated) => {
                emitExpr(expr)
                if (terminated) {
                  write(";")
                }
              },
              SurfaceAst.LetItem(binding, terminated) => {
                emitBinding(binding)
                if (terminated) {
                  write(";")
                }
              },
              SurfaceAst.TriviaItem(trivia) => emitTrivia(trivia),
              SurfaceAst.Directive(d) => emitDirective(d),
            }
            emitItems(tail)
          },
        }
      }
      emitItems(block.items)

      indent = indent - 2
      newline()
    }
    write("}")
  }

  and emitFnItem = (item: SurfaceAst.FnItem) => {
    withAttachments(
      item.attach,
      () => {
        match (item.kind) {
          SurfaceAst.Clause(clause) => {
            emitPattern(clause.param)
            match (clause.guard) {
              None => void,
              Some(guardExpr) => {
                space()
                write("when")
                space()
                emitExpr(guardExpr)
              },
            }
            space()
            write("=>")
            space()
            emitBlock(clause.body)
          },
          SurfaceAst.Include(name) => write(name.text),
          SurfaceAst.Trivia(trivia) => emitTrivia(trivia),
          SurfaceAst.Hole(_) => write("?"),
        }
      },
    )
  }

  and emitLetBindingBare = (binding: SurfaceAst.LetBinding) => {
    emitPattern(binding.name)
    match (binding.annotation) {
      None => void,
      Some(ty) => {
        space()
        write(":")
        space()
        emitTypeExpr(ty)
      },
    }
    space()
    write("=")
    space()
    emitExpr(binding.value)
  }

  and emitBinding = (binding: SurfaceAst.LetBinding) => {
    write("let")
    space()
    emitLetBindingBare(binding)
  }

  let emitTypeDecl = (typeDecl: SurfaceAst.TypeDecl) => {
    write(typeDecl.name.text)
    emitTypeParams(typeDecl.typeParams)
    match (typeDecl.infection) {
      None => void,
      Some(domain) => {
        space()
        write("infectious")
        space()
        write(domain.text)
      },
    }
    emitTypeDeclBody(typeDecl.body)
  }

  let emitRecordDecl = (recordDecl: SurfaceAst.RecordDecl) => {
    write(recordDecl.name.text)
    emitTypeParams(recordDecl.typeParams)
    space()
    write("=")
    space()
    write("{")
    if (recordDecl.fields != []) {
      space()
      emitCommaSeparated(
        (pair: (SurfaceAst.Name, SurfaceAst.TypeExpr)) => {
          let (name, ty) = pair
          write(name.text)
          space()
          write(":")
          space()
          emitTypeExpr(ty)
        },
        recordDecl.fields,
      )
      space()
    }
    write("}")
  }

  let emitDecl = (decl: SurfaceAst.Decl) => {
    match (decl) {
      SurfaceAst.LetDecl(letDecl) => {
        match (letDecl.bindings) {
          [] => void,
          [first, ...tail] => {
            emitBinding(first)
            List.forEach(
              (binding: SurfaceAst.LetBinding) => {
                newline()
                emitBinding(binding)
              },
              tail,
            )
          },
        }
      },
      SurfaceAst.TypeDecl(typeDecl) => {
        write("type")
        space()
        emitTypeDecl(typeDecl)
      },
      SurfaceAst.RecordDecl(recordDecl) => {
        write("record")
        space()
        emitRecordDecl(recordDecl)
      },
      SurfaceAst.InfixDecl(infixDecl) => {
        match (infixDecl.associativity) {
          SurfaceAst.Left => write("infixl"),
          SurfaceAst.Right => write("infixr"),
          SurfaceAst.NonAssoc => write("infix"),
        }
        space()
        write(toString(infixDecl.precedence))
        space()
        write(infixDecl.name.text)
      },
      SurfaceAst.PrefixDecl(prefixDecl) => {
        write("prefix")
        space()
        write(prefixDecl.name.text)
      },
    }
  }

  let emitTopItem = (item: SurfaceAst.TopItem) => {
    match (item) {
      SurfaceAst.DeclGroup(group) => {
        if (group.exported) {
          write("export")
          space()
        }
        match (group.kind) {
          SurfaceAst.LetGroup(mods) => {
            write("let")
            match (mods) {
              SurfaceAst.Plain => void,
              SurfaceAst.Rec => {
                space()
                write("rec")
              },
              SurfaceAst.Mut => {
                space()
                write("mut")
              },
            }
            space()
            let bindings = List.flatMap(
              (decl: SurfaceAst.Decl) =>
                match (decl) {
                  SurfaceAst.LetDecl(ld) => ld.bindings,
                  _ => [],
                },
              group.decls,
            )
            match (bindings) {
              [] => void,
              [first, ...rest] => {
                emitLetBindingBare(first)
                let rec emitAnd = (items: List<SurfaceAst.LetBinding>) => {
                  match (items) {
                    [] => void,
                    [binding, ...tail] => {
                      newline()
                      write("and")
                      space()
                      emitLetBindingBare(binding)
                      emitAnd(tail)
                    },
                  }
                }
                emitAnd(rest)
              },
            }
          },
          SurfaceAst.TypeGroup(mods) => {
            write("type")
            match (mods) {
              SurfaceAst.Plain => void,
              SurfaceAst.Rec => {
                space()
                write("rec")
              },
            }
            space()
            let types = List.filterMap(
              (decl: SurfaceAst.Decl) =>
                match (decl) {
                  SurfaceAst.TypeDecl(td) => Some(td),
                  _ => None,
                },
              group.decls,
            )
            match (types) {
              [] => void,
              [first, ...rest] => {
                emitTypeDecl(first)
                let rec emitAnd = (items: List<SurfaceAst.TypeDecl>) => {
                  match (items) {
                    [] => void,
                    [decl, ...tail] => {
                      newline()
                      write("and")
                      space()
                      emitTypeDecl(decl)
                      emitAnd(tail)
                    },
                  }
                }
                emitAnd(rest)
              },
            }
          },
          SurfaceAst.RecordGroup(mods) => {
            write("record")
            match (mods) {
              SurfaceAst.Plain => void,
              SurfaceAst.Rec => {
                space()
                write("rec")
              },
            }
            space()
            let records = List.filterMap(
              (decl: SurfaceAst.Decl) =>
                match (decl) {
                  SurfaceAst.RecordDecl(rd) => Some(rd),
                  _ => None,
                },
              group.decls,
            )
            match (records) {
              [] => void,
              [first, ...rest] => {
                emitRecordDecl(first)
                let rec emitAnd = (items: List<SurfaceAst.RecordDecl>) => {
                  match (items) {
                    [] => void,
                    [decl, ...tail] => {
                      newline()
                      write("and")
                      space()
                      emitRecordDecl(decl)
                      emitAnd(tail)
                    },
                  }
                }
                emitAnd(rest)
              },
            }
          },
          SurfaceAst.OpGroup => {
            let mut first = true
            let rec emitDecls = (decls: List<SurfaceAst.Decl>) => {
              match (decls) {
                [] => void,
                [decl, ...tail] => {
                  if (!first) {
                    newline()
                  } else {
                    first = false
                  }
                  emitDecl(decl)
                  emitDecls(tail)
                },
              }
            }
            emitDecls(group.decls)
          },
          SurfaceAst.RuleGroup(kind) => {
            match (kind) {
              SurfaceAst.Domain => write("domain"),
              SurfaceAst.Policy => write("policy"),
              SurfaceAst.Op => write("op"),
              SurfaceAst.Annotate => write("annotate"),
            }
          },
        }
      },
      SurfaceAst.Import(importDecl) => {
        write("import")
        space()
        write(importDecl.modulePath)
      },
      SurfaceAst.Reexport(reexportDecl) => {
        write("reexport")
        space()
        write(reexportDecl.modulePath)
      },
      SurfaceAst.Export(_) => void,
      SurfaceAst.Directive(directive) => emitDirective(directive),
      SurfaceAst.Mark(mark) =>
        match (mark.kind) {
          SurfaceAst.UnknownTopLevel(text) => write(text),
          SurfaceAst.InvalidTopLevel(text) => write(text),
        },
      SurfaceAst.Trivia(trivia) => emitTrivia(trivia),
    }
  }

  let mut firstTop = true
  let rec emitProgramItems = (items: List<SurfaceAst.TopItem>) => {
    match (items) {
      [] => void,
      [item, ...tail] => {
        if (!firstTop) {
          newline()
          newline()
        } else {
          firstTop = false
        }
        emitTopItem(item)
        let endSpan = topItemSpan(item)
        if (hasTerminatorAfter(endSpan.end)) {
          write(";")
        }
        emitProgramItems(tail)
      },
    }
  }

  emitProgramItems(program.items)

  {
    text: join("", List.reverse(chunks)),
    virtualArtifacts: List.reverse(artifacts),
  }
}

let formatResultWithSettings = (source: String, mode: Mode, settings: Settings) => {
  let program = Parser.parse(source)
  let rendered = renderWithSettings(program, source, mode, settings)
  rendered
}

provide let formatResultWithMode = (source: String, mode: Mode) =>
  match (mode) {
    Real => formatResultWithSettings(source, mode, realSettings),
    Virtual => formatResultWithSettings(source, mode, virtualSettings),
  }

provide let formatWithMode = (source: String, mode: Mode) => {
  let result = formatResultWithMode(source, mode)
  result.text
}

provide let format = (source: String) => formatWithMode(source, Real)
