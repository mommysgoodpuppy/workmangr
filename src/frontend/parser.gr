module Parser

from "runtime/unsafe/panic" include Panic
use Panic.{ panic }
from "list" include List
from "string" include String

from "../core/ast.gr" include Ast
use Ast.{ type TopLevel }
from "./lexer.gr" include Lexer
from "../core/source.gr" include Source

from "../util.gr" include Util
use Util.{ testStr }

record ParseState {
  tokens: List<Lexer.Token>,
  nextId: Number, // token id
  allTokens: List<Lexer.Token>,
}

// id +1
let freshId = (state: ParseState) => {
  let id = state.nextId
  (id, { ...state, nextId: id + 1 })
}

// drop 1 token from the list
let dropToken = (tokens: List<Lexer.Token>) => match (tokens) {
  [_head, ...tail] => tail,
  [] => [],
}

// inspect token
let currentToken = (state: ParseState) => match (state.tokens) {
  [head, ..._tail] => head,
  [] => { kind: Lexer.EOF, span: Source.makeSpan(1, 1, 0, 0), mate: None },
}

//return token at an index
let rec tokenAt = (tokens: List<Lexer.Token>, index: Number) => {
  if (index < 0) {
    None
  } else {
    match (tokens) {
      [] => None,
      [head, ...tail] => if (index == 0) {
        Some(head)
      } else {
        tokenAt(tail, index - 1)
      },
    }
  }
}

// check token validity
let kindIs = (kind, expected) => kind == expected

//expect type
let expectSimple = (expected, state: ParseState) => {
  let tok = currentToken(state)
  if (kindIs(tok.kind, expected)) {
    (tok, { ...state, tokens: dropToken(state.tokens) })
  } else {
    let str = "Parse error: unexpected token " ++ Lexer.tokenToString(tok)
    Panic.panic(str)
  }
}

//expect name
let expectName = (state: ParseState) => {
  let tok = currentToken(state)
  match (tok.kind) {
    Lexer.LitName(name) =>
      (name, tok, { ...state, tokens: dropToken(state.tokens) }),
    _ => Panic.panic("Parse error: expected identifier"),
  }
}

//expect keyword tokenized as a name
let expectKeyword = (keyword: String, state: ParseState) => {
  let tok = currentToken(state)
  match (tok.kind) {
    Lexer.LitName(name) when name == keyword =>
      (tok, { ...state, tokens: dropToken(state.tokens) }),
    _ => Panic.panic("Parse error: expected keyword"),
  }
}

//fetch the mate of a token that has one
let fetchMate = (state: ParseState, tok: Lexer.Token) => {
  match (tok.mate) {
    Some(mateIndex) => {
      let rec find = (ts: List<Lexer.Token>) => match (ts) {
        [] => panic("Mate not found"),
        [h, ...t] => if (h.span.start == mateIndex) {
          h
        } else {
          find(t)
        },
      }
      find(state.allTokens)
    },
    None => panic("No mate"),
  }
}

//create a span from the end token
let spanFromTokens = (startSpan: Source.Span, endSpan: Source.Span) =>
  Source.makeSpan(startSpan.line, startSpan.col, startSpan.start, endSpan.end)

let spanFromEnd = (state: ParseState, endTok: Lexer.Token) => {
  let startTok = fetchMate(state, endTok)
  spanFromTokens(startTok.span, endTok.span)
}

//parse
let rec parseExpr = (state: ParseState) => {
  let (expr: Ast.Expr, state1) = parseTerm(state)
  match (currentToken(state1).kind) {
    Lexer.FatArrow => {
      let (id, stateAfterId) = freshId(state1)
      let (_, state2) = expectSimple(Lexer.FatArrow, stateAfterId)
      let (rhs, state3): (Ast.Expr, ParseState) = parseExpr(state2)
      let span = spanFromTokens(expr.span, rhs.span)
      let node: Ast.Expr = {
        id,
        span,
        kind: Ast.Infix(Ast.OpFatArrow, expr, rhs),
      }
      (node, state3)
    },
    _ => (expr, state1),
  }
}
and parseTerm = (state: ParseState) => {
  let tok = currentToken(state)
  match (tok.kind) {
    Lexer.LBrace => parseBlock(state),
    _ => parsePrimary(state),
  }
}
and parseBlock = (state: ParseState) => {
  let (id, state1) = freshId(state)
  let (_, state2) = expectSimple(Lexer.LBrace, state1)
  let (inner, state3): (Ast.Expr, ParseState) = parseExpr(state2)
  let (rbraceTok, state4): (Lexer.Token, ParseState) = expectSimple(
    Lexer.RBrace,
    state3
  )
  let span = spanFromEnd(state4, rbraceTok)
  let expr: Ast.Expr = { id, span, kind: Ast.Block(inner) }
  (expr, state4)
}
and parsePrimary = (state: ParseState) => {
  let (id, state1) = freshId(state)
  let tok = currentToken(state1)

  match (tok.kind) {
    Lexer.LitNum(value) => {
      let state2 = { ...state1, tokens: dropToken(state1.tokens) }
      let expr: Ast.Expr = { id, span: tok.span, kind: Ast.IntLit(value) }
      (expr, state2)
    },
    Lexer.LitString(value) => {
      let state2 = { ...state1, tokens: dropToken(state1.tokens) }
      let expr: Ast.Expr = { id, span: tok.span, kind: Ast.StrLit(value) }
      (expr, state2)
    },
    Lexer.LitChar(value) => {
      let state2 = { ...state1, tokens: dropToken(state1.tokens) }
      let expr: Ast.Expr = { id, span: tok.span, kind: Ast.CharLit(value) }
      (expr, state2)
    },
    Lexer.LitName(name) => {
      let state2 = { ...state1, tokens: dropToken(state1.tokens) }
      let expr: Ast.Expr = { id, span: tok.span, kind: Ast.Ident(name) }
      (expr, state2)
    },
    Lexer.LParen => {
      let (_, state2) = expectSimple(Lexer.LParen, state1)
      if (kindIs(currentToken(state2).kind, Lexer.RParen)) {
        let (rparenTok, state3) = expectSimple(Lexer.RParen, state2)
        let span = spanFromTokens(tok.span, rparenTok.span)
        let expr: Ast.Expr = { id, span, kind: Ast.Unit }
        (expr, state3)
      } else {
        let (inner, state3) = parseExpr(state2)
        if (kindIs(currentToken(state3).kind, Lexer.Comma)) {
          let mut exprs = [inner]
          let mut currentState = state3
          while (kindIs(currentToken(currentState).kind, Lexer.Comma)) {
            let (_, state_temp) = expectSimple(Lexer.Comma, currentState)
            let (nextExpr, state_next) = parseExpr(state_temp)
            exprs = [nextExpr, ...exprs]
            currentState = state_next
          }
          let (rparenTok, state4) = expectSimple(Lexer.RParen, currentState)
          let span = spanFromTokens(tok.span, rparenTok.span)
          let expr: Ast.Expr = {
            id,
            span,
            kind: Ast.Tuple(List.reverse(exprs)),
          }
          (expr, state4)
        } else {
          let (rparenTok, state4) = expectSimple(Lexer.RParen, state3)
          let span = spanFromTokens(tok.span, rparenTok.span)
          let expr: Ast.Expr = { id, span, kind: Ast.Paren(inner) }
          (expr, state4)
        }
      }
    },
    Lexer.Question => {
      let state2 = { ...state1, tokens: dropToken(state1.tokens) }
      let expr: Ast.Expr = { id, span: tok.span, kind: Ast.Unknown }
      (expr, state2)
    },
    _ => Panic.panic("Parse error: expected expression"),
  }
}

let rec parseTopLevels = (state: ParseState) => {
  let tok = currentToken(state)
  match (tok.kind) {
    Lexer.EOF => ([], state),
    Lexer.SemiColon => {
      // Skip semicolons
      let state1 = { ...state, tokens: dropToken(state.tokens) }
      parseTopLevels(state1)
    },
    Lexer.LitName(name) when name == "let" => {
      let (binding, state1): (Ast.Binding, ParseState) = parseBinding(state)
      let (id, state2) = freshId(state1)
      let topLevel: Ast.TopLevel = {
        id,
        span: binding.span,
        kind: Ast.LetBinding(binding),
        exported: false,
      }
      let (rest, state3) = parseTopLevels(state2)
      ([topLevel, ...rest], state3)
    },
    Lexer.LitName(name) when name == "export" => {
      let state1 = dropToken(state) // drop export
      let (inner, state2) = parseTopLevels(state1)
      match (inner) {
        [tl, ...rest] => {
          let exportedTl = { ...tl, exported: true }
          ([exportedTl, ...rest], state2)
        },
        [] => panic("Expected something after export"),
      }
    },
    Lexer.LitName(name) when name == "type" => {
      let (typeDef, state1) = parseTypeDef(state)
      let (rest, state2) = parseTopLevels(state1)
      ([typeDef, ...rest], state2)
    },
    _ => panic("Unknown top-level construct: " ++ Lexer.tokenToString(tok)),
  }
}
and parseBinding = (state: ParseState) => {
  let (id, state1) = freshId(state)
  let (letTok, state2): (Lexer.Token, ParseState) = expectKeyword("let", state1)
  let (name, litName, state3) = expectName(state2)
  let (_, state4) = expectSimple(Lexer.Eq, state3)
  let (value, state5): (Ast.Expr, ParseState) = parseExpr(state4)
  let span = spanFromTokens(letTok.span, value.span)
  let binding: Ast.Binding = { id, span, nameSpan: litName.span, name, value }
  and parseTypeDef = (state: ParseState) => {
    let (id, state1) = freshId(state)
    let (typeTok, state2) = expectKeyword("type", state1)
    let (name, _, state3) = expectName(state2)
    let (_, state4) = expectSimple(Lexer.Eq, state3)
    // Simple: parse until ;
    let rec parseDef = (acc, st) => {
      let tok = currentToken(st)
      match (tok.kind) {
        Lexer.SemiColon => (acc, dropToken(st)),
        Lexer.EOF => (acc, st),
        _ => parseDef(acc ++ " " ++ tok.text, dropToken(st)), // approximate
      }
    }
    let (def, state5) = parseDef("", state4)
    let topLevel = Ast.TopLevel{
      id,
      span: typeTok.span, // approximate
      kind: Ast.TypeDef(name, def),
      exported: false,
    }
    (topLevel, state5)
  }
  let tokens = Lexer.lex(source)
  let initial: ParseState = { tokens, nextId: 1, allTokens: tokens }
  let (topLevels, _finalState) = parseTopLevels(initial)
  let program: Ast.Program = { topLevels, }
  program
}
