module Parser

from "list" include List
from "string" include String
from "array" include Array
from "bytes" include Bytes
from "wasi/file" include File

from "../core/surface_ast.gr" include SurfaceAst
use SurfaceAst.*
from "./lexer.gr" include Lexer
from "../core/source.gr" include Source
from "../core/error.gr" include Error

from "../util.gr" include Util
use Util.{ testStr }

provide record ParseResult {
  program: SurfaceAst.Program,
  tokens: List<Lexer.Token>,
}

record ParseState {
  tokens: List<Lexer.Token>,
  nextId: Number, // token id
  allTokens: List<Lexer.Token>,
}

type Parser<a> = ParseState => (a, ParseState)

let makeExpr: (Number, Source.Span, SurfaceAst.ExprKind) => SurfaceAst.Expr = (
  id,
  span,
  kind,
) => {
  let node = { id, span }
  let attach = { leading: [], trailing: [], dangling: [] }
  { node, kind, attach }
}

let makeTypeExpr: (Number, Source.Span, SurfaceAst.TypeExprKind) => SurfaceAst.TypeExpr =
  (id, span, kind) => {
    let node = { id, span }
    let attach = { leading: [], trailing: [], dangling: [] }
    { node, kind, attach }: SurfaceAst.TypeExpr
  }

let makeLineTrivia = (id: Number, span: Source.Span, text: String) => {
  let node = { id, span }
  { node, kind: SurfaceAst.LineComment(text), placement: SurfaceAst.Gap }:
    SurfaceAst.Trivia
}

let makeOpaqueTrivia = (id: Number, span: Source.Span, text: String) => {
  let node = { id, span }
  { node, kind: SurfaceAst.Opaque(text), placement: SurfaceAst.Gap }:
    SurfaceAst.Trivia
}

let withExprAttachments = (
  expr: SurfaceAst.Expr,
  leading: List<SurfaceAst.Trivia>,
  trailing: List<SurfaceAst.Trivia>,
) => {
  let attach = {
    ...expr.attach,
    leading: List.append(leading, expr.attach.leading),
    trailing: List.append(expr.attach.trailing, trailing),
  }
  { ...expr, attach }
}

let withPatternAttachments = (
  pattern: SurfaceAst.Pattern,
  leading: List<SurfaceAst.Trivia>,
  trailing: List<SurfaceAst.Trivia>,
) => {
  let attach = {
    ...pattern.attach,
    leading: List.append(leading, pattern.attach.leading),
    trailing: List.append(pattern.attach.trailing, trailing),
  }
  { ...pattern, attach }
}

let rec takeLeadingGapTrivia = (state: ParseState, acc: List<SurfaceAst.Trivia>) => {
  match (state.tokens) {
    [tok, ...tail] => match (tok.kind) {
      Lexer.LineComment(text) => {
        let state1 = { ...state, tokens: tail }
        let id = state1.nextId
        let state2 = { ...state1, nextId: id + 1 }
        let trivia = makeLineTrivia(id, tok.span, text)
        takeLeadingGapTrivia(state2, [trivia, ...acc])
      },
      Lexer.Opaque(text) => {
        let state1 = { ...state, tokens: tail }
        let id = state1.nextId
        let state2 = { ...state1, nextId: id + 1 }
        let trivia = makeOpaqueTrivia(id, tok.span, text)
        takeLeadingGapTrivia(state2, [trivia, ...acc])
      },
      _ => (List.reverse(acc), state),
    },
    _ => (List.reverse(acc), state),
  }
}

let rec takeTrailingGapTriviaOnLine = (
  line: Number,
  state: ParseState,
  acc: List<SurfaceAst.Trivia>,
) => {
  match (state.tokens) {
    [tok, ...tail] => match (tok.kind) {
      Lexer.LineComment(text) when tok.span.line == line => {
        let state1 = { ...state, tokens: tail }
        let id = state1.nextId
        let state2 = { ...state1, nextId: id + 1 }
        let trivia = makeLineTrivia(id, tok.span, text)
        takeTrailingGapTriviaOnLine(line, state2, [trivia, ...acc])
      },
      Lexer.Opaque(text) when tok.span.line == line => {
        let state1 = { ...state, tokens: tail }
        let id = state1.nextId
        let state2 = { ...state1, nextId: id + 1 }
        let trivia = makeOpaqueTrivia(id, tok.span, text)
        takeTrailingGapTriviaOnLine(line, state2, [trivia, ...acc])
      },
      _ => (List.reverse(acc), state),
    },
    _ => (List.reverse(acc), state),
  }
}

// id +1
let freshId = (state: ParseState) => {
  let id = state.nextId
  (id, { ...state, nextId: id + 1 })
}

// inspect token
let currentToken = (state: ParseState) => match (state.tokens) {
  [head, ..._tail] => head,
  [] => { kind: Lexer.EOF, span: Source.makeSpan(1, 1, 0, 0), mate: None },
}

// drop 1 token from the list
let dropToken = (state: ParseState) => {
  match (state.tokens) {
    [_head, ...tail] => { ...state, tokens: tail },
    [] => { ...state, tokens: [] },
  }
}

let previousToken = (state: ParseState) => {
  let cur = currentToken(state).span.start
  let rec walk = (prev: Lexer.Token, tokens: List<Lexer.Token>) =>
    match (tokens) {
      [] => prev,
      [tok, ...rest] => if (tok.span.start >= cur) {
        prev
      } else {
        walk(tok, rest)
      },
    }
  let fallback: Lexer.Token = {
    kind: Lexer.EOF,
    span: Source.makeSpan(1, 0, 0, 0),
    mate: None,
  }
  walk(fallback, state.allTokens)
}

let tokenCursor = (state: ParseState) => currentToken(state).span.start

let parserLog = (text: String) => {
  let _ = File.fdWrite(
    File.stderr,
    Bytes.fromString("[Parser] " ++ text ++ "\n")
  )
  void
}

let ensureProgress = (before: ParseState, after: ParseState, context: String) => {
  if (
    tokenCursor(after) <= tokenCursor(before)
    && currentToken(after).kind != Lexer.EOF
  ) {
    let tok = currentToken(after)
    parserLog(
      "no progress in "
        ++ context
        ++ " token="
        ++ Lexer.tokenKindToString(tok.kind)
        ++ " line="
        ++ toString(tok.span.line)
        ++ " col="
        ++ toString(tok.span.col)
    )
    let (markId, state1) = freshId(after)
    let mark: SurfaceAst.Mark = {
      node: { id: markId, span: tok.span },
      kind: SurfaceAst.UnexpectedToken(Lexer.tokenKindToString(tok.kind)),
      expected: SurfaceAst.ExpectToken,
    }
    Error.createMarkedError(
      Error.Parsing,
      mark,
      "Parser made no progress in " ++ context ++ "; skipping token",
      dropToken(state1),
      clues=[
        Error.Received(Lexer.tokenKindToString(tok.kind)),
        Error.Note("recovery skipped one token to prevent an infinite loop"),
      ],
      severity=Error.SError
    )
  } else {
    after
  }
}

//return token at an index
let rec tokenAt = (tokens: List<Lexer.Token>, index: Number) => {
  if (index < 0) {
    None
  } else {
    match (tokens) {
      [] => None,
      [head, ...tail] => if (index == 0) {
        Some(head)
      } else {
        tokenAt(tail, index - 1)
      },
    }
  }
}

// check token validity
let kindIs = (kind, expected) => kind == expected

let isTopLevelBoundary = (tok: Lexer.Token) => match (tok.kind) {
  Lexer.EOF => true,
  Lexer.SemiColon => true,
  Lexer.Directive => true,
  Lexer.LineComment(_) => true,
  Lexer.Opaque(_) => true,
  Lexer.LitName(name) when name == "let"
    || name == "export"
    || name == "from"
    || name == "reexport"
    || name == "type"
    || name == "record" => true,
  _ => false,
}

let recoverMissingTopLevelSemicolon = (
  state: ParseState,
  anchorSpan: Source.Span,
) => {
  let atTok = currentToken(state)
  let prevTok = previousToken(state)
  let endCol = prevTok.span.col + (prevTok.span.end - prevTok.span.start)
  let errSpan = Source.makeSpan(
    prevTok.span.line,
    endCol,
    prevTok.span.end,
    prevTok.span.end
  )
  let (markId, state1) = freshId(state)
  let mark: SurfaceAst.Mark = {
    node: { id: markId, span: errSpan },
    kind: SurfaceAst.MissingSemicolon,
    expected: SurfaceAst.ExpectToken,
  }
  Error.createMarkedError(
    Error.Parsing,
    mark,
    "Expected ';' after top-level declaration",
    state1,
    clues=[
      Error.Expected(";"),
      Error.Received(Lexer.tokenKindToString(atTok.kind)),
    ],
    severity=Error.Warning
  )
}

let consumeTopLevelSemicolon = (state: ParseState, anchorSpan: Source.Span) =>
  if (kindIs(currentToken(state).kind, Lexer.SemiColon)) {
    dropToken(state)
  } else {
    recoverMissingTopLevelSemicolon(state, anchorSpan)
  }

let topItemSpan = (item: SurfaceAst.TopItem) => match (item) {
  SurfaceAst.DeclGroup(group) => group.node.span,
  SurfaceAst.Import(importDecl) => importDecl.node.span,
  SurfaceAst.Reexport(reexportDecl) => reexportDecl.node.span,
  SurfaceAst.Export(exportDecl) => exportDecl.node.span,
  SurfaceAst.Directive(directive) => directive.name.node.span,
  SurfaceAst.Mark(mark) => mark.node.span,
  SurfaceAst.Trivia(trivia) => trivia.node.span,
}

let recoverMissingBlockSemicolon = (state: ParseState, anchorSpan: Source.Span) => {
  let atTok = currentToken(state)
  let errSpan = Source.makeSpan(
    anchorSpan.line,
    anchorSpan.col,
    anchorSpan.end,
    anchorSpan.end
  )
  let (markId, state1) = freshId(state)
  let mark: SurfaceAst.Mark = {
    node: { id: markId, span: errSpan },
    kind: SurfaceAst.MissingSemicolon,
    expected: SurfaceAst.ExpectToken,
  }
  Error.createMarkedError(
    Error.Parsing,
    mark,
    "Expected ';' after statement",
    state1,
    clues=[
      Error.Expected(";"),
      Error.Received(Lexer.tokenKindToString(atTok.kind)),
    ],
    severity=Error.Warning
  )
}

let startsBlockStatement = (tok: Lexer.Token) => match (tok.kind) {
  Lexer.LitName("let") => true,
  Lexer.Directive => true,
  _ => false,
}

let isValueBoundary = (tok: Lexer.Token) => match (tok.kind) {
  Lexer.SemiColon => true,
  Lexer.Comma => true,
  Lexer.RBrace => true,
  Lexer.EOF => true,
  Lexer.LineComment(_) => true,
  Lexer.Opaque(_) => true,
  Lexer.Directive => true,
  Lexer.LitName(name) when name == "let"
    || name == "and"
    || name == "type"
    || name == "record"
    || name == "export" => true,
  _ => false,
}

let isKeywordName = (name: String) =>
  name == "let"
    || name == "and"
    || name == "type"
    || name == "record"
    || name == "export"
    || name == "from"
    || name == "import"
    || name == "as"
    || name == "reexport"

let isOpaqueLineStart = (state: ParseState) => {
  let tok = currentToken(state)
  match (tok.kind) {
    Lexer.LitName(name) when !isKeywordName(name) => {
      let nextTok = tokenAt(state.tokens, 1)
      match (nextTok) {
        Some(next) => next.span.line == tok.span.line && match (next.kind) {
          Lexer.LitName(_) => true,
          _ => false,
        },
        None => false,
      }
    },
    _ => false,
  }
}

let isOpaqueTopLevelStart = (state: ParseState) => {
  let tok = currentToken(state)
  match (tok.kind) {
    Lexer.LitName(name) when !isKeywordName(name) => true,
    _ => false,
  }
}

let consumeOpaqueLine = (state: ParseState) => {
  let tok = currentToken(state)
  let line = tok.span.line
  let rec gather = (tokens: List<Lexer.Token>, acc: List<String>) => {
    match (tokens) {
      [t, ...rest] when t.span.line == line => {
        let text = Lexer.tokenKindToString(t.kind)
        gather(rest, [text, ...acc])
      },
      _ => (List.reverse(acc), tokens),
    }
  }
  let (parts, remaining) = gather(state.tokens, [])
  let text = Array.join(" ", Array.fromList(parts))
  let (id, state1) = freshId({ ...state, tokens: remaining })
  let trivia = makeOpaqueTrivia(id, tok.span, text)
  (trivia, state1)
}

let makeInferredExprHole = (
  state: ParseState,
  anchorSpan: Source.Span,
  message: String,
  clues: List<Error.ErrorClue>,
) => {
  let tok = currentToken(state)
  let (id, state1) = freshId(state)
  let span = Source.makeSpan(
    anchorSpan.line,
    anchorSpan.col,
    anchorSpan.end,
    anchorSpan.end
  )
  let hole: SurfaceAst.Hole = {
    node: { id, span },
    kind: ExprHole,
    origin: Inferred,
  }
  let expr = makeExpr(id, span, Hole(hole))
  let (markId, state2) = freshId(state1)
  let mark: SurfaceAst.Mark = {
    node: { id: markId, span },
    kind: SurfaceAst.MissingExpr(message),
    expected: SurfaceAst.ExpectExpr,
  }
  let recoveryExpr = Error.createMarkedError(
    Error.Parsing,
    mark,
    message,
    expr,
    clues=clues,
    severity=Error.SError
  )
  (recoveryExpr, state2)
}

//expect type
let expectSimple = (expected, state: ParseState) => {
  let tok = currentToken(state)
  if (kindIs(tok.kind, expected)) {
    (tok, dropToken(state))
  } else {
    let syntheticSpan = Source.makeSpan(
      tok.span.line,
      tok.span.col,
      tok.span.start,
      tok.span.start
    )
    let synthetic: Lexer.Token = {
      kind: expected,
      span: syntheticSpan,
      mate: None,
    }
    let (markId, state1) = freshId(state)
    let mark: SurfaceAst.Mark = {
      node: { id: markId, span: tok.span },
      kind: SurfaceAst.MissingToken(Lexer.tokenKindToString(expected)),
      expected: SurfaceAst.ExpectToken,
    }
    let recoveryTok = Error.createMarkedError(
      Error.Parsing,
      mark,
      "Unexpected token",
      synthetic,
      clues=[
        Error.Expected(Lexer.tokenKindToString(expected)),
        Error.Received(Lexer.tokenKindToString(tok.kind)),
      ],
      severity=Error.SError
    )
    (recoveryTok, state1)
  }
}

//expect name
let expectName = (state: ParseState) => {
  let tok = currentToken(state)
  match (tok.kind) {
    Lexer.LitName(name) => (name, tok, dropToken(state)),
    _ => {
      let syntheticName = "_missing"
      let syntheticSpan = Source.makeSpan(
        tok.span.line,
        tok.span.col,
        tok.span.start,
        tok.span.start
      )
      let syntheticTok: Lexer.Token = {
        kind: Lexer.LitName(syntheticName),
        span: syntheticSpan,
        mate: None,
      }
      let (markId, state1) = freshId(state)
      let mark: SurfaceAst.Mark = {
        node: { id: markId, span: tok.span },
        kind: SurfaceAst.MissingToken("identifier"),
        expected: SurfaceAst.ExpectToken,
      }
      let recoveryName = Error.createMarkedError(
        Error.Parsing,
        mark,
        "Expected identifier",
        syntheticName,
        clues=[Error.Received(Lexer.tokenKindToString(tok.kind))],
        severity=Error.SError
      )
      let recoveryTok = Error.createMarkedError(
        Error.Parsing,
        mark,
        "Expected identifier",
        syntheticTok,
        clues=[Error.Received(Lexer.tokenKindToString(tok.kind))],
        severity=Error.SError
      )
      (recoveryName, recoveryTok, state1)
    },
  }
}

let expectAnyName = (state: ParseState) => {
  let tok = currentToken(state)
  match (tok.kind) {
    Lexer.LitName(name) => (name, tok, dropToken(state)),
    Lexer.ConstructorTok(name) => (name, tok, dropToken(state)),
    _ => {
      let syntheticName = "_missing"
      let syntheticSpan = Source.makeSpan(
        tok.span.line,
        tok.span.col,
        tok.span.start,
        tok.span.start
      )
      let syntheticTok: Lexer.Token = {
        kind: Lexer.LitName(syntheticName),
        span: syntheticSpan,
        mate: None,
      }
      let (markId, state1) = freshId(state)
      let mark: SurfaceAst.Mark = {
        node: { id: markId, span: tok.span },
        kind: SurfaceAst.MissingToken("identifier"),
        expected: SurfaceAst.ExpectToken,
      }
      let recoveryName = Error.createMarkedError(
        Error.Parsing,
        mark,
        "Expected identifier",
        syntheticName,
        clues=[Error.Received(Lexer.tokenKindToString(tok.kind))],
        severity=Error.SError
      )
      let recoveryTok = Error.createMarkedError(
        Error.Parsing,
        mark,
        "Expected identifier",
        syntheticTok,
        clues=[Error.Received(Lexer.tokenKindToString(tok.kind))],
        severity=Error.SError
      )
      (recoveryName, recoveryTok, state1)
    },
  }
}

let expectTypeParamName = (state: ParseState) => {
  let tok = currentToken(state)
  match (tok.kind) {
    Lexer.LitName(name) => (name, tok, dropToken(state)),
    Lexer.ConstructorTok(name) => (name, tok, dropToken(state)),
    _ => {
      let syntheticName = "_missing"
      let syntheticSpan = Source.makeSpan(
        tok.span.line,
        tok.span.col,
        tok.span.start,
        tok.span.start
      )
      let syntheticTok: Lexer.Token = {
        kind: Lexer.LitName(syntheticName),
        span: syntheticSpan,
        mate: None,
      }
      let (markId, state1) = freshId(state)
      let mark: SurfaceAst.Mark = {
        node: { id: markId, span: tok.span },
        kind: SurfaceAst.MissingToken("type parameter"),
        expected: SurfaceAst.ExpectToken,
      }
      let recoveryName = Error.createMarkedError(
        Error.Parsing,
        mark,
        "Expected type parameter name",
        syntheticName,
        clues=[Error.Received(Lexer.tokenKindToString(tok.kind))],
        severity=Error.SError
      )
      let recoveryTok = Error.createMarkedError(
        Error.Parsing,
        mark,
        "Expected type parameter name",
        syntheticTok,
        clues=[Error.Received(Lexer.tokenKindToString(tok.kind))],
        severity=Error.SError
      )
      (recoveryName, recoveryTok, state1)
    },
  }
}

//expect name
let expectConstructor = (state: ParseState) => {
  let tok = currentToken(state)
  match (tok.kind) {
    Lexer.ConstructorTok(name) => (name, tok, dropToken(state)),
    _ => {
      let syntheticName = "Missing"
      let syntheticSpan = Source.makeSpan(
        tok.span.line,
        tok.span.col,
        tok.span.start,
        tok.span.start
      )
      let syntheticTok: Lexer.Token = {
        kind: Lexer.ConstructorTok(syntheticName),
        span: syntheticSpan,
        mate: None,
      }
      let (markId, state1) = freshId(state)
      let mark: SurfaceAst.Mark = {
        node: { id: markId, span: tok.span },
        kind: SurfaceAst.MissingToken("constructor"),
        expected: SurfaceAst.ExpectToken,
      }
      let recoveryName = Error.createMarkedError(
        Error.Parsing,
        mark,
        "Expected constructor",
        syntheticName,
        clues=[Error.Received(Lexer.tokenKindToString(tok.kind))],
        severity=Error.SError
      )
      let recoveryTok = Error.createMarkedError(
        Error.Parsing,
        mark,
        "Expected constructor",
        syntheticTok,
        clues=[Error.Received(Lexer.tokenKindToString(tok.kind))],
        severity=Error.SError
      )
      (recoveryName, recoveryTok, state1)
    },
  }
}

//expect keyword tokenized as a name
let expectKeyword = (keyword: String, state: ParseState) => {
  let tok = currentToken(state)
  match (tok.kind) {
    Lexer.LitName(name) when name == keyword => (tok, dropToken(state)),
    _ => {
      let syntheticSpan = Source.makeSpan(
        tok.span.line,
        tok.span.col,
        tok.span.start,
        tok.span.start
      )
      let syntheticTok: Lexer.Token = {
        kind: Lexer.LitName(keyword),
        span: syntheticSpan,
        mate: None,
      }
      let (markId, state1) = freshId(state)
      let mark: SurfaceAst.Mark = {
        node: { id: markId, span: tok.span },
        kind: SurfaceAst.MissingToken(keyword),
        expected: SurfaceAst.ExpectToken,
      }
      let recoveryTok = Error.createMarkedError(
        Error.Parsing,
        mark,
        "Expected keyword",
        syntheticTok,
        clues=[
          Error.Expected(keyword),
          Error.Received(Lexer.tokenKindToString(tok.kind)),
        ],
        severity=Error.SError
      )
      (recoveryTok, state1)
    },
  }
}

//fetch the mate of a token that has one
let fetchMate = (state: ParseState, tok: Lexer.Token) => {
  match (tok.mate) {
    Some(mateIndex) => {
      let rec find = (ts: List<Lexer.Token>) => match (ts) {
        [] => {
          let mark: SurfaceAst.Mark = {
            node: { id: 0, span: tok.span },
            kind: SurfaceAst.UnexpectedToken("unmatched delimiter"),
            expected: SurfaceAst.ExpectToken,
          }
          Error.createMarkedError(
            Error.Parsing,
            mark,
            "Internal error",
            tok,
            clues=[Error.Note("matching delimiter not found")],
            severity=Error.SError
          )
        },
        [h, ...t] => if (h.span.start == mateIndex) {
          h
        } else {
          find(t)
        },
      }
      find(state.allTokens)
    },
    None => {
      let mark: SurfaceAst.Mark = {
        node: { id: 0, span: tok.span },
        kind: SurfaceAst.UnexpectedToken("unmatched delimiter"),
        expected: SurfaceAst.ExpectToken,
      }
      Error.createMarkedError(
        Error.Parsing,
        mark,
        "Internal error",
        tok,
        clues=[Error.Note("token has no mate")],
        severity=Error.SError
      )
    },
  }
}

//create a span from the end token
let spanFromTokens = (startSpan: Source.Span, endSpan: Source.Span) =>
  Source.makeSpan(startSpan.line, startSpan.col, startSpan.start, endSpan.end)

let makeUnitExpr = (state: ParseState, span: Source.Span) => {
  let (id, state1) = freshId(state)
  let expr = makeExpr(id, span, SurfaceAst.Lit(SurfaceAst.Unit))
  (expr, state1)
}

let makeWildcardPattern = (state: ParseState, span: Source.Span) => {
  let (id, state1) = freshId(state)
  let pat: SurfaceAst.Pattern = {
    node: { id, span },
    kind: SurfaceAst.Wildcard,
    attach: { leading: [], trailing: [], dangling: [] },
  }
  (pat, state1)
}

let makeLetExpr = (
  state: ParseState,
  binding: SurfaceAst.LetBinding,
  body: SurfaceAst.Expr,
) => {
  let (id, state1) = freshId(state)
  let span = spanFromTokens(binding.node.span, body.node.span)
  let expr = makeExpr(id, span, SurfaceAst.Let(binding, body))
  (expr, state1)
}

let spanFromEnd = (state: ParseState, endTok: Lexer.Token) => {
  let startTok = fetchMate(state, endTok)
  spanFromTokens(startTok.span, endTok.span)
}

let expectSimpleOrRecover = (expected, state: ParseState, context: String) => {
  let tok = currentToken(state)
  if (kindIs(tok.kind, expected)) {
    expectSimple(expected, state)
  } else {
    let syntheticSpan = Source.makeSpan(
      tok.span.line,
      tok.span.col,
      tok.span.start,
      tok.span.start
    )
    let synthetic: Lexer.Token = {
      kind: expected,
      span: syntheticSpan,
      mate: None,
    }
    let (markId, state1) = freshId(state)
    let mark: SurfaceAst.Mark = {
      node: { id: markId, span: tok.span },
      kind: SurfaceAst.MissingToken(Lexer.tokenKindToString(expected)),
      expected: SurfaceAst.ExpectToken,
    }
    let recoveryTok = Error.createMarkedError(
      Error.Parsing,
      mark,
      "Expected " ++ Lexer.tokenKindToString(expected) ++ " " ++ context,
      synthetic,
      clues=[
        Error.Expected(Lexer.tokenKindToString(expected)),
        Error.Received(Lexer.tokenKindToString(tok.kind)),
      ],
      severity=Error.SError
    )
    (recoveryTok, state1)
  }
}

let blockItemsToBody = (
  items: List<SurfaceAst.BlockItem>,
  state: ParseState,
  fallbackSpan: Source.Span,
) => {
  let hasTerminatorAfter = (tail: List<SurfaceAst.BlockItem>) => match (tail) {
    [SurfaceAst.Semicolon, ..._] => true,
    [SurfaceAst.MarkItem(mark), ..._] => match (mark.kind) {
      SurfaceAst.MissingSemicolon => true,
      _ => false,
    },
    _ => false,
  }

  let rec fold = (
    remaining: List<SurfaceAst.BlockItem>,
    state: ParseState,
    bodyOpt: Option<SurfaceAst.Expr>,
  ) => {
    let bindingsFromDeclGroup = (group: SurfaceAst.DeclGroup) => {
      match (group.kind) {
        SurfaceAst.LetGroup(_) =>
          List.flatMap((decl: SurfaceAst.Decl) => match (decl) {
            SurfaceAst.LetDecl(ld) => ld.bindings,
            _ => [],
          }, group.decls),
        _ => [],
      }
    }
    match (remaining) {
      [] => (bodyOpt, state),
      [item, ...tail] => {
        let (nextOpt, state1) = fold(tail, state, bodyOpt)
        match (item) {
          SurfaceAst.ExprItem(expr) => {
            if (hasTerminatorAfter(tail)) {
              let (body, state2) = match (nextOpt) {
                Some(b) => (b, state1),
                None => makeUnitExpr(state1, expr.node.span),
              }
              let (pat, state3) = makeWildcardPattern(state2, expr.node.span)
              let (bindingId, state4) = freshId(state3)
              let binding: SurfaceAst.LetBinding = {
                node: { id: bindingId, span: expr.node.span },
                name: pat,
                annotation: None,
                hasEq: true,
                value: expr,
              }
              let (letExpr, state5) = makeLetExpr(state4, binding, body)
              (Some(letExpr), state5)
            } else {
              match (nextOpt) {
                None => (Some(expr), state1),
                Some(body) => {
                  let (pat, state2) = makeWildcardPattern(
                    state1,
                    expr.node.span
                  )
                  let (bindingId, state3) = freshId(state2)
                  let binding: SurfaceAst.LetBinding = {
                    node: { id: bindingId, span: expr.node.span },
                    name: pat,
                    annotation: None,
                    hasEq: true,
                    value: expr,
                  }
                  let (letExpr, state4) = makeLetExpr(state3, binding, body)
                  (Some(letExpr), state4)
                },
              }
            }
          },
          SurfaceAst.LetItem(binding) => {
            let (body, state2) = match (nextOpt) {
              Some(b) => (b, state1),
              None => makeUnitExpr(state1, binding.node.span),
            }
            let (letExpr, state3) = makeLetExpr(state2, binding, body)
            (Some(letExpr), state3)
          },
          SurfaceAst.DeclGroup(group) => {
            let bindings = bindingsFromDeclGroup(group)
            match (bindings) {
              [] => (nextOpt, state1),
              _ => {
                let (body, state2) = match (nextOpt) {
                  Some(b) => (b, state1),
                  None => makeUnitExpr(state1, group.node.span),
                }
                let rec wrap = (
                  remainingBindings: List<SurfaceAst.LetBinding>,
                  inner: SurfaceAst.Expr,
                  stateX: ParseState,
                ) => match (remainingBindings) {
                  [] => (inner, stateX),
                  [binding, ...rest] => {
                    let (letExpr, stateY) = makeLetExpr(stateX, binding, inner)
                    wrap(rest, letExpr, stateY)
                  },
                }
                let reversedBindings = List.reverse(bindings)
                let (finalExpr, state3) = wrap(reversedBindings, body, state2)
                (Some(finalExpr), state3)
              },
            }
          },
          SurfaceAst.Semicolon |
          SurfaceAst.Comma |
          SurfaceAst.MarkItem(_) |
          SurfaceAst.TriviaItem(_) |
          SurfaceAst.Directive(_) => (nextOpt, state1),
        }
      },
    }
  }

  let (bodyOpt, state1) = fold(items, state, None)
  match (bodyOpt) {
    Some(body) => (body, state1),
    None => makeUnitExpr(state1, fallbackSpan),
  }
}

//parse
let rec parseExpr: Parser<SurfaceAst.Expr> = state => {
  let (leadingTrivia, state0) = takeLeadingGapTrivia(state, [])
  let (coreExpr: SurfaceAst.Expr, coreState) = parseInfix(state0)
  let (expr, state1) = match (currentToken(coreState).kind) {
    Lexer.FatArrow => {
      let (id, stateAfterId) = freshId(coreState)
      let opTok = currentToken(stateAfterId)
      let (_, state2) = expectSimple(Lexer.FatArrow, stateAfterId)
      let (opId, state2b) = freshId(state2)
      let (rhs, state3): (SurfaceAst.Expr, ParseState) = parseExpr(state2b)
      let span = spanFromTokens(coreExpr.node.span, rhs.node.span)
      let node: SurfaceAst.Expr = makeExpr(
        id,
        span,
        InfixChain(
          {
            first: coreExpr,
            rest: [({ node: { id: opId, span: opTok.span }, text: "=>" }, rhs)],
          },
        )
      )
      (node, state3)
    },
    Lexer.PipeArrow => {
      let (id, stateAfterId) = freshId(coreState)
      let opTok = currentToken(stateAfterId)
      let (_, state2) = expectSimple(Lexer.PipeArrow, stateAfterId)
      let (opId, state2b) = freshId(state2)
      let (rhs, state3) = parseExpr(state2b)
      let span = spanFromTokens(coreExpr.node.span, rhs.node.span)
      let node = makeExpr(
        id,
        span,
        InfixChain(
          {
            first: coreExpr,
            rest: [({ node: { id: opId, span: opTok.span }, text: ":>" }, rhs)],
          },
        )
      )
      (node, state3)
    },
    _ => (coreExpr, coreState),
  }
  let (trailingTrivia, state2) = takeTrailingGapTriviaOnLine(
    expr.node.span.line,
    state1,
    []
  )
  let exprWithAttach = withExprAttachments(expr, leadingTrivia, trailingTrivia)
  (exprWithAttach, state2)
}
and parseInfix: Parser<SurfaceAst.Expr> = state => {
  let (expr: Expr, state1) = parseTerm(state)
  match (currentToken(state1).kind) {
    Lexer.Star => {
      let (id, stateAfterId) = freshId(state1)
      let opTok = currentToken(stateAfterId)
      let (_, state2) = expectSimple(Lexer.Star, stateAfterId)
      let (opId, state2b) = freshId(state2)
      let (rhs, state3) = parseInfix(state2b)
      let span = spanFromTokens(expr.node.span, rhs.node.span)
      let node = makeExpr(
        id,
        span,
        InfixChain(
          {
            first: expr,
            rest: [({ node: { id: opId, span: opTok.span }, text: "*" }, rhs)],
          },
        )
      )
      (node, state3)
    },
    Lexer.EqEq => {
      let (id, stateAfterId) = freshId(state1)
      let opTok = currentToken(stateAfterId)
      let (_, state2) = expectSimple(Lexer.EqEq, stateAfterId)
      let (opId, state2b) = freshId(state2)
      let (rhs, state3) = parseInfix(state2b)
      let span = spanFromTokens(expr.node.span, rhs.node.span)
      let node = makeExpr(
        id,
        span,
        InfixChain(
          {
            first: expr,
            rest: [({ node: { id: opId, span: opTok.span }, text: "==" }, rhs)],
          },
        )
      )
      (node, state3)
    },
    Lexer.Plus => {
      let (id, stateAfterId) = freshId(state1)
      let opTok = currentToken(stateAfterId)
      let (_, state2) = expectSimple(Lexer.Plus, stateAfterId)
      let (opId, state2b) = freshId(state2)
      let (rhs, state3) = parseInfix(state2b)
      let span = spanFromTokens(expr.node.span, rhs.node.span)
      let node = makeExpr(
        id,
        span,
        InfixChain(
          {
            first: expr,
            rest: [({ node: { id: opId, span: opTok.span }, text: "+" }, rhs)],
          },
        )
      )
      (node, state3)
    },
    Lexer.Dash => {
      let (id, stateAfterId) = freshId(state1)
      let opTok = currentToken(stateAfterId)
      let (_, state2) = expectSimple(Lexer.Dash, stateAfterId)
      let (opId, state2b) = freshId(state2)
      let (rhs, state3) = parseInfix(state2b)
      let span = spanFromTokens(expr.node.span, rhs.node.span)
      let node = makeExpr(
        id,
        span,
        InfixChain(
          {
            first: expr,
            rest: [({ node: { id: opId, span: opTok.span }, text: "-" }, rhs)],
          },
        )
      )
      (node, state3)
    },
    Lexer.Arrow => {
      let (id, stateAfterId) = freshId(state1)
      let opTok = currentToken(stateAfterId)
      let (_, state2) = expectSimple(Lexer.Arrow, stateAfterId)
      let (opId, state2b) = freshId(state2)
      let (rhs, state3) = parseInfix(state2b)
      let span = spanFromTokens(expr.node.span, rhs.node.span)
      let node = makeExpr(
        id,
        span,
        InfixChain(
          {
            first: expr,
            rest: [({ node: { id: opId, span: opTok.span }, text: ">" }, rhs)],
          },
        )
      )
      (node, state3)
    },
    _ => (expr, state1),
  }
}
and parsePostfix = (
  target: SurfaceAst.Expr,
  segments: List<SurfaceAst.PostfixSegment>,
  state: ParseState,
) => {
  let tok = currentToken(state)
  match (tok.kind) {
    Lexer.LParen => {
      let (_, state1) = expectSimple(Lexer.LParen, state)
      let mut args = []
      let mut currentState = state1
      if (!kindIs(currentToken(currentState).kind, Lexer.RParen)) {
        let (arg, state_temp) = parseExpr(currentState)
        args = [arg, ...args]
        currentState = state_temp
        while (kindIs(currentToken(currentState).kind, Lexer.Comma)) {
          let before = currentState
          let (_, state_temp2) = expectSimple(Lexer.Comma, currentState)
          let (nextArg, state_temp3) = parseExpr(state_temp2)
          args = [nextArg, ...args]
          currentState = state_temp3
          currentState = ensureProgress(before, currentState, "call args")
        }
      }
      let (rparenTok, state2) = expectSimpleOrRecover(
        Lexer.RParen,
        currentState,
        "to close call"
      )
      let segment = Call(List.reverse(args))
      let newSegments = [segment, ...segments]
      parsePostfix(target, newSegments, state2)
    },
    Lexer.Period => {
      let (_, state1) = expectSimple(Lexer.Period, state)
      let (name, nameTok, state2) = expectAnyName(state1)
      let segment = Project(
        { node: { id: target.node.id, span: nameTok.span }, text: name },
      )
      let newSegments = [segment, ...segments]
      parsePostfix(target, newSegments, state2)
    },
    _ => {
      if (List.length(segments) == 0) {
        (target, state)
      } else {
        let postfix = Postfix({ target, segments: List.reverse(segments) })
        let newExpr = makeExpr(target.node.id, target.node.span, postfix)
        (newExpr, state)
      }
    },
  }
}
and parseTerm: Parser<SurfaceAst.Expr> = state => {
  let tok = currentToken(state)
  match (tok.kind) {
    Lexer.LBrace => parseBlock(state),
    Lexer.FatArrow => {
      // Thunk syntax: => body
      let (id, state1) = freshId(state)
      let (_, state2) = expectSimple(Lexer.FatArrow, state1)
      let (body, state3) = parseExpr(state2)
      let span = spanFromTokens(tok.span, body.node.span)
      let bodyBlock = match (body.kind) {
        Block(b) => b,
        _ => { node: body.node, items: [SurfaceAst.ExprItem(body)], body },
      }
      let (patId, state4) = freshId(state3)
      let wildcardPat: SurfaceAst.Pattern = {
        node: { id: patId, span: tok.span },
        kind: Wildcard,
        attach: { leading: [], trailing: [], dangling: [] },
      }
      let (clauseId, state5) = freshId(state4)
      let clause: SurfaceAst.FnClause = {
        node: { id: clauseId, span },
        param: wildcardPat,
        guard: None,
        body: bodyBlock,
        attach: { leading: [], trailing: [], dangling: [] },
      }
      let (itemId, state6) = freshId(state5)
      let item: SurfaceAst.FnItem = {
        node: { id: itemId, span },
        kind: SurfaceAst.Clause(clause),
        attach: { leading: [], trailing: [], dangling: [] },
      }
      let (fnExprId, state7) = freshId(state6)
      let fnExpr: SurfaceAst.FnExpr = {
        node: { id: fnExprId, span },
        items: [item],
        attach: { leading: [], trailing: [], dangling: [] },
      }
      let expr = makeExpr(id, span, Fn(fnExpr))
      (expr, state7)
    },
    _ => {
      let (expr, state1) = parsePrimary(state)
      parsePostfix(expr, [], state1)
    },
  }
}
//must support inner code
and parseBlock: Parser<SurfaceAst.Expr> = state => {
  let (id, state1) = freshId(state)
  let (lbraceTok, state2) = expectSimple(Lexer.LBrace, state1)
  let (items, state3) = parseBlockItems(state2)
  let tokAfterItems = currentToken(state3)
  let blockItemSpan = (item: SurfaceAst.BlockItem) => match (item) {
    SurfaceAst.ExprItem(expr) => expr.node.span,
    SurfaceAst.LetItem(binding) => binding.node.span,
    SurfaceAst.DeclGroup(group) => group.node.span,
    SurfaceAst.MarkItem(mark) => mark.node.span,
    SurfaceAst.TriviaItem(trivia) => trivia.node.span,
    SurfaceAst.Directive(directive) => directive.name.node.span,
    SurfaceAst.Semicolon | SurfaceAst.Comma => lbraceTok.span,
  }
  let anchorSpan = match (List.head(List.reverse(items))) {
    Some(item) => blockItemSpan(item),
    None => lbraceTok.span,
  }
  let (items2, rbraceTok, state4) = if (
    kindIs(tokAfterItems.kind, Lexer.RBrace)
  ) {
    let (rbraceTok, state4) = expectSimple(Lexer.RBrace, state3)
    (items, rbraceTok, state4)
  } else {
    let (markId, state4) = freshId(state3)
    let markSpan = Source.makeSpan(
      anchorSpan.line,
      anchorSpan.col,
      anchorSpan.end,
      anchorSpan.end
    )
    let mark: SurfaceAst.Mark = {
      node: { id: markId, span: markSpan },
      kind: SurfaceAst.MissingRBrace,
      expected: SurfaceAst.ExpectToken,
    }
    let markItem: SurfaceAst.BlockItem = Error.createMarkedError(
      Error.Parsing,
      mark,
      "Expected '}' to close block",
      SurfaceAst.MarkItem(mark),
      clues=[
        Error.Expected("}"),
        Error.Received(Lexer.tokenKindToString(tokAfterItems.kind)),
      ],
      severity=Error.SError
    )
    let syntheticSpan = Source.makeSpan(
      tokAfterItems.span.line,
      tokAfterItems.span.col,
      tokAfterItems.span.start,
      tokAfterItems.span.start
    )
    let rbraceTok: Lexer.Token = {
      kind: Lexer.RBrace,
      span: syntheticSpan,
      mate: None,
    }
    (List.append(items, [markItem]), rbraceTok, state4)
  }
  let span = spanFromTokens(lbraceTok.span, rbraceTok.span)
  let (body, state5) = blockItemsToBody(items2, state4, span)
  let expr = makeExpr(
    id,
    span,
    Block({ node: { id, span }, items: items2, body })
  )
  (expr, state5)
}
and parsePrimary: Parser<SurfaceAst.Expr> = state => {
  let (id, state1) = freshId(state)
  let tok = currentToken(state1)

  match (tok.kind) {
    Lexer.Wildcard => {
      let state2 = dropToken(state1)
      let (nameId, state3) = freshId(state2)
      let expr: SurfaceAst.Expr = makeExpr(
        id,
        tok.span,
        Ident({ node: { id: nameId, span: tok.span }, text: "_" })
      )
      (expr, state3)
    },
    Lexer.LitNum(value) => {
      let state2 = dropToken(state1)
      let expr: SurfaceAst.Expr = makeExpr(
        id,
        tok.span,
        Lit(SurfaceAst.Int(value))
      )
      (expr, state2)
    },
    Lexer.LitString(value) => {
      let state2 = dropToken(state1)
      let expr: SurfaceAst.Expr = makeExpr(
        id,
        tok.span,
        Lit(SurfaceAst.Str(value))
      )
      (expr, state2)
    },
    Lexer.LitChar(value) => {
      let state2 = dropToken(state1)
      let expr: SurfaceAst.Expr = makeExpr(
        id,
        tok.span,
        Lit(SurfaceAst.Char(value))
      )
      (expr, state2)
    },
    Lexer.LitBool(value) => {
      let state2 = dropToken(state1)
      let expr: SurfaceAst.Expr = makeExpr(
        id,
        tok.span,
        Lit(SurfaceAst.Bool(value))
      )
      (expr, state2)
    },
    Lexer.LitName(name) => {
      if (name == "match") {
        parseMatch(state1)
      } else if (name == "if") {
        parseIf(state1)
      } else {
        let state2 = dropToken(state1)
        let (nameId, state3) = freshId(state2)
        let expr: SurfaceAst.Expr = makeExpr(
          id,
          tok.span,
          Ident({ node: { id: nameId, span: tok.span }, text: name })
        )
        (expr, state3)
      }
    },
    Lexer.ConstructorTok(name) => {
      let state1 = dropToken(state1)
      if (kindIs(currentToken(state1).kind, Lexer.LBrace)) {
        let (_, state2) = expectSimple(Lexer.LBrace, state1)
        let mut fields = []
        let mut currentState = state2
        while (!kindIs(currentToken(currentState).kind, Lexer.RBrace)) {
          let before = currentState
          if (kindIs(currentToken(currentState).kind, Lexer.Comma)) {
            let (_, state_temp) = expectSimple(Lexer.Comma, currentState)
            currentState = state_temp
          } else {
            let tokAt = currentToken(currentState)
            let isName = match (tokAt.kind) {
              Lexer.LitName(_) => true,
              _ => false,
            }
            if (!isName) {
              let (markId, stateMark) = freshId(currentState)
              let mark: SurfaceAst.Mark = {
                node: { id: markId, span: tokAt.span },
                kind: SurfaceAst.UnexpectedToken(
                  Lexer.tokenKindToString(tokAt.kind),
                ),
                expected: SurfaceAst.ExpectToken,
              }
              let stateDropped = dropToken(stateMark)
              currentState = Error.createMarkedError(
                Error.Parsing,
                mark,
                "Unexpected token in record literal",
                stateDropped,
                clues=[
                  Error.Expected("identifier"),
                  Error.Received(Lexer.tokenKindToString(tokAt.kind)),
                ],
                severity=Error.SError
              )
            } else {
              let (fieldName, nameTok, state_temp) = expectName(currentState)
              let (fieldExpr, state_temp3) = if (
                kindIs(currentToken(state_temp).kind, Lexer.Eq)
              ) {
                let (_, state_temp2) = expectSimple(Lexer.Eq, state_temp)
                parseExpr(state_temp2)
              } else {
                (
                  makeExpr(
                    id,
                    nameTok.span,
                    Ident({ node: { id, span: nameTok.span }, text: fieldName })
                  ),
                  state_temp,
                )
              }
              fields = [(fieldName, nameTok, fieldExpr), ...fields]
              currentState = state_temp3
              if (kindIs(currentToken(currentState).kind, Lexer.Comma)) {
                let (_, state_temp4) = expectSimple(Lexer.Comma, currentState)
                currentState = state_temp4
              }
            }
          }
          currentState = ensureProgress(
            before,
            currentState,
            "constructor record literal fields"
          )
        }
        let (rbraceTok, state3) = expectSimpleOrRecover(
          Lexer.RBrace,
          currentState,
          "to close constructor record"
        )
        let span = spanFromTokens(tok.span, rbraceTok.span)
        let reversedFields = List.reverse(fields)
        let rec buildFieldItems: (
          List<(String, Lexer.Token, SurfaceAst.Expr)>,
          Number,
        ) => List<SurfaceAst.RecordItem> = (items, currentId) =>
          match (items) {
            [] => [],
            [(name, tok, expr), ...rest] => {
              let field = Field(
                { node: { id: currentId, span: tok.span }, text: name },
                expr,
              )
              [field, ...buildFieldItems(rest, currentId + 1)]
            },
          }
        let fieldItems = buildFieldItems(reversedFields, id + 1)
        let (recordId, state4) = freshId(state3)
        let recordExpr: SurfaceAst.Expr = makeExpr(
          recordId,
          span,
          RecordLit(fieldItems)
        )
        let (calleeId, state5) = freshId(state4)
        let (nameId, state6) = freshId(state5)
        let calleeExpr: SurfaceAst.Expr = makeExpr(
          calleeId,
          tok.span,
          Ident({ node: { id: nameId, span: tok.span }, text: name })
        )
        let (applyId, state7) = freshId(state6)
        let applyExpr: SurfaceAst.Expr = makeExpr(
          applyId,
          span,
          Apply(calleeExpr, recordExpr)
        )
        (applyExpr, state7)
      } else {
        let expr: SurfaceAst.Expr = makeExpr(
          id,
          tok.span,
          Ident({ node: { id, span: tok.span }, text: name })
        )
        (expr, state1)
      }
    },
    Lexer.LParen => {
      let (_, state2) = expectSimple(Lexer.LParen, state1)
      if (kindIs(currentToken(state2).kind, Lexer.RParen)) {
        let (rparenTok, state3) = expectSimpleOrRecover(
          Lexer.RParen,
          state2,
          "to close tuple/paren"
        )
        let span = spanFromTokens(tok.span, rparenTok.span)
        let expr: SurfaceAst.Expr = makeExpr(id, span, Lit(SurfaceAst.Unit))
        (expr, state3)
      } else {
        let (inner, state3) = parseExpr(state2)
        // Handle optional type annotation (name: Type) for typed lambda params
        let state3 = if (kindIs(currentToken(state3).kind, Lexer.Colon)) {
          let (_, stateColon) = expectSimple(Lexer.Colon, state3)
          let (_, stateAfterTy) = parseTypeExpr(stateColon)
          stateAfterTy
        } else {
          state3
        }
        if (kindIs(currentToken(state3).kind, Lexer.Comma)) {
          let mut exprs = [inner]
          let mut currentState = state3
          while (kindIs(currentToken(currentState).kind, Lexer.Comma)) {
            let before = currentState
            let (_, state_temp) = expectSimple(Lexer.Comma, currentState)
            let (nextExpr, state_next) = parseExpr(state_temp)
            exprs = [nextExpr, ...exprs]
            let state_with_annotation = if (
              kindIs(currentToken(state_next).kind, Lexer.Colon)
            ) {
              let (_, state_colon) = expectSimple(Lexer.Colon, state_next)
              let (_, state_after_ty) = parseTypeExpr(state_colon)
              state_after_ty
            } else {
              state_next
            }
            currentState = state_with_annotation
            currentState = ensureProgress(before, currentState, "tuple expr")
          }
          let (rparenTok, state4) = expectSimpleOrRecover(
            Lexer.RParen,
            currentState,
            "to close tuple"
          )
          let span = spanFromTokens(tok.span, rparenTok.span)
          let expr: SurfaceAst.Expr = makeExpr(
            id,
            span,
            Tuple(List.reverse(exprs))
          )
          (expr, state4)
        } else if (kindIs(currentToken(state3).kind, Lexer.SemiColon)) {
          let mut exprs = [inner]
          let mut currentState = state3
          while (kindIs(currentToken(currentState).kind, Lexer.SemiColon)) {
            let before = currentState
            let (_, state_temp) = expectSimple(Lexer.SemiColon, currentState)
            let nextTok = currentToken(state_temp)
            if (isValueBoundary(nextTok) || isOpaqueLineStart(state_temp)) {
              let (holeExpr, state_after) = makeInferredExprHole(
                state_temp,
                nextTok.span,
                "Expected expression after ';' in sequence",
                [
                  Error.Expected("expression"),
                  Error.Received(Lexer.tokenKindToString(nextTok.kind)),
                ]
              )
              exprs = [holeExpr, ...exprs]
              currentState = state_after
            } else {
              let (nextExpr, state_next) = parseExpr(state_temp)
              exprs = [nextExpr, ...exprs]
              currentState = state_next
            }
            currentState = ensureProgress(before, currentState, "sequence expr")
          }
          let (rparenTok, state4) = expectSimpleOrRecover(
            Lexer.RParen,
            currentState,
            "to close sequence"
          )
          let span = spanFromTokens(tok.span, rparenTok.span)
          let expr: SurfaceAst.Expr = makeExpr(
            id,
            span,
            Seq(List.reverse(exprs))
          )
          (expr, state4)
        } else {
          let (rparenTok, state4) = expectSimpleOrRecover(
            Lexer.RParen,
            state3,
            "to close parenthesized expression"
          )
          let span = spanFromTokens(tok.span, rparenTok.span)
          let expr: SurfaceAst.Expr = makeExpr(id, span, Paren(inner))
          (expr, state4)
        }
      }
    },
    Lexer.Question => {
      let state2 = dropToken(state1)
      let expr: SurfaceAst.Expr = makeExpr(
        id,
        tok.span,
        Hole(
          { node: { id, span: tok.span }, kind: ExprHole, origin: UserTyped },
        )
      )
      (expr, state2)
    },
    Lexer.DotBrace => {
      let (_, state2) = expectSimple(Lexer.DotBrace, state1)
      let mut fields = []
      let mut currentState = state2
      while (!kindIs(currentToken(currentState).kind, Lexer.RBrace)) {
        let before = currentState
        if (kindIs(currentToken(currentState).kind, Lexer.Comma)) {
          // Skip leading/trailing commas
          let (_, state_temp) = expectSimple(Lexer.Comma, currentState)
          currentState = state_temp
        } else {
          let tokAt = currentToken(currentState)
          let isName = match (tokAt.kind) {
            Lexer.LitName(_) => true,
            _ => false,
          }
          if (!isName) {
            let (markId, stateMark) = freshId(currentState)
            let mark: SurfaceAst.Mark = {
              node: { id: markId, span: tokAt.span },
              kind: SurfaceAst.UnexpectedToken(
                Lexer.tokenKindToString(tokAt.kind),
              ),
              expected: SurfaceAst.ExpectToken,
            }
            let stateDropped = dropToken(stateMark)
            currentState = Error.createMarkedError(
              Error.Parsing,
              mark,
              "Unexpected token in record literal",
              stateDropped,
              clues=[
                Error.Expected("identifier"),
                Error.Received(Lexer.tokenKindToString(tokAt.kind)),
              ],
              severity=Error.SError
            )
          } else {
            let (fieldName, nameTok, state_temp) = expectName(currentState)
            let (fieldExpr, state_temp3) = if (
              kindIs(currentToken(state_temp).kind, Lexer.Eq)
            ) {
              let (_, state_temp2) = expectSimple(Lexer.Eq, state_temp)
              parseExpr(state_temp2)
            } else {
              (
                makeExpr(
                  id,
                  nameTok.span,
                  Ident({ node: { id, span: nameTok.span }, text: fieldName })
                ),
                state_temp,
              )
            }
            fields = [(fieldName, nameTok, fieldExpr), ...fields]
            currentState = state_temp3
            if (kindIs(currentToken(currentState).kind, Lexer.Comma)) {
              let (_, state_temp4) = expectSimple(Lexer.Comma, currentState)
              currentState = state_temp4
            }
          }
        }
        currentState = ensureProgress(
          before,
          currentState,
          "record literal fields"
        )
      }
      let (rbraceTok, state3) = expectSimpleOrRecover(
        Lexer.RBrace,
        currentState,
        "to close record literal"
      )
      let span = spanFromTokens(tok.span, rbraceTok.span)
      let reversedFields = List.reverse(fields)
      let rec buildFieldItems: (
        List<(String, Lexer.Token, SurfaceAst.Expr)>,
        Number,
      ) => List<SurfaceAst.RecordItem> = (items, currentId) => match (items) {
        [] => [],
        [(name, tok, expr), ...rest] => {
          let field = Field(
            { node: { id: currentId, span: tok.span }, text: name },
            expr,
          )
          [field, ...buildFieldItems(rest, currentId + 1)]
        },
      }
      let fieldItems = buildFieldItems(reversedFields, id + 1)
      let expr: SurfaceAst.Expr = makeExpr(id, span, RecordLit(fieldItems))
      (expr, state3)
    },
    Lexer.FatArrow => {
      let state2 = dropToken(state1)
      let (bodyExpr, state3) = parseExpr(state2)
      let span = spanFromTokens(tok.span, bodyExpr.node.span)
      let (patId, state4) = freshId(state3)
      let pat: SurfaceAst.Pattern = {
        node: { id: patId, span: tok.span },
        kind: Wildcard,
        attach: { leading: [], trailing: [], dangling: [] },
      }
      let bodyBlock = match (bodyExpr.kind) {
        Block(b) => b,
        _ =>
          {
            node: bodyExpr.node,
            items: [SurfaceAst.ExprItem(bodyExpr)],
            body: bodyExpr,
          },
      }
      let (clauseId, state5) = freshId(state4)
      let clause: SurfaceAst.FnClause = {
        node: { id: clauseId, span },
        param: pat,
        guard: None,
        body: bodyBlock,
        attach: { leading: [], trailing: [], dangling: [] },
      }
      let (itemId, state6) = freshId(state5)
      let item: SurfaceAst.FnItem = {
        node: { id: itemId, span },
        kind: SurfaceAst.Clause(clause),
        attach: { leading: [], trailing: [], dangling: [] },
      }
      let (fnExprId, state7) = freshId(state6)
      let fnExpr: SurfaceAst.FnExpr = {
        node: { id: fnExprId, span },
        items: [item],
        attach: { leading: [], trailing: [], dangling: [] },
      }
      let expr = makeExpr(id, span, Fn(fnExpr))
      (expr, state7)
    },
    _ => {
      makeInferredExprHole(
        state,
        tok.span,
        "Expected expression",
        [
          Error.Expected("expression"),
          Error.Received(Lexer.tokenKindToString(tok.kind)),
        ]
      )
    },
  }
}
and parseIf = (state: ParseState) => {
  let (id, state1) = freshId(state)
  let (ifTok, state2) = expectKeyword("if", state)
  let (cond, state3) = parseExpr(state2)
  let (thenExpr, state4) = parseExpr(state3)
  let (elseExpr, state5) = if (
    kindIs(currentToken(state4).kind, Lexer.LitName("else"))
  ) {
    let (_, state_temp) = expectKeyword("else", state4)
    let (expr, state_temp2) = parseExpr(state_temp)
    (Some(expr), state_temp2)
  } else {
    (None, state4)
  }
  let endSpan = match (elseExpr) {
    Some(e) => e.node.span,
    None => thenExpr.node.span,
  }
  let span = spanFromTokens(ifTok.span, endSpan)
  let expr = makeExpr(id, span, SurfaceAst.If(cond, thenExpr, elseExpr))
  (expr, state5)
}
and expectStringLiteral = (state: ParseState) => {
  let tok = currentToken(state)
  match (tok.kind) {
    Lexer.LitString(text) => (text, tok, dropToken(state)),
    _ => {
      let syntheticSpan = Source.makeSpan(
        tok.span.line,
        tok.span.col,
        tok.span.start,
        tok.span.start
      )
      let syntheticTok: Lexer.Token = {
        kind: Lexer.LitString(""),
        span: syntheticSpan,
        mate: None,
      }
      let (markId, state1) = freshId(state)
      let mark: SurfaceAst.Mark = {
        node: { id: markId, span: tok.span },
        kind: SurfaceAst.MissingToken("string literal"),
        expected: SurfaceAst.ExpectToken,
      }
      let recoveryText = Error.createMarkedError(
        Error.Parsing,
        mark,
        "Expected string literal",
        "",
        clues=[Error.Received(Lexer.tokenKindToString(tok.kind))],
        severity=Error.SError
      )
      let recoveryTok = Error.createMarkedError(
        Error.Parsing,
        mark,
        "Expected string literal",
        syntheticTok,
        clues=[Error.Received(Lexer.tokenKindToString(tok.kind))],
        severity=Error.SError
      )
      (recoveryText, recoveryTok, state1)
    },
  }
}
and parseDirectiveTopItem = (state: ParseState) => {
  let (directiveTok, state1) = expectSimple(Lexer.Directive, state)
  let (nameText, nameTok, state2) = expectName(state1)
  let (nameId, state3) = freshId(state2)
  let name: SurfaceAst.Name = {
    node: { id: nameId, span: nameTok.span },
    text: nameText,
  }
  let (_, state4) = expectSimpleOrRecover(
    Lexer.SemiColon,
    state3,
    "after directive"
  )
  let (dirId, state5) = freshId(state4)
  let directive: SurfaceAst.Directive = { name, args: [] }
  let topItem: SurfaceAst.TopItem = SurfaceAst.Directive(directive)
  let _ = directiveTok
  (topItem, state5)
}
and parseImportClause = (state: ParseState) => {
  let tok = currentToken(state)
  match (tok.kind) {
    Lexer.Star => {
      let state1 = dropToken(state)
      if (kindIs(currentToken(state1).kind, Lexer.LitName("as"))) {
        let (_, state2) = expectKeyword("as", state1)
        let (aliasText, aliasTok, state3) = expectAnyName(state2)
        let (aliasId, state4) = freshId(state3)
        let alias: SurfaceAst.Name = {
          node: { id: aliasId, span: aliasTok.span },
          text: aliasText,
        }
        (Some(alias), [], state4)
      } else {
        (None, [], state1)
      }
    },
    Lexer.LBrace => {
      let (_, state1) = expectSimple(Lexer.LBrace, state)
      let rec loop = (
        namesRev: List<SurfaceAst.ImportName>,
        stateX: ParseState,
      ) => {
        let tokX = currentToken(stateX)
        match (tokX.kind) {
          Lexer.RBrace => {
            let (_, stateY) = expectSimple(Lexer.RBrace, stateX)
            (None, List.reverse(namesRev), stateY)
          },
          Lexer.EOF => (None, List.reverse(namesRev), stateX),
          _ => {
            let (nameText, nameTok, stateY) = expectAnyName(stateX)
            let (nameId, stateY2) = freshId(stateY)
            let name: SurfaceAst.Name = {
              node: { id: nameId, span: nameTok.span },
              text: nameText,
            }
            let (aliasOpt, stateY3) = if (
              kindIs(currentToken(stateY2).kind, Lexer.LitName("as"))
            ) {
              let (_, stateAs) = expectKeyword("as", stateY2)
              let (aliasText, aliasTok, stateAlias) = expectAnyName(stateAs)
              let (aliasId, stateAlias2) = freshId(stateAlias)
              let alias: SurfaceAst.Name = {
                node: { id: aliasId, span: aliasTok.span },
                text: aliasText,
              }
              (Some(alias), stateAlias2)
            } else {
              (None, stateY2)
            }
            let nextNames = [{ name, alias: aliasOpt }: SurfaceAst.ImportName, ...namesRev]
            let stateY4 = if (kindIs(currentToken(stateY3).kind, Lexer.Comma)) {
              let (_, stateComma) = expectSimple(Lexer.Comma, stateY3)
              stateComma
            } else {
              stateY3
            }
            loop(nextNames, stateY4)
          },
        }
      }
      loop([], state1)
    },
    _ => (None, [], state),
  }
}
and parseImportTopItem = (state: ParseState) => {
  let (fromTok, state1) = expectKeyword("from", state)
  let (modulePath, _moduleTok, state2) = expectStringLiteral(state1)
  let (_, state3) = expectKeyword("import", state2)
  let (alias, names, state4) = parseImportClause(state3)
  let (_, state5) = expectSimpleOrRecover(
    Lexer.SemiColon,
    state4,
    "after import declaration"
  )
  let (id, state6) = freshId(state5)
  let importDecl: SurfaceAst.ImportDecl = {
    node: { id, span: fromTok.span },
    modulePath,
    alias,
    names,
  }
  (SurfaceAst.Import(importDecl), state6)
}
and parseReexportTopItem = (state: ParseState) => {
  let (reexportTok, state1) = expectKeyword("reexport", state)
  let (modulePath, _moduleTok, state2) = expectStringLiteral(state1)
  let (_, state3) = expectSimpleOrRecover(
    Lexer.SemiColon,
    state2,
    "after reexport declaration"
  )
  let (id, state4) = freshId(state3)
  let reexportDecl: SurfaceAst.ReexportDecl = {
    node: { id, span: reexportTok.span },
    modulePath,
  }
  (SurfaceAst.Reexport(reexportDecl), state4)
}
and parseExportFromTopItem = (state: ParseState) => {
  let (exportTok, state1) = expectKeyword("export", state)
  let (_, state2) = expectKeyword("from", state1)
  let (modulePath, _moduleTok, state3) = expectStringLiteral(state2)
  let rec skipClause = (stateX: ParseState) => {
    let tokX = currentToken(stateX)
    match (tokX.kind) {
      Lexer.SemiColon => stateX,
      Lexer.EOF => stateX,
      _ => skipClause(dropToken(stateX)),
    }
  }
  let state4 = skipClause(state3)
  let (_, state5) = expectSimpleOrRecover(
    Lexer.SemiColon,
    state4,
    "after export-from declaration"
  )
  let (id, state6) = freshId(state5)
  let reexportDecl: SurfaceAst.ReexportDecl = {
    node: { id, span: exportTok.span },
    modulePath,
  }
  (SurfaceAst.Reexport(reexportDecl), state6)
}
and parseTopLevels = (state: ParseState) => {
  let continueTopLevels = (nextState: ParseState) => {
    let safe = ensureProgress(state, nextState, "top-level parsing")
    parseTopLevels(safe)
  }
  let tok = currentToken(state)
  //print(tok)
  if (isOpaqueTopLevelStart(state)) {
    let (trivia, state1) = consumeOpaqueLine(state)
    let topTrivia: SurfaceAst.TopItem = SurfaceAst.Trivia(trivia)
    let (rest, state2) = continueTopLevels(state1)
    ([topTrivia, ...rest], state2)
  } else {
    match (tok.kind) {
      Lexer.EOF => ([], state),
      Lexer.SemiColon => {
        // Skip semicolons
        let state1 = dropToken(state)
        continueTopLevels(state1)
      },
      Lexer.LineComment(text) => {
        let state1 = dropToken(state)
        let (id, state2) = freshId(state1)
        let trivia = makeLineTrivia(id, tok.span, text)
        let topTrivia: SurfaceAst.TopItem = SurfaceAst.Trivia(trivia)
        let (rest, state3) = continueTopLevels(state2)
        ([topTrivia, ...rest], state3)
      },
      Lexer.Opaque(text) => {
        let state1 = dropToken(state)
        let (id, state2) = freshId(state1)
        let trivia = makeOpaqueTrivia(id, tok.span, text)
        let topTrivia: SurfaceAst.TopItem = SurfaceAst.Trivia(trivia)
        let (rest, state3) = continueTopLevels(state2)
        ([topTrivia, ...rest], state3)
      },
      Lexer.Directive => {
        let (directive, state1) = parseDirectiveTopItem(state)
        let (rest, state2) = continueTopLevels(state1)
        ([directive, ...rest], state2)
      },
      Lexer.LitName(name) when name == "from" => {
        let (importItem, state1) = parseImportTopItem(state)
        let (rest, state2) = continueTopLevels(state1)
        ([importItem, ...rest], state2)
      },
      Lexer.LitName(name) when name == "reexport" => {
        let (reexportItem, state1) = parseReexportTopItem(state)
        let (rest, state2) = continueTopLevels(state1)
        ([reexportItem, ...rest], state2)
      },
      Lexer.LitName(name) when name == "let" => {
        let (group, state1) = parseLetGroup(state)
        let state2 = consumeTopLevelSemicolon(state1, topItemSpan(group))
        let (rest, state3) = continueTopLevels(state2)
        ([group, ...rest], state3)
      },
      Lexer.LitName(name) when name == "export" => {
        let nextTok = tokenAt(state.tokens, 1)
        match (nextTok) {
          Some({ kind: Lexer.LitName("from"), _ }) => {
            let (reexportItem, state1) = parseExportFromTopItem(state)
            let (rest, state2) = continueTopLevels(state1)
            ([reexportItem, ...rest], state2)
          },
          _ => {
            let exportTok = tok
            let state1 = dropToken(state)
            let (exportId, state1b) = freshId(state1)
            let (inner, state2) = parseTopLevels(state1b)
            match (inner) {
              [SurfaceAst.DeclGroup(dg), ...rest] => {
                // Create Export node for the export keyword
                let exportNode = Export(
                  { node: { id: exportId, span: exportTok.span }, },
                )
                // Mark DeclGroup as exported
                let exportedDg = { ...dg, exported: true }
                ([exportNode, SurfaceAst.DeclGroup(exportedDg), ...rest], state2)
              },
              [] => {
                let exportRecovery: SurfaceAst.Mark = {
                  node: { id: exportId, span: exportTok.span },
                  kind: SurfaceAst.InvalidTopLevel("export"),
                  expected: SurfaceAst.ExpectTopItem(SurfaceAst.TopItemDeclGroup),
                }
                let recoveryItem: SurfaceAst.TopItem = Error.createMarkedError(
                  Error.Parsing,
                  exportRecovery,
                  "Expected declaration after export",
                  SurfaceAst.Mark(exportRecovery),
                  clues=[Error.Note("export must be followed by a declaration")],
                  severity=Error.SError
                )
                ([recoveryItem], state2)
              },
              [first, ...rest] => {
                let exportRecovery: SurfaceAst.Mark = {
                  node: { id: exportId, span: exportTok.span },
                  kind: SurfaceAst.InvalidTopLevel("export"),
                  expected: SurfaceAst.ExpectTopItem(SurfaceAst.TopItemDeclGroup),
                }
                let recoveryItem: SurfaceAst.TopItem = Error.createMarkedError(
                  Error.Parsing,
                  exportRecovery,
                  "Invalid export",
                  SurfaceAst.Mark(exportRecovery),
                  clues=[Error.Note("export can only be applied to declarations")],
                  severity=Error.SError
                )
                ([recoveryItem, first, ...rest], state2)
              },
            }
          },
        }
      },
      Lexer.LitName(name) when name == "type" => {
        let (typeDef, state1) = parseTypeDef(state)
        let (rest, state2) = continueTopLevels(state1)
        ([typeDef, ...rest], state2)
      },
      Lexer.LitName(name) when name == "record" => {
        let (typeDef, state1) = parseRecordDef(state)
        let (rest, state2) = continueTopLevels(state1)
        ([typeDef, ...rest], state2)
      },
      _ => {
        let (trivia, state1) = consumeOpaqueLine(state)
        let topTrivia: SurfaceAst.TopItem = SurfaceAst.Trivia(trivia)
        let (rest, state2) = continueTopLevels(state1)
        ([topTrivia, ...rest], state2)
      },
    }
  }
}
and parseBinding = (state: ParseState, startSpanOpt: Option<Source.Span>) => {
  let (id, state1) = freshId(state)
  let (pattern, state2) = parsePattern(state1)
  let rec skipLineComments = (line: Number, stateX: ParseState) => {
    match (currentToken(stateX).kind) {
      Lexer.LineComment(_) when currentToken(stateX).span.line == line =>
        skipLineComments(line, dropToken(stateX)),
      _ => stateX,
    }
  }
  let state2b = skipLineComments(pattern.node.span.line, state2)
  //Optionally parse type annotation after ':'
  let (typeOpt, state3) = if (kindIs(currentToken(state2b).kind, Lexer.Colon)) {
    let (_, state_temp) = expectSimple(Lexer.Colon, state2b)
    let (ty, state_next) = parseTypeExpr(state_temp)
    (Some(ty), state_next)
  } else {
    (None, state2b)
  }
  let (state4, hasEq) = if (kindIs(currentToken(state3).kind, Lexer.Eq)) {
    let (_, nextState) = expectSimple(Lexer.Eq, state3)
    (nextState, true)
  } else if (isValueBoundary(currentToken(state3)) || isOpaqueLineStart(state3)) {
    let errSpan = Source.makeSpan(
      pattern.node.span.line,
      pattern.node.span.col,
      pattern.node.span.end,
      pattern.node.span.end
    )
    let (markId, state_temp) = freshId(state3)
    let mark: SurfaceAst.Mark = {
      node: { id: markId, span: errSpan },
      kind: SurfaceAst.MissingToken("="),
      expected: SurfaceAst.ExpectToken,
    }
    let recoveryState = Error.createMarkedError(
      Error.Parsing,
      mark,
      "Expected '=' in let binding",
      state_temp,
      clues=[
        Error.Expected("="),
        Error.Received(Lexer.tokenKindToString(currentToken(state3).kind)),
      ],
      severity=Error.SError
    )
    (recoveryState, false)
  } else {
    let (markId, state_temp) = freshId(state3)
    let mark: SurfaceAst.Mark = {
      node: { id: markId, span: currentToken(state3).span },
      kind: SurfaceAst.MissingToken("="),
      expected: SurfaceAst.ExpectToken,
    }
    let recoveryState = Error.createMarkedError(
      Error.Parsing,
      mark,
      "Expected '=' in let binding",
      state3,
      clues=[Error.Received(Lexer.tokenKindToString(currentToken(state3).kind))],
      severity=Error.SError
    )
    (recoveryState, false)
  }
  let (value, state5): (SurfaceAst.Expr, ParseState) = if (
    hasEq
    && (isValueBoundary(currentToken(state4)) || isOpaqueLineStart(state4))
  ) {
    makeInferredExprHole(
      state4,
      pattern.node.span,
      "Expected expression after '=' in let binding",
      [
        Error.Expected("expression"),
        Error.Received(Lexer.tokenKindToString(currentToken(state4).kind)),
      ]
    )
  } else if (hasEq) {
    parseExpr(state4)
  } else {
    makeInferredExprHole(
      state4,
      pattern.node.span,
      "Expected expression in let binding",
      [
        Error.Expected("expression"),
        Error.Received(Lexer.tokenKindToString(currentToken(state4).kind)),
      ]
    )
  }
  // Use startSpan if provided (for 'let' keyword), otherwise start from pattern
  let span = match (startSpanOpt) {
    Some(startSpan) => spanFromTokens(startSpan, value.node.span),
    None => spanFromTokens(pattern.node.span, value.node.span),
  }
  let binding: SurfaceAst.LetBinding = {
    node: { id, span },
    name: pattern,
    annotation: typeOpt,
    hasEq,
    value,
  }
  (binding, state5)
}
and parseLetMods: ParseState => (SurfaceAst.LetGroupMods, ParseState) =
  state => {
    let tok = currentToken(state)
    if (kindIs(tok.kind, Lexer.LitName("rec"))) {
      let state1 = dropToken(state)
      (SurfaceAst.Rec, state1)
    } else if (kindIs(tok.kind, Lexer.LitName("mut"))) {
      let state1 = dropToken(state)
      (SurfaceAst.Mut, state1)
    } else {
      (SurfaceAst.Plain, state)
    }
  }
and parseLetGroup: ParseState => (SurfaceAst.TopItem, ParseState) = state => {
  let (id, state1) = freshId(state)
  let (letTok, state2) = expectKeyword("let", state1)
  let (mods, state3) = parseLetMods(state2)
  let (firstBinding, state4) = parseBinding(state3, Some(letTok.span))
  let mut bindings = [firstBinding]
  let mut currentState = state4
  while (kindIs(currentToken(currentState).kind, Lexer.LitName("and"))) {
    let before = currentState
    let (andTok, state_temp) = expectKeyword("and", currentState)
    let (binding, state_temp2) = parseBinding(state_temp, Some(andTok.span))
    bindings = [binding, ...bindings]
    currentState = ensureProgress(before, state_temp2, "let-group bindings")
  }
  let (lastBinding, stateAfterBindings) = match (List.head(bindings)) {
    Some(b) => (b, currentState),
    None => {
      let (pat, stateP) = makeWildcardPattern(currentState, letTok.span)
      let (holeExpr, stateE) = makeInferredExprHole(
        stateP,
        letTok.span,
        "Expected let binding",
        [Error.Expected("binding"), Error.Received("EOF")]
      )
      let (bindId, stateB) = freshId(stateE)
      let binding: SurfaceAst.LetBinding = {
        node: { id: bindId, span: letTok.span },
        name: pat,
        annotation: None,
        hasEq: false,
        value: holeExpr,
      }
      (binding, stateB)
    },
  }
  let reversedBindings = List.reverse(bindings)
  let span = spanFromTokens(letTok.span, lastBinding.node.span)
  let topLevel: SurfaceAst.TopItem = SurfaceAst.DeclGroup(
    {
      node: { id, span },
      exported: false,
      kind: LetGroup(mods),
      decls: [LetDecl({ node: { id, span }, bindings: reversedBindings })],
    },
  )
  (topLevel, stateAfterBindings)
}
and parseTypeParams = (state: ParseState) => {
  if (!kindIs(currentToken(state).kind, Lexer.LAngle)) {
    ([], state)
  } else {
    let (_, state1) = expectSimple(Lexer.LAngle, state)
    let rec parseItems = (items, stateX) => {
      let tok = currentToken(stateX)
      if (kindIs(tok.kind, Lexer.Arrow)) {
        (List.reverse(items), stateX)
      } else if (kindIs(tok.kind, Lexer.EOF)) {
        (List.reverse(items), stateX)
      } else {
        let before = stateX
        let (paramText, paramTok, state2) = expectTypeParamName(stateX)
        let (paramId, state3) = freshId(state2)
        let param: SurfaceAst.Name = {
          node: { id: paramId, span: paramTok.span },
          text: paramText,
        }
        let state4 = if (kindIs(currentToken(state3).kind, Lexer.Comma)) {
          let (_, stateComma) = expectSimple(Lexer.Comma, state3)
          stateComma
        } else {
          state3
        }
        let nextState = ensureProgress(before, state4, "type parameter list")
        parseItems([param, ...items], nextState)
      }
    }
    let (typeParams, state2) = parseItems([], state1)
    let (_, state3) = expectSimpleOrRecover(
      Lexer.Arrow,
      state2,
      "to close type parameter list"
    )
    (typeParams, state3)
  }
}
and parseTypeDef: ParseState => (SurfaceAst.TopItem, ParseState) = state => {
  let (id, state1) = freshId(state)
  let (typeTok, state2) = expectKeyword("type", state1)
  let (mods, state3): (SurfaceAst.TypeGroupMods, ParseState) = if (
    kindIs(currentToken(state2).kind, Lexer.LitName("rec"))
  ) {
    let stateRec = dropToken(state2)
    (SurfaceAst.Rec, stateRec)
  } else {
    (SurfaceAst.Plain, state2)
  }
  // Parse optional 'infectious <domain>' modifier
  let (infectionOpt, state3b) = if (
    kindIs(currentToken(state3).kind, Lexer.LitName("infectious"))
  ) {
    let stateInf = dropToken(state3)
    let domainTok = currentToken(stateInf)
    match (domainTok.kind) {
      Lexer.LitName(domainName) => {
        let stateDom = dropToken(stateInf)
        let (domId, stateDom2) = freshId(stateDom)
        let domainNameNode: SurfaceAst.Name = {
          node: { id: domId, span: domainTok.span },
          text: domainName,
        }
        (Some(domainNameNode), stateDom2)
      },
      _ => (None, stateInf),
    }
  } else {
    (None, state3)
  }
  let (name, nameTok, state4) = expectConstructor(state3b)
  let mut lastSpan = nameTok.span
  let (typeParams, state5) = parseTypeParams(state4)
  if (List.length(typeParams) > 0) {
    match (List.head(List.reverse(typeParams))) {
      Some(lastTypeParam) => lastSpan = lastTypeParam.node.span,
      None => void,
    }
  }
  let (body, state6) = if (kindIs(currentToken(state5).kind, Lexer.Eq)) {
    let (_, stateEq) = expectSimple(Lexer.Eq, state5)
    let tok = currentToken(stateEq)
    let isVariantStart = match (tok.kind) {
      Lexer.Pipe => true,
      Lexer.Directive => true,
      Lexer.ConstructorTok(_) => false,
      _ => false,
    }
    if (isVariantStart) {
      let stateAfterPipe = if (kindIs(tok.kind, Lexer.Pipe)) {
        let (_, stateP) = expectSimple(Lexer.Pipe, stateEq)
        stateP
      } else {
        stateEq
      }
      let rec parseConstructors = (items, stateX) => {
        // Parse optional @value or @effect annotation
        let (annotOpt, stateAnnot) = if (
          kindIs(currentToken(stateX).kind, Lexer.Directive)
        ) {
          let stateAt = dropToken(stateX)
          let annotTok = currentToken(stateAt)
          match (annotTok.kind) {
            Lexer.LitName(aname) when aname == "value" || aname == "effect" => {
              let stateA = dropToken(stateAt)
              (Some(aname), stateA)
            },
            _ => (None, stateAt),
          }
        } else {
          (None, stateX)
        }
        let (cname, cTok, stateY) = expectConstructor(stateAnnot)
        let (nameId, stateY2) = freshId(stateY)
        let ctorName: SurfaceAst.Name = {
          node: { id: nameId, span: cTok.span },
          text: cname,
        }
        lastSpan = cTok.span
        let (payloadOpt, stateY3) = if (
          kindIs(currentToken(stateY2).kind, Lexer.LParen)
        ) {
          let (_, stateP) = expectSimple(Lexer.LParen, stateY2)
          let (payload, stateP2) = parseTypeExpr(stateP)
          let (_, stateP3) = expectSimpleOrRecover(
            Lexer.RParen,
            stateP2,
            "to close type constructor payload"
          )
          lastSpan = payload.node.span
          (Some(payload), stateP3)
        } else if (kindIs(currentToken(stateY2).kind, Lexer.LAngle)) {
          // Also accept <T> type arguments (e.g. ISome<T>)
          let (_, stateA) = expectSimple(Lexer.LAngle, stateY2)
          let (payload, stateA2) = parseTypeExpr(stateA)
          let (_, stateA3) = expectSimpleOrRecover(
            Lexer.Arrow,
            stateA2,
            "to close type argument list"
          )
          lastSpan = payload.node.span
          (Some(payload), stateA3)
        } else {
          (None, stateY2)
        }
        let entry = (ctorName, payloadOpt, annotOpt)
        let nextItems = [entry, ...items]
        let tokNext = currentToken(stateY3)
        if (kindIs(tokNext.kind, Lexer.Pipe)) {
          let (_, stateP) = expectSimple(Lexer.Pipe, stateY3)
          parseConstructors(nextItems, stateP)
        } else {
          (List.reverse(nextItems), stateY3)
        }
      }
      let hadLeadingPipe = kindIs(tok.kind, Lexer.Pipe)
      let (cases, stateAfter) = parseConstructors([], stateAfterPipe)
      (SurfaceAst.Variant(cases, hadLeadingPipe), stateAfter)
    } else {
      // Check if the first token after = is a @value/@effect annotation
      let (firstAnnotOpt, stateBeforeFirst) = if (
        kindIs(currentToken(stateEq).kind, Lexer.Directive)
      ) {
        let stateAt = dropToken(stateEq)
        let annotTok = currentToken(stateAt)
        match (annotTok.kind) {
          Lexer.LitName(aname) when aname == "value" || aname == "effect" => {
            let stateA = dropToken(stateAt)
            (Some(aname), stateA)
          },
          _ => (None, stateAt),
        }
      } else {
        (None, stateEq)
      }
      let (firstTy, stateAfterFirst) = parseTypeExpr(stateBeforeFirst)
      if (kindIs(currentToken(stateAfterFirst).kind, Lexer.Pipe)) {
        let packCtorPayload = (
          args: List<SurfaceAst.TypeExpr>,
          stateX: ParseState,
        ) => {
          match (args) {
            [] => (None, stateX),
            [only] => (Some(only), stateX),
            [firstArg, ...restArgs] => {
              let allArgs = [firstArg, ...restArgs]
              let lastArg = List.head(List.reverse(allArgs))
              let tupleSpan = match (lastArg) {
                Some(lastTy) =>
                  spanFromTokens(firstArg.node.span, lastTy.node.span),
                None => firstArg.node.span,
              }
              let (tupleId, stateY) = freshId(stateX)
              let tupleTy = makeTypeExpr(
                tupleId,
                tupleSpan,
                SurfaceAst.Tuple(allArgs)
              )
              (Some(tupleTy), stateY)
            },
          }
        }
        match (firstTy.kind) {
          SurfaceAst.Ref(name, firstArgs) => {
            let (firstPayload, stateAfterFirstPayload) = packCtorPayload(
              firstArgs,
              stateAfterFirst
            )
            let firstCase = (name, firstPayload, firstAnnotOpt)
            let (_, statePipe) = expectSimple(
              Lexer.Pipe,
              stateAfterFirstPayload
            )
            let rec parseRest = (items, stateX) => {
              // Parse optional @value or @effect annotation
              let (restAnnotOpt, stateBeforeType) = if (
                kindIs(currentToken(stateX).kind, Lexer.Directive)
              ) {
                let stateAt = dropToken(stateX)
                let annotTok = currentToken(stateAt)
                match (annotTok.kind) {
                  Lexer.LitName(aname) when aname == "value"
                    || aname == "effect" => {
                    let stateA = dropToken(stateAt)
                    (Some(aname), stateA)
                  },
                  _ => (None, stateAt),
                }
              } else {
                (None, stateX)
              }
              let (caseTy, stateY) = parseTypeExpr(stateBeforeType)
              let (nextItems, stateY2) = match (caseTy.kind) {
                SurfaceAst.Ref(ctorName, ctorArgs) => {
                  let (payload, statePayload) = packCtorPayload(
                    ctorArgs,
                    stateY
                  )
                  lastSpan = caseTy.node.span
                  ([(ctorName, payload, restAnnotOpt), ...items], statePayload)
                },
                _ => {
                  lastSpan = caseTy.node.span
                  (items, stateY)
                },
              }
              let tokNext = currentToken(stateY2)
              if (kindIs(tokNext.kind, Lexer.Pipe)) {
                let (_, stateP) = expectSimple(Lexer.Pipe, stateY2)
                parseRest(nextItems, stateP)
              } else {
                (List.reverse(nextItems), stateY2)
              }
            }
            let (restCases, stateAfter) = parseRest([firstCase], statePipe)
            (SurfaceAst.Variant(restCases, false), stateAfter)
          },
          _ => {
            lastSpan = firstTy.node.span
            (SurfaceAst.Alias(firstTy), stateAfterFirst)
          },
        }
      } else {
        lastSpan = firstTy.node.span
        (SurfaceAst.Alias(firstTy), stateAfterFirst)
      }
    }
  } else {
    let (holeId, stateHole) = freshId(state5)
    let holeExpr = makeTypeExpr(
      holeId,
      nameTok.span,
      SurfaceAst.Hole(
        {
          node: { id: holeId, span: nameTok.span },
          kind: SurfaceAst.TypeHole,
          origin: SurfaceAst.UserTyped,
        },
      )
    )
    (SurfaceAst.Alias(holeExpr), stateHole)
  }
  let fullSpan = spanFromTokens(typeTok.span, lastSpan)
  let (typeDeclId, state7) = freshId(state6)
  let (nameId, state8) = freshId(state7)
  let topLevel: SurfaceAst.TopItem = SurfaceAst.DeclGroup(
    {
      node: { id, span: fullSpan },
      exported: false,
      kind: TypeGroup(mods),
      decls: [
        TypeDecl(
          {
            node: { id: typeDeclId, span: fullSpan },
            name: { node: { id: nameId, span: nameTok.span }, text: name },
            infection: infectionOpt,
            typeParams,
            body,
          },
        ),
      ],
    },
  )
  let state9 = consumeTopLevelSemicolon(state8, fullSpan)
  (topLevel, state9)
}
and parseRecordDef = (state: ParseState) => {
  let (id, state1) = freshId(state)
  let (recordTok, state2) = expectKeyword("record", state1) // Expect "record" keyword
  let (mods, state3): (SurfaceAst.RecordGroupMods, ParseState) = if (
    kindIs(currentToken(state2).kind, Lexer.LitName("rec"))
  ) {
    let stateRec = dropToken(state2)
    (SurfaceAst.Rec, stateRec)
  } else {
    (SurfaceAst.Plain, state2)
  }
  let (name, nameTok, state4) = expectConstructor(state3) // Expect the record name (e.g., MyRecord)
  let (typeParams, state5) = parseTypeParams(state4)
  let (_, state6) = expectSimple(Lexer.Eq, state5) // Expect =
  let (lbraceTok, state7) = expectSimple(Lexer.LBrace, state6)
  let rec parseFields = (fields, stateX) => {
    let tok = currentToken(stateX)
    if (kindIs(tok.kind, Lexer.RBrace)) {
      (List.reverse(fields), stateX)
    } else if (kindIs(tok.kind, Lexer.EOF)) {
      (List.reverse(fields), stateX)
    } else {
      let before = stateX
      let (fieldNameText, fieldTok, state2) = expectName(stateX)
      let (fieldNameId, state2b) = freshId(state2)
      let fieldName: SurfaceAst.Name = {
        node: { id: fieldNameId, span: fieldTok.span },
        text: fieldNameText,
      }
      let (_, state3) = expectSimple(Lexer.Colon, state2b)
      let (fieldType, state4b) = parseTypeExpr(state3)
      let nextFields = [(fieldName, fieldType), ...fields]
      let state5b = if (kindIs(currentToken(state4b).kind, Lexer.Comma)) {
        let (_, stateComma) = expectSimple(Lexer.Comma, state4b)
        stateComma
      } else {
        state4b
      }
      let nextState = ensureProgress(
        before,
        state5b,
        "record declaration fields"
      )
      parseFields(nextFields, nextState)
    }
  }
  let (fields, state8) = parseFields([], state7)
  let (rbraceTok, state9) = expectSimpleOrRecover(
    Lexer.RBrace,
    state8,
    "to close record declaration"
  )
  let fullSpan = spanFromTokens(recordTok.span, rbraceTok.span)
  let (recordDeclId, state10) = freshId(state9)
  let (nameId, state11) = freshId(state10)
  let topLevel: SurfaceAst.TopItem = SurfaceAst.DeclGroup(
    {
      node: { id, span: fullSpan },
      exported: false,
      kind: RecordGroup(mods),
      decls: [
        RecordDecl(
          {
            node: { id: recordDeclId, span: fullSpan },
            name: { node: { id: nameId, span: nameTok.span }, text: name },
            typeParams,
            fields,
          },
        ),
      ],
    },
  )
  let state12 = consumeTopLevelSemicolon(state11, fullSpan)
  (topLevel, state12)
}
and parseBlockItems = (state: ParseState) => {
  let continueBlockItems = (nextState: ParseState) => {
    let safe = ensureProgress(state, nextState, "block item parsing")
    parseBlockItems(safe)
  }
  if (isOpaqueLineStart(state)) {
    let (trivia, state1) = consumeOpaqueLine(state)
    let item = SurfaceAst.TriviaItem(trivia)
    let (restItems, state2) = continueBlockItems(state1)
    ([item, ...restItems], state2)
  } else {
    let makeMissingSemicolonItem = (stateX: ParseState, anchorSpan: Source.Span) => {
      let atTok = currentToken(stateX)
      let (id, state1) = freshId(stateX)
      match (atTok.kind) {
        Lexer.Comma => {
          let mark: SurfaceAst.Mark = {
            node: { id, span: atTok.span },
            kind: SurfaceAst.UnexpectedToken(","),
            expected: SurfaceAst.ExpectToken,
          }
          let item: SurfaceAst.BlockItem = Error.createMarkedError(
            Error.Parsing,
            mark,
            "Unexpected ',' after statement; expected ';'",
            SurfaceAst.MarkItem(mark),
            clues=[Error.Expected(";"), Error.Received(",")],
            severity=Error.Warning
          )
          (item, state1)
        },
        _ => {
          let mark: SurfaceAst.Mark = {
            node: { id, span: atTok.span },
            kind: SurfaceAst.MissingSemicolon,
            expected: SurfaceAst.ExpectToken,
          }
          let item: SurfaceAst.BlockItem = Error.createMarkedError(
            Error.Parsing,
            mark,
            "Expected ';' after statement",
            SurfaceAst.MarkItem(mark),
            clues=[
              Error.Expected(";"),
              Error.Received(Lexer.tokenKindToString(atTok.kind)),
            ],
            severity=Error.Warning
          )
          (item, state1)
        },
      }
    }

    let tok = currentToken(state)
    match (tok.kind) {
      Lexer.RBrace => ([], state),
      Lexer.EOF => ([], state),
      Lexer.SemiColon => parseBlockItems(dropToken(state)),
      Lexer.Comma => {
        let state1 = dropToken(state)
        let item = SurfaceAst.Comma
        let (restItems, state2) = continueBlockItems(state1)
        ([item, ...restItems], state2)
      },
      Lexer.LineComment(text) => {
        let state1 = dropToken(state)
        let (id, state2) = freshId(state1)
        let trivia = makeLineTrivia(id, tok.span, text)
        let item = SurfaceAst.TriviaItem(trivia)
        let (restItems, state3) = continueBlockItems(state2)
        ([item, ...restItems], state3)
      },
      Lexer.Opaque(text) => {
        let state1 = dropToken(state)
        let (id, state2) = freshId(state1)
        let trivia = makeOpaqueTrivia(id, tok.span, text)
        let item = SurfaceAst.TriviaItem(trivia)
        let (restItems, state3) = continueBlockItems(state2)
        ([item, ...restItems], state3)
      },
      Lexer.Directive => {
        let (directiveTop, state1) = parseDirectiveTopItem(state)
        let (item, nextState): (SurfaceAst.BlockItem, ParseState) = match (
          directiveTop
        ) {
          SurfaceAst.Directive(directive) =>
            (SurfaceAst.Directive(directive): SurfaceAst.BlockItem, state1),
          _ => {
            let mark: SurfaceAst.Mark = {
              node: { id: 0, span: tok.span },
              kind: SurfaceAst.InvalidTopLevel("directive in block"),
              expected: SurfaceAst.ExpectTopItem(SurfaceAst.TopItemDirective),
            }
            // Guarantee progress even if directive recovery returned without consuming input.
            let recoverState = dropToken(state1)
            (
              Error.createMarkedError(
                Error.Parsing,
                mark,
                "Expected directive item in block",
                SurfaceAst.MarkItem(mark),
                clues=[
                  Error.Note("parser recovered from invalid directive shape"),
                ],
                severity=Error.SError
              ),
              recoverState,
            )
          },
        }
        let (restItems, state2) = continueBlockItems(nextState)
        ([item, ...restItems], state2)
      },
      Lexer.LitName("let") => {
        let (topItem, state1) = parseLetGroup(state)
        match (topItem) {
          SurfaceAst.DeclGroup(group) => {
            let blockItem: SurfaceAst.BlockItem = SurfaceAst.DeclGroup(group)
            if (kindIs(currentToken(state1).kind, Lexer.SemiColon)) {
              let state1b = dropToken(state1)
              let (restItems, state2) = continueBlockItems(state1b)
              ([blockItem, SurfaceAst.Semicolon, ...restItems], state2)
            } else {
              let (markItem, state1b) = makeMissingSemicolonItem(
                state1,
                group.node.span
              )
              let (restItems, state2) = continueBlockItems(state1b)
              ([blockItem, markItem, ...restItems], state2)
            }
          },
          _ => {
            let mark: SurfaceAst.Mark = {
              node: { id: 0, span: tok.span },
              kind: SurfaceAst.InvalidTopLevel("let group in block"),
              expected: SurfaceAst.ExpectTopItem(SurfaceAst.TopItemDeclGroup),
            }
            let blockItem: SurfaceAst.BlockItem = Error.createMarkedError(
              Error.Parsing,
              mark,
              "Expected let declaration group in block",
              SurfaceAst.MarkItem(mark),
              clues=[
                Error.Note("parser recovered from invalid let-group shape"),
              ],
              severity=Error.SError
            )
            // Guarantee progress even if let-group recovery returned without consuming input.
            let state1b = dropToken(state1)
            let (restItems, state2) = continueBlockItems(state1b)
            ([blockItem, ...restItems], state2)
          },
        }
      },
      _ => {
        let (expr, state1) = parseExpr(state)
        if (kindIs(currentToken(state1).kind, Lexer.Eq)) {
          let (_, stateAssign0) = expectSimple(Lexer.Eq, state1)
          let (assignValue, stateAssign1) = if (
            isValueBoundary(currentToken(stateAssign0))
          ) {
            makeInferredExprHole(
              stateAssign0,
              expr.node.span,
              "Expected expression after '=' in assignment",
              [
                Error.Expected("expression"),
                Error.Received(
                  Lexer.tokenKindToString(currentToken(stateAssign0).kind),
                ),
              ]
            )
          } else {
            parseExpr(stateAssign0)
          }
          let stateAssign2 = stateAssign1
          let (exprId, stateAssign3) = freshId(stateAssign2)
          let span = spanFromTokens(expr.node.span, assignValue.node.span)
          let assignExpr = makeExpr(
            exprId,
            span,
            SurfaceAst.Assign({ target: expr, value: assignValue })
          )
          if (kindIs(currentToken(stateAssign3).kind, Lexer.SemiColon)) {
            let stateAssign4 = dropToken(stateAssign3)
            let item = SurfaceAst.ExprItem(assignExpr)
            let (restItems, stateEnd) = continueBlockItems(stateAssign4)
            ([item, SurfaceAst.Semicolon, ...restItems], stateEnd)
          } else if (
            kindIs(currentToken(stateAssign3).kind, Lexer.RBrace)
            || kindIs(currentToken(stateAssign3).kind, Lexer.EOF)
          ) {
            let item = SurfaceAst.ExprItem(assignExpr)
            let (restItems, stateEnd) = continueBlockItems(stateAssign3)
            ([item, ...restItems], stateEnd)
          } else {
            let item = SurfaceAst.ExprItem(assignExpr)
            let (markItem, stateAssign4) = makeMissingSemicolonItem(
              stateAssign3,
              assignValue.node.span
            )
            let (restItems, stateEnd) = continueBlockItems(stateAssign4)
            ([item, markItem, ...restItems], stateEnd)
          }
        } else {
          if (kindIs(currentToken(state1).kind, Lexer.SemiColon)) {
            let stateExprStmt = dropToken(state1)
            let item = SurfaceAst.ExprItem(expr)
            let (restItems, stateEnd) = continueBlockItems(stateExprStmt)
            ([item, SurfaceAst.Semicolon, ...restItems], stateEnd)
          } else if (
            kindIs(currentToken(state1).kind, Lexer.RBrace)
            || kindIs(currentToken(state1).kind, Lexer.EOF)
          ) {
            let item = SurfaceAst.ExprItem(expr)
            let (restItems, stateEnd) = continueBlockItems(state1)
            ([item, ...restItems], stateEnd)
          } else {
            let item = SurfaceAst.ExprItem(expr)
            let (markItem, stateExprStmt) = makeMissingSemicolonItem(
              state1,
              expr.node.span
            )
            let (restItems, stateEnd) = continueBlockItems(stateExprStmt)
            ([item, markItem, ...restItems], stateEnd)
          }
        }
      },
    }
  }
}
and parsePatternWithPinMode = (state: ParseState, pinBareIdent: Bool) => {
  let (leadingTrivia, state0) = takeLeadingGapTrivia(state, [])
  let state = state0
  let tok = currentToken(state)
  let (corePattern, coreState) = match (tok.kind) {
    Lexer.Wildcard => {
      let state1 = dropToken(state)
      let (id, state2) = freshId(state1)
      let node = { id, span: tok.span }
      let attach = { leading: [], trailing: [], dangling: [] }
      let kind: SurfaceAst.PatternKind = SurfaceAst.Wildcard
      let pat: SurfaceAst.Pattern = { node, kind, attach }
      (pat, state2)
    },
    Lexer.LitName(name) => {
      let state1 = dropToken(state)
      let (patId, state2) = freshId(state1)
      let (nameId, state3) = freshId(state2)
      let node = { id: patId, span: tok.span }
      let attach = { leading: [], trailing: [], dangling: [] }
      let nameNode = { node: { id: nameId, span: tok.span }, text: name }
      let kind: SurfaceAst.PatternKind = if (pinBareIdent) {
        SurfaceAst.Pin(nameNode)
      } else {
        SurfaceAst.Var(nameNode)
      }
      let pat: SurfaceAst.Pattern = { node, kind, attach }
      (pat, state3)
    },
    Lexer.LitNum(value) => {
      let state1 = dropToken(state)
      let (id, state2) = freshId(state1)
      let node = { id, span: tok.span }
      let attach = { leading: [], trailing: [], dangling: [] }
      let lit: SurfaceAst.AtomLiteral = SurfaceAst.Int(value)
      let kind: SurfaceAst.PatternKind = SurfaceAst.Lit(lit)
      let pat: SurfaceAst.Pattern = { node, kind, attach }
      (pat, state2)
    },
    Lexer.LitString(value) => {
      let state1 = dropToken(state)
      let (id, state2) = freshId(state1)
      let node = { id, span: tok.span }
      let attach = { leading: [], trailing: [], dangling: [] }
      let lit: SurfaceAst.AtomLiteral = SurfaceAst.Str(value)
      let kind: SurfaceAst.PatternKind = SurfaceAst.Lit(lit)
      let pat: SurfaceAst.Pattern = { node, kind, attach }
      (pat, state2)
    },
    Lexer.LitChar(value) => {
      let state1 = dropToken(state)
      let (id, state2) = freshId(state1)
      let node = { id, span: tok.span }
      let attach = { leading: [], trailing: [], dangling: [] }
      let lit: SurfaceAst.AtomLiteral = SurfaceAst.Char(value)
      let kind: SurfaceAst.PatternKind = SurfaceAst.Lit(lit)
      let pat: SurfaceAst.Pattern = { node, kind, attach }
      (pat, state2)
    },
    Lexer.LitBool(value) => {
      let state1 = dropToken(state)
      let (id, state2) = freshId(state1)
      let node = { id, span: tok.span }
      let attach = { leading: [], trailing: [], dangling: [] }
      let lit: SurfaceAst.AtomLiteral = SurfaceAst.Bool(value)
      let kind: SurfaceAst.PatternKind = SurfaceAst.Lit(lit)
      let pat: SurfaceAst.Pattern = { node, kind, attach }
      (pat, state2)
    },
    Lexer.ConstructorTok(name) => {
      if (name == "Var") {
        // Var(name) for binding
        let (_, state1) = expectSimple(Lexer.LParen, dropToken(state))
        let (nameStr, nameTok, state2) = expectName(state1)
        let (_, state3) = expectSimpleOrRecover(
          Lexer.RParen,
          state2,
          "to close Var(...) pattern"
        )
        let (patId, state4) = freshId(state3)
        let (nameId, state5) = freshId(state4)
        let node = { id: patId, span: tok.span }
        let attach = { leading: [], trailing: [], dangling: [] }
        let nameNode = {
          node: { id: nameId, span: nameTok.span },
          text: nameStr,
        }
        let kind: SurfaceAst.PatternKind = SurfaceAst.Var(nameNode)
        let pat: SurfaceAst.Pattern = { node, kind, attach }
        (pat, state5)
      } else if (kindIs(currentToken(dropToken(state)).kind, Lexer.LParen)) {
        let state1 = dropToken(state)
        let (_, state2) = expectSimple(Lexer.LParen, state1)
        let mut args = []
        let mut currentState = state2
        if (!kindIs(currentToken(currentState).kind, Lexer.RParen)) {
          let (arg, state_temp) = parsePatternWithPinMode(currentState, false)
          args = [arg, ...args]
          currentState = state_temp
          while (kindIs(currentToken(currentState).kind, Lexer.Comma)) {
            let before = currentState
            let (_, state_temp2) = expectSimple(Lexer.Comma, currentState)
            let (nextArg, state_temp3) = parsePatternWithPinMode(
              state_temp2,
              false
            )
            args = [nextArg, ...args]
            currentState = state_temp3
            currentState = ensureProgress(
              before,
              currentState,
              "constructor pattern args"
            )
          }
        }
        let (_, state3) = expectSimpleOrRecover(
          Lexer.RParen,
          currentState,
          "to close constructor pattern arguments"
        )
        let (patId, state4) = freshId(state3)
        let (nameId, state5) = freshId(state4)
        let node = { id: patId, span: tok.span }
        let attach = { leading: [], trailing: [], dangling: [] }
        let nameNode = { node: { id: nameId, span: tok.span }, text: name }
        let kind: SurfaceAst.PatternKind = SurfaceAst.Constructor(
          nameNode,
          List.reverse(args),
        )
        let pat: SurfaceAst.Pattern = { node, kind, attach }
        (pat, state5)
      } else {
        let (patId, state1) = freshId(dropToken(state))
        let (nameId, state2) = freshId(state1)
        let node = { id: patId, span: tok.span }
        let attach = { leading: [], trailing: [], dangling: [] }
        let nameNode = { node: { id: nameId, span: tok.span }, text: name }
        let kind: SurfaceAst.PatternKind = SurfaceAst.Constructor(nameNode, [])
        let pat: SurfaceAst.Pattern = { node, kind, attach }
        (pat, state2)
      }
    },
    Lexer.LParen => {
      let (_, state1) = expectSimple(Lexer.LParen, state)
      let (innerPat, state2) = parsePatternWithPinMode(state1, pinBareIdent)
      if (kindIs(currentToken(state2).kind, Lexer.Comma)) {
        let mut pats = [innerPat]
        let mut currentState = state2
        while (kindIs(currentToken(currentState).kind, Lexer.Comma)) {
          let before = currentState
          let (_, state_temp) = expectSimple(Lexer.Comma, currentState)
          let (nextPat, state_next) = parsePatternWithPinMode(
            state_temp,
            pinBareIdent
          )
          pats = [nextPat, ...pats]
          currentState = state_next
          currentState = ensureProgress(before, currentState, "tuple pattern")
        }
        let (_, state3) = expectSimpleOrRecover(
          Lexer.RParen,
          currentState,
          "to close tuple pattern"
        )
        let (id, state4) = freshId(state3)
        let node = { id, span: Source.makeSpan(0, 0, 0, 0) } // fix span
        let attach = { leading: [], trailing: [], dangling: [] }
        let kind: SurfaceAst.PatternKind = SurfaceAst.Tuple(List.reverse(pats))
        let pat: SurfaceAst.Pattern = { node, kind, attach }
        (pat, state4)
      } else {
        let (_, state3) = expectSimpleOrRecover(
          Lexer.RParen,
          state2,
          "to close parenthesized pattern"
        )
        (innerPat, state3)
      }
    },
    _ => {
      let (id, state1) = freshId(state)
      let span = tok.span
      let pat: SurfaceAst.Pattern = {
        node: { id, span },
        kind: SurfaceAst.Wildcard,
        attach: { leading: [], trailing: [], dangling: [] },
      }
      let (markId, state2) = freshId(state1)
      let mark: SurfaceAst.Mark = {
        node: { id: markId, span },
        kind: SurfaceAst.MissingPattern(""),
        expected: SurfaceAst.ExpectPattern,
      }
      let recoveryPat = Error.createMarkedError(
        Error.Parsing,
        mark,
        "Expected pattern",
        pat,
        clues=[Error.Received(Lexer.tokenKindToString(tok.kind))],
        severity=Error.SError
      )
      (recoveryPat, state2)
    },
  }
  let (trailingTrivia, state1) = takeTrailingGapTriviaOnLine(
    corePattern.node.span.line,
    coreState,
    []
  )
  (withPatternAttachments(corePattern, leadingTrivia, trailingTrivia), state1)
}
and parsePattern: Parser<SurfaceAst.Pattern> = state =>
  parsePatternWithPinMode(state, false)
and parseMatchPattern: Parser<SurfaceAst.Pattern> = state =>
  parsePatternWithPinMode(state, true)
and parseTypeExpr: Parser<SurfaceAst.TypeExpr> = state => {
  let (left, state1) = parseTypeAtom(state)
  if (kindIs(currentToken(state1).kind, Lexer.FatArrow)) {
    let (_, state2) = expectSimple(Lexer.FatArrow, state1)
    let (rhs, state3) = parseTypeExpr(state2)
    let params = match (left.kind) {
      SurfaceAst.Tuple(items) => items,
      _ => [left],
    }
    let span = spanFromTokens(left.node.span, rhs.node.span)
    let (id, state4) = freshId(state3)
    let expr = makeTypeExpr(id, span, SurfaceAst.Arrow(params, rhs))
    (expr, state4)
  } else {
    (left, state1)
  }
}
and parseTypeAtom: Parser<SurfaceAst.TypeExpr> = state => {
  let parseTypeArguments = (stateX: ParseState) => {
    if (!kindIs(currentToken(stateX).kind, Lexer.LAngle)) {
      ([], stateX)
    } else {
      let (_, state1) = expectSimple(Lexer.LAngle, stateX)
      let rec parseItems = (items, stateY) => {
        let tokArg = currentToken(stateY)
        if (kindIs(tokArg.kind, Lexer.Arrow)) {
          (List.reverse(items), stateY)
        } else if (kindIs(tokArg.kind, Lexer.EOF)) {
          (List.reverse(items), stateY)
        } else {
          let before = stateY
          let (arg, state2) = parseTypeExpr(stateY)
          let state3 = if (kindIs(currentToken(state2).kind, Lexer.Comma)) {
            let (_, stateComma) = expectSimple(Lexer.Comma, state2)
            stateComma
          } else {
            state2
          }
          let nextState = ensureProgress(before, state3, "type argument list")
          parseItems([arg, ...items], nextState)
        }
      }
      let (args, state2) = parseItems([], state1)
      let (_, state3) = expectSimpleOrRecover(
        Lexer.Arrow,
        state2,
        "to close type argument list"
      )
      (args, state3)
    }
  }
  let tok = currentToken(state)
  match (tok.kind) {
    Lexer.Question => {
      let state1 = dropToken(state)
      let (id, state2) = freshId(state1)
      let hole: SurfaceAst.Hole = {
        node: { id, span: tok.span },
        kind: SurfaceAst.TypeHole,
        origin: SurfaceAst.UserTyped,
      }
      let expr = makeTypeExpr(id, tok.span, SurfaceAst.Hole(hole))
      (expr, state2)
    },
    Lexer.ConstructorTok(name) => {
      let state1 = dropToken(state)
      let (exprId, state2) = freshId(state1)
      let (nameId, state3) = freshId(state2)
      let (args, state4) = parseTypeArguments(state3)
      let nameNode: SurfaceAst.Name = {
        node: { id: nameId, span: tok.span },
        text: name,
      }
      let kind = if (name == "Void" && List.length(args) == 0) {
        SurfaceAst.UnitType
      } else {
        SurfaceAst.Ref(nameNode, args)
      }
      let expr = makeTypeExpr(exprId, tok.span, kind)
      (expr, state4)
    },
    Lexer.LitName(name) => {
      let state1 = dropToken(state)
      let (exprId, state2) = freshId(state1)
      let (nameId, state3) = freshId(state2)
      let nameNode: SurfaceAst.Name = {
        node: { id: nameId, span: tok.span },
        text: name,
      }
      let kind = if (name == "Void") {
        SurfaceAst.UnitType
      } else {
        SurfaceAst.Var(nameNode)
      }
      let expr = makeTypeExpr(exprId, tok.span, kind)
      (expr, state3)
    },
    Lexer.LParen => {
      let (lparenTok, state1) = expectSimple(Lexer.LParen, state)
      if (kindIs(currentToken(state1).kind, Lexer.RParen)) {
        let (_, state2) = expectSimple(Lexer.RParen, state1)
        let (id, state3) = freshId(state2)
        let expr = makeTypeExpr(
          id,
          spanFromTokens(lparenTok.span, lparenTok.span),
          SurfaceAst.UnitType
        )
        (expr, state3)
      } else {
        let (first, state2) = parseTypeExpr(state1)
        let rec parseRest = (items, stateX) => {
          if (kindIs(currentToken(stateX).kind, Lexer.Comma)) {
            let (_, stateNext) = expectSimple(Lexer.Comma, stateX)
            let (nextTy, stateAfter) = parseTypeExpr(stateNext)
            parseRest([nextTy, ...items], stateAfter)
          } else {
            (List.reverse(items), stateX)
          }
        }
        let (items, state3) = parseRest([first], state2)
        let (rparenTok, state4) = expectSimpleOrRecover(
          Lexer.RParen,
          state3,
          "to close type tuple"
        )
        let span = spanFromTokens(lparenTok.span, rparenTok.span)
        let (id, state5) = freshId(state4)
        let expr = match (items) {
          [only] => only,
          _ => makeTypeExpr(id, span, SurfaceAst.Tuple(items)),
        }
        (expr, state5)
      }
    },
    Lexer.LBrace => {
      let (lbraceTok, state1) = expectSimple(Lexer.LBrace, state)
      let rec parseFields = (fields, stateX) => {
        let tokField = currentToken(stateX)
        if (kindIs(tokField.kind, Lexer.RBrace)) {
          (List.reverse(fields), stateX)
        } else if (kindIs(tokField.kind, Lexer.EOF)) {
          (List.reverse(fields), stateX)
        } else {
          let before = stateX
          let (nameText, nameTok, state2) = expectName(stateX)
          let (nameId, state2b) = freshId(state2)
          let name: SurfaceAst.Name = {
            node: { id: nameId, span: nameTok.span },
            text: nameText,
          }
          let (_, state3) = expectSimple(Lexer.Colon, state2b)
          let (ty, state4) = parseTypeExpr(state3)
          let nextFields = [(name, ty), ...fields]
          let state5 = if (kindIs(currentToken(state4).kind, Lexer.Comma)) {
            let (_, stateComma) = expectSimple(Lexer.Comma, state4)
            stateComma
          } else {
            state4
          }
          let nextState = ensureProgress(before, state5, "record type fields")
          parseFields(nextFields, nextState)
        }
      }
      let (fields, state2) = parseFields([], state1)
      let (rbraceTok, state3) = expectSimpleOrRecover(
        Lexer.RBrace,
        state2,
        "to close record type"
      )
      let span = spanFromTokens(lbraceTok.span, rbraceTok.span)
      let (id, state4) = freshId(state3)
      let expr = makeTypeExpr(id, span, SurfaceAst.Record(fields))
      (expr, state4)
    },
    _ => {
      let (id, state1) = freshId(state)
      let hole: SurfaceAst.Hole = {
        node: { id, span: tok.span },
        kind: SurfaceAst.TypeHole,
        origin: SurfaceAst.Inferred,
      }
      let expr = makeTypeExpr(id, tok.span, SurfaceAst.Hole(hole))
      let (markId, state2) = freshId(state1)
      let mark: SurfaceAst.Mark = {
        node: { id: markId, span: tok.span },
        kind: SurfaceAst.MissingTypeExpr(""),
        expected: SurfaceAst.ExpectTypeExpr,
      }
      let recoveryExpr = Error.createMarkedError(
        Error.Parsing,
        mark,
        "Expected type expression",
        expr,
        clues=[
          Error.Expected("type expression"),
          Error.Received(Lexer.tokenKindToString(tok.kind)),
        ],
        severity=Error.SError
      )
      (recoveryExpr, state2)
    },
  }
}
and parseMatch = (state: ParseState) => {
  let (id, state1) = freshId(state)
  let (matchTok, state2) = expectKeyword("match", state)
  let rec exprToParamPattern = (expr: SurfaceAst.Expr) => {
    match (expr.kind) {
      Ident({ text, _ }) when text == "_" =>
        Some(
          { node: expr.node, kind: SurfaceAst.Wildcard, attach: expr.attach }:
            SurfaceAst.Pattern,
        ),
      Ident(name) =>
        Some(
          { node: expr.node, kind: SurfaceAst.Var(name), attach: expr.attach }:
            SurfaceAst.Pattern,
        ),
      Paren(inner) => exprToParamPattern(inner),
      Tuple(items) => {
        let rec convertAll = (es: List<SurfaceAst.Expr>) => {
          match (es) {
            [] => Some([]),
            [head, ...tail] => match (exprToParamPattern(head)) {
              Some(hPat) => match (convertAll(tail)) {
                Some(restPats) => Some([hPat, ...restPats]),
                None => None,
              },
              None => None,
            },
          }
        }
        match (convertAll(items)) {
          Some(pats) =>
            Some(
              {
                node: expr.node,
                kind: SurfaceAst.Tuple(pats),
                attach: expr.attach,
              }: SurfaceAst.Pattern,
            ),
          None => None,
        }
      },
      _ => None,
    }
  }
  let parseFnItemsInBraces = (stateX: ParseState) => {
    let (_, state4) = expectSimple(Lexer.LBrace, stateX)
    let mut items: List<SurfaceAst.FnItem> = []
    let mut currentState = state4
    while (
      !kindIs(currentToken(currentState).kind, Lexer.RBrace)
      && !kindIs(currentToken(currentState).kind, Lexer.EOF)
    ) {
      let before = currentState
      let tok = currentToken(currentState)
      let nextTok = currentToken(dropToken(currentState))
      let includeName = match (tok.kind) {
        Lexer.LitName(name) when kindIs(nextTok.kind, Lexer.Comma)
          || kindIs(nextTok.kind, Lexer.RBrace) => Some(name),
        _ => None,
      }
      let (nextState, item) = match (tok.kind) {
        Lexer.LineComment(comment) => {
          let state_temp = dropToken(currentState)
          let (itemId, state_temp2) = freshId(state_temp)
          let trivia = makeLineTrivia(itemId, tok.span, comment)
          let triviaItem: SurfaceAst.FnItem = {
            node: { id: itemId, span: tok.span },
            kind: SurfaceAst.Trivia(trivia),
            attach: { leading: [], trailing: [], dangling: [] },
          }
          (state_temp2, triviaItem)
        },
        _ => match (includeName) {
          Some(name) => {
            let state_temp = dropToken(currentState)
            let (nameId, state_temp1) = freshId(state_temp)
            let (itemId, state_temp2) = freshId(state_temp1)
            let includeRef: SurfaceAst.Name = {
              node: { id: nameId, span: tok.span },
              text: name,
            }
            let includeItem: SurfaceAst.FnItem = {
              node: { id: itemId, span: tok.span },
              kind: SurfaceAst.Include(includeRef),
              attach: { leading: [], trailing: [], dangling: [] },
            }
            (state_temp2, includeItem)
          },
          None => {
            let (pat, state_temp) = parseMatchPattern(currentState)
            let (guardOpt, state_temp1) = if (
              kindIs(currentToken(state_temp).kind, Lexer.LitName("when"))
            ) {
              let (_, state_temp0) = expectKeyword("when", state_temp)
              // Parse guard without consuming the clause arrow token.
              let (guard, state_temp00) = parseInfix(state_temp0)
              (Some(guard), state_temp00)
            } else {
              (None, state_temp)
            }
            let (_, state_temp2) = expectSimple(Lexer.FatArrow, state_temp1)
            let (blockExpr, state_temp3) = parseBlock(state_temp2)
            let (body, state_temp4) = match (blockExpr.kind) {
              Block(b) => (b, state_temp3),
              _ => {
                let (markId, state_temp4) = freshId(state_temp3)
                let mark: SurfaceAst.Mark = {
                  node: { id: markId, span: blockExpr.node.span },
                  kind: SurfaceAst.MissingBlock("after =>"),
                  expected: SurfaceAst.ExpectBlock,
                }
                let recoveryBlock = Error.createMarkedError(
                  Error.Parsing,
                  mark,
                  "Expected block after =>",
                  {
                    node: blockExpr.node,
                    items: [SurfaceAst.ExprItem(blockExpr)],
                    body: blockExpr,
                  },
                  clues=[Error.Received("non-block expression")],
                  severity=Error.SError
                )
                (recoveryBlock, state_temp4)
              },
            }
            let (clauseId, state_temp5) = freshId(state_temp4)
            let span = spanFromTokens(pat.node.span, body.node.span)
            let clause: SurfaceAst.FnClause = {
              node: { id: clauseId, span },
              param: pat,
              guard: guardOpt,
              body,
              attach: { leading: [], trailing: [], dangling: [] },
            }
            let (itemId, state_temp6) = freshId(state_temp5)
            let clauseItem: SurfaceAst.FnItem = {
              node: { id: itemId, span },
              kind: SurfaceAst.Clause(clause),
              attach: { leading: [], trailing: [], dangling: [] },
            }
            (state_temp6, clauseItem)
          },
        },
      }
      items = [item, ...items]
      if (kindIs(currentToken(nextState).kind, Lexer.Comma)) {
        let (_, state_temp6) = expectSimple(Lexer.Comma, nextState)
        currentState = state_temp6
      } else {
        currentState = nextState
      }
      currentState = ensureProgress(before, currentState, "match bundle items")
    }
    let (rbraceTok, state5) = expectSimpleOrRecover(
      Lexer.RBrace,
      currentState,
      "to close match bundle"
    )
    (List.reverse(items), rbraceTok, state5)
  }

  let mkMatchExpr = (
    exprId: Number,
    endSpan: Source.Span,
    scrutineeOpt: Option<SurfaceAst.Expr>,
    fnItems: List<SurfaceAst.FnItem>,
    arrowSugar: Bool,
    stateX: ParseState,
  ) => {
    let (fnExprId, stateY) = freshId(stateX)
    let fnExpr: SurfaceAst.FnExpr = {
      node: { id: fnExprId, span: endSpan },
      items: fnItems,
      attach: { leading: [], trailing: [], dangling: [] },
    }
    let matchExpr: SurfaceAst.MatchExpr = {
      node: { id: exprId, span: endSpan },
      scrutinee: scrutineeOpt,
      bundle: fnExpr,
      arrowSugar,
      attach: { leading: [], trailing: [], dangling: [] },
    }
    let expr = makeExpr(exprId, endSpan, Match(matchExpr))
    (expr, stateY)
  }

  if (kindIs(currentToken(state2).kind, Lexer.LBrace)) {
    let (fnItems, rbraceTok, state5) = parseFnItemsInBraces(state2)
    let span = spanFromTokens(matchTok.span, rbraceTok.span)
    mkMatchExpr(id, span, None, fnItems, false, state5)
  } else {
    let (scrutinee, state3) = parseInfix(state2)
    if (kindIs(currentToken(state3).kind, Lexer.LBrace)) {
      let (fnItems, rbraceTok, state5) = parseFnItemsInBraces(state3)
      let span = spanFromTokens(matchTok.span, rbraceTok.span)
      mkMatchExpr(id, span, Some(scrutinee), fnItems, false, state5)
    } else if (kindIs(currentToken(state3).kind, Lexer.FatArrow)) {
      let (_, state4) = expectSimple(Lexer.FatArrow, state3)
      if (kindIs(currentToken(state4).kind, Lexer.LBrace)) {
        let _ = match (exprToParamPattern(scrutinee)) {
          Some(_) => void,
          None => {
            let (markId, state_temp) = freshId(state4)
            let mark: SurfaceAst.Mark = {
              node: { id: markId, span: scrutinee.node.span },
              kind: SurfaceAst.UnexpectedToken("unsupported expression"),
              expected: SurfaceAst.ExpectPattern,
            }
            Error.createMarkedError(
              Error.Parsing,
              mark,
              "Unsupported first-class match parameter",
              void,
              clues=[
                Error.Note(
                  "match(param) => currently supports identifier or tuple of identifiers",
                ),
              ],
              severity=Error.SError
            )
          },
        }
        let (fnItems, rbraceTok, state5) = parseFnItemsInBraces(state4)
        let span = spanFromTokens(matchTok.span, rbraceTok.span)
        mkMatchExpr(id, span, Some(scrutinee), fnItems, true, state5)
      } else {
        let syntheticSpan = Source.makeSpan(
          currentToken(state4).span.line,
          currentToken(state4).span.col,
          currentToken(state4).span.start,
          currentToken(state4).span.start
        )
        let syntheticRbrace: Lexer.Token = {
          kind: Lexer.RBrace,
          span: syntheticSpan,
          mate: None,
        }
        let (markId, state5) = freshId(state4)
        let mark: SurfaceAst.Mark = {
          node: { id: markId, span: currentToken(state4).span },
          kind: SurfaceAst.MissingBlock("match arrow form"),
          expected: SurfaceAst.ExpectBlock,
        }
        let recoveryItems = Error.createMarkedError(
          Error.Parsing,
          mark,
          "Expected { ... } after match(...) =>",
          [],
          clues=[Error.Note("match arrow form requires a clause block")],
          severity=Error.SError
        )
        let span = spanFromTokens(matchTok.span, syntheticRbrace.span)
        mkMatchExpr(id, span, Some(scrutinee), recoveryItems, true, state5)
      }
    } else {
      let (markId, stateX) = freshId(state3)
      let mark: SurfaceAst.Mark = {
        node: { id: markId, span: currentToken(state3).span },
        kind: SurfaceAst.MissingBlock("match body"),
        expected: SurfaceAst.ExpectBlock,
      }
      let recoveryExpr = Error.createMarkedError(
        Error.Parsing,
        mark,
        "Expected match body",
        makeExpr(
          id,
          matchTok.span,
          Hole(
            {
              node: { id, span: matchTok.span },
              kind: ExprHole,
              origin: Inferred,
            },
          )
        ),
        clues=[
          Error.Note(
            "use match { ... }, match(expr) { ... }, or match(expr) => { ... }",
          ),
        ],
        severity=Error.SError
      )
      (recoveryExpr, stateX)
    }
  }
}

let parseWithRecovery = (source: String) => {
  let tokens = Lexer.lex(source)
  let initial: ParseState = { tokens, nextId: 1, allTokens: tokens }
  let (topLevels, _finalState) = parseTopLevels(initial)
  let hasCoreDirective = List.some(
    (item: SurfaceAst.TopItem) => match (item) {
      SurfaceAst.Directive({ name, _ }) => name.text == "core",
      _ => false,
    },
    topLevels
  )
  let program: SurfaceAst.Program = { items: topLevels, core: hasCoreDirective }
  { program, tokens }
}

provide let parseResult = (source: String) => parseWithRecovery(source)

provide let parse = (source: String) => parseResult(source).program
