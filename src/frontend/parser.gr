module Parser

from "runtime/unsafe/panic" include Panic
use Panic.{ panic }
from "list" include List
from "string" include String

from "../core/ast.gr" include Ast
use Ast.*
from "./lexer.gr" include Lexer
from "../core/source.gr" include Source

from "../util.gr" include Util
use Util.{ testStr }

record ParseState {
  tokens: List<Lexer.Token>,
  nextId: Number, // token id
  allTokens: List<Lexer.Token>,
}

let makeExpr: (Number, Source.Span, Ast.ExprKind) => Ast.Expr = (id, span, kind) => {
  let node = { id, span }
  let attach = { leading: [], trailing: [], dangling: [] }
  { node, kind, attach }
}

// id +1
let freshId = (state: ParseState) => {
  let id = state.nextId
  (id, { ...state, nextId: id + 1 })
}

// inspect token
let currentToken = (state: ParseState) => match (state.tokens) {
  [head, ..._tail] => head,
  [] => { kind: Lexer.EOF, span: Source.makeSpan(1, 1, 0, 0), mate: None },
}

// drop 1 token from the list
let dropToken = (state: ParseState) => {
  let tok = currentToken(state)
  //print(tok)
  print("Processed token: " ++ Lexer.tokenKindToString(tok.kind))
  match (state.tokens) {
    [_head, ...tail] => { ...state, tokens: tail },
    [] => { ...state, tokens: [] },
  }
}

//return token at an index
let rec tokenAt = (tokens: List<Lexer.Token>, index: Number) => {
  if (index < 0) {
    None
  } else {
    match (tokens) {
      [] => None,
      [head, ...tail] => if (index == 0) {
        Some(head)
      } else {
        tokenAt(tail, index - 1)
      },
    }
  }
}

// check token validity
let kindIs = (kind, expected) => kind == expected

//expect type
let expectSimple = (expected, state: ParseState) => {
  let tok = currentToken(state)
  if (kindIs(tok.kind, expected)) {
    (tok, dropToken(state))
  } else {
    print("expected: " ++ Lexer.tokenKindToString(expected))
    let str = "Parse error: unexpected token "
      ++ Lexer.tokenKindToString(tok.kind)
    Panic.panic(str)
  }
}

//expect name
let expectName = (state: ParseState) => {
  let tok = currentToken(state)
  match (tok.kind) {
    Lexer.LitName(name) => (name, tok, dropToken(state)),
    _ => {
      print(tok.kind)
      Panic.panic(
        "Parse error: expected identifier, tok: "
          ++ Lexer.tokenKindToString(tok.kind)
      )
    },
  }
}

//expect name
let expectConstructor = (state: ParseState) => {
  let tok = currentToken(state)
  match (tok.kind) {
    Lexer.ConstructorTok(name) => (name, tok, dropToken(state)),
    _ => {
      print(tok.kind)
      Panic.panic(
        "Parse error: expected identifier, tok: "
          ++ Lexer.tokenKindToString(tok.kind)
      )
    },
  }
}

//expect keyword tokenized as a name
let expectKeyword = (keyword: String, state: ParseState) => {
  let tok = currentToken(state)
  match (tok.kind) {
    Lexer.LitName(name) when name == keyword => (tok, dropToken(state)),
    _ => {
      print(tok.kind)
      Panic.panic("Parse error: expected keyword")
    },
  }
}

//fetch the mate of a token that has one
let fetchMate = (state: ParseState, tok: Lexer.Token) => {
  match (tok.mate) {
    Some(mateIndex) => {
      let rec find = (ts: List<Lexer.Token>) => match (ts) {
        [] => panic("Mate not found"),
        [h, ...t] => if (h.span.start == mateIndex) {
          h
        } else {
          find(t)
        },
      }
      find(state.allTokens)
    },
    None => panic("No mate"),
  }
}

//create a span from the end token
let spanFromTokens = (startSpan: Source.Span, endSpan: Source.Span) =>
  Source.makeSpan(startSpan.line, startSpan.col, startSpan.start, endSpan.end)

let spanFromEnd = (state: ParseState, endTok: Lexer.Token) => {
  let startTok = fetchMate(state, endTok)
  spanFromTokens(startTok.span, endTok.span)
}

//parse
let rec parseExpr = (state: ParseState) => {
  let (expr: Ast.Expr, state1) = parseTerm(state)
  match (currentToken(state1).kind) {
    Lexer.FatArrow => {
      let (id, stateAfterId) = freshId(state1)
      let (_, state2) = expectSimple(Lexer.FatArrow, stateAfterId)
      let (rhs, state3): (Ast.Expr, ParseState) = parseExpr(state2)
      let span = spanFromTokens(expr.node.span, rhs.node.span)
      let node: Ast.Expr = makeExpr(
        id,
        span,
        InfixChain(
          { first: expr, rest: [({ node: { id, span }, text: "=>" }, rhs)] },
        )
      )
      (node, state3)
    },
    _ => (expr, state1),
  }
}
and parseTerm = (state: ParseState) => {
  let tok = currentToken(state)
  match (tok.kind) {
    Lexer.LBrace => parseBlock(state),
    _ => parsePrimary(state),
  }
}
//must support inner code
and parseBlock = (state: ParseState) => {
  let (id, state1) = freshId(state)
  let (_, state2) = expectSimple(Lexer.LBrace, state1)
  let (inner, state3): (Ast.Expr, ParseState) = parseExpr(state2)
  let (rbraceTok, state4): (Lexer.Token, ParseState) = expectSimple(
    Lexer.RBrace,
    state3
  )
  let span = spanFromEnd(state4, rbraceTok)
  let expr: Ast.Expr = makeExpr(
    id,
    span,
    Block({ node: { id, span }, items: [], result: Some(inner) })
  )
  (expr, state4)
}
and parsePrimary = (state: ParseState) => {
  let (id, state1) = freshId(state)
  let tok = currentToken(state1)

  match (tok.kind) {
    Lexer.LitNum(value) => {
      let state2 = dropToken(state1)
      let expr: Ast.Expr = makeExpr(id, tok.span, Lit(Ast.Int(value)))
      (expr, state2)
    },
    Lexer.LitString(value) => {
      let state2 = dropToken(state1)
      let expr: Ast.Expr = makeExpr(id, tok.span, Lit(Ast.Str(value)))
      (expr, state2)
    },
    Lexer.LitChar(value) => {
      let state2 = dropToken(state1)
      let expr: Ast.Expr = makeExpr(id, tok.span, Lit(Ast.Char(value)))
      (expr, state2)
    },
    Lexer.LitName(name) => {
      let state2 = dropToken(state1)
      let expr: Ast.Expr = makeExpr(
        id,
        tok.span,
        Ident({ node: { id, span: tok.span }, text: name })
      )
      (expr, state2)
    },
    Lexer.LParen => {
      let (_, state2) = expectSimple(Lexer.LParen, state1)
      if (kindIs(currentToken(state2).kind, Lexer.RParen)) {
        let (rparenTok, state3) = expectSimple(Lexer.RParen, state2)
        let span = spanFromTokens(tok.span, rparenTok.span)
        let expr: Ast.Expr = makeExpr(id, span, Lit(Ast.Unit))
        (expr, state3)
      } else {
        let (inner, state3) = parseExpr(state2)
        if (kindIs(currentToken(state3).kind, Lexer.Comma)) {
          let mut exprs = [inner]
          let mut currentState = state3
          while (kindIs(currentToken(currentState).kind, Lexer.Comma)) {
            let (_, state_temp) = expectSimple(Lexer.Comma, currentState)
            let (nextExpr, state_next) = parseExpr(state_temp)
            exprs = [nextExpr, ...exprs]
            currentState = state_next
          }
          let (rparenTok, state4) = expectSimple(Lexer.RParen, currentState)
          let span = spanFromTokens(tok.span, rparenTok.span)
          let expr: Ast.Expr = makeExpr(id, span, Tuple(List.reverse(exprs)))
          (expr, state4)
        } else {
          let (rparenTok, state4) = expectSimple(Lexer.RParen, state3)
          let span = spanFromTokens(tok.span, rparenTok.span)
          let expr: Ast.Expr = makeExpr(id, span, Paren(inner))
          (expr, state4)
        }
      }
    },
    Lexer.Question => {
      let state2 = dropToken(state1)
      let expr: Ast.Expr = makeExpr(
        id,
        tok.span,
        Hole(
          { node: { id, span: tok.span }, kind: ExprHole, origin: UserTyped },
        )
      )
      (expr, state2)
    },
    Lexer.DotBrace => {
      let (_, state2) = expectSimple(Lexer.DotBrace, state1)
      let mut fields = []
      let mut currentState = state2
      while (!kindIs(currentToken(currentState).kind, Lexer.RBrace)) {
        if (kindIs(currentToken(currentState).kind, Lexer.Comma)) {
          // Skip leading/trailing commas
          let (_, state_temp) = expectSimple(Lexer.Comma, currentState)
          currentState = state_temp
        } else {
          let (fieldName, nameTok, state_temp) = expectName(currentState)
          let (_, state_temp2) = expectSimple(Lexer.Eq, state_temp)
          let (fieldExpr, state_temp3) = parseExpr(state_temp2)
          fields = [(fieldName, nameTok, fieldExpr), ...fields]
          currentState = state_temp3
          if (kindIs(currentToken(currentState).kind, Lexer.Comma)) {
            let (_, state_temp4) = expectSimple(Lexer.Comma, currentState)
            currentState = state_temp4
          }
        }
      }
      let (rbraceTok, state3) = expectSimple(Lexer.RBrace, currentState)
      let span = spanFromTokens(tok.span, rbraceTok.span)
      let reversedFields = List.reverse(fields)
      let rec buildFieldItems: (List<(String, Lexer.Token, Ast.Expr)>, Number) => List<
        Ast.RecordItem
      > = (items, currentId) => match (items) {
        [] => [],
        [(name, tok, expr), ...rest] => {
          let field = Field(
            { node: { id: currentId, span: tok.span }, text: name },
            expr,
          )
          [field, ...buildFieldItems(rest, currentId + 1)]
        },
      }
      let fieldItems = buildFieldItems(reversedFields, id + 1)
      let expr: Ast.Expr = makeExpr(id, span, RecordLit(fieldItems))
      (expr, state3)
    },
    _ => Panic.panic("Parse error: expected expression"),
  }
}

let rec parseTopLevels = (state: ParseState) => {
  let tok = currentToken(state)
  //print(tok)
  match (tok.kind) {
    Lexer.EOF => ([], state),
    Lexer.SemiColon => {
      // Skip semicolons
      let state1 = dropToken(state)
      parseTopLevels(state1)
    },
    Lexer.LitName(name) when name == "let" => {
      let (binding, state1): (Ast.LetBinding, ParseState) = parseBinding(state)
      let (id, state2) = freshId(state1)
      let topLevel: Ast.TopItem = DeclGroup(
        {
          node: { id, span: binding.node.span },
          exported: false,
          kind: LetGroup(Rec),
          decls: [
            LetDecl(
              { node: { id, span: binding.node.span }, bindings: [binding] },
            ),
          ],
        },
      )
      let (rest, state3) = parseTopLevels(state2)
      ([topLevel, ...rest], state3)
    },
    Lexer.LitName(name) when name == "export" => {
      let state1 = dropToken(state)
      let (inner, state2) = parseTopLevels(state1)
      match (inner) {
        [DeclGroup(dg), ...rest] => {
          let exportedDg = { ...dg, exported: true }
          ([DeclGroup(exportedDg), ...rest], state2)
        },
        [] => panic("Expected something after export"),
        [first, ...rest] => panic("Export can only be applied to declarations"),
      }
    },
    Lexer.LitName(name) when name == "type" => {
      let (typeDef, state1) = parseTypeDef(state)
      let (rest, state2) = parseTopLevels(state1)
      ([typeDef, ...rest], state2)
    },
    Lexer.LitName(name) when name == "record" => {
      let (typeDef, state1) = parseRecordDef(state)
      let (rest, state2) = parseTopLevels(state1)
      ([typeDef, ...rest], state2)
    },
    _ =>
      panic(
        "Unknown top-level construct: " ++ Lexer.tokenKindToString(tok.kind)
      ),
  }
}
and parseBinding = (state: ParseState) => {
  let (id, state1) = freshId(state)
  let (letTok, state2): (Lexer.Token, ParseState) = expectKeyword("let", state1)
  let (name, litName, state3) = expectName(state2)
  //Optionally parse type annotation after ':'
  let (typeOpt, state4) = if (kindIs(currentToken(state3).kind, Lexer.Colon)) {
    let (_, state_temp) = expectSimple(Lexer.Colon, state3)
    // Parse type tokens until '=' (approximate, like TypeDef)
    let rec parseType = (accumulator, state) => {
      let tok = currentToken(state)
      if (kindIs(tok.kind, Lexer.Eq)) {
        (Some(accumulator), state)
      } else {
        parseType(accumulator ++ " " ++ toString(tok.kind), dropToken(state))
      }
    }
    parseType("", state_temp)
  } else {
    (None, state3)
  }
  let (_, state5) = expectSimple(Lexer.Eq, state4)
  let (value, state6): (Ast.Expr, ParseState) = parseExpr(state5)
  let span = spanFromTokens(letTok.span, value.node.span)
  let binding: Ast.LetBinding = {
    node: { id, span },
    name: {
      node: { id, span: litName.span },
      kind: Var({ node: { id, span: litName.span }, text: name }),
      attach: { leading: [], trailing: [], dangling: [] },
    },
    annotation: None,
    value,
  }
  (binding, state6)
}
and parseTypeDef: ParseState => (Ast.TopItem, ParseState) = state => {
  let (id, state1) = freshId(state)
  let (typeTok, state2) = expectKeyword("type", state1)
  let (name, _, state3) = expectConstructor(state2)
  let (_, state4) = expectSimple(Lexer.Eq, state3)
  // Simple: parse until ;
  let rec parseDef = (accumulator, state) => {
    let tok = currentToken(state)
    match (tok.kind) {
      Lexer.SemiColon => (accumulator, dropToken(state)),
      Lexer.EOF => (accumulator, state),
      _ => parseDef(accumulator ++ " " ++ toString(tok.kind), dropToken(state)), // approximate
    }
  }
  let (def, state5) = parseDef("", state4)
  let topLevel = DeclGroup(
    {
      node: { id, span: typeTok.span },
      exported: false,
      kind: TypeGroup(Rec),
      decls: [
        TypeDecl(
          {
            node: { id, span: typeTok.span },
            name: { node: { id, span: typeTok.span }, text: name },
            infection: None,
            typeParams: [],
            body: Alias(
              {
                node: { id, span: typeTok.span },
                kind: Hole(
                  {
                    node: { id, span: typeTok.span },
                    kind: TypeHole,
                    origin: UserTyped,
                  },
                ),
                attach: { leading: [], trailing: [], dangling: [] },
              }: TypeExpr,
            ),
          },
        ),
      ],
    },
  )
  (topLevel, state5)
}
and parseRecordDef = (state: ParseState) => {
  let (id, state1) = freshId(state)
  let (recordTok, state2) = expectKeyword("record", state1) // Expect "record" keyword
  let (name, _, state3) = expectConstructor(state2) // Expect the record name (e.g., MyRecord)
  let (_, state4) = expectSimple(Lexer.Eq, state3) // Expect =
  // Simple: parse until ; (same as type for now; customize if record syntax differs)
  let rec parseDef = (accumulator, state) => {
    let tok = currentToken(state)
    match (tok.kind) {
      Lexer.SemiColon => (accumulator, dropToken(state)),
      Lexer.EOF => (accumulator, state),
      _ => parseDef(accumulator ++ " " ++ toString(tok.kind), dropToken(state)), // approximate
    }
  }
  let (def, state5) = parseDef("", state4)
  let topLevel = DeclGroup(
    {
      node: { id, span: recordTok.span },
      exported: false,
      kind: RecordGroup(Rec),
      decls: [
        RecordDecl(
          {
            node: { id, span: recordTok.span },
            name: { node: { id, span: recordTok.span }, text: name },
            typeParams: [],
            fields: [],
          },
        ),
      ],
    },
  )
  (topLevel, state5)
}

provide let parse = (source: String) => {
  let tokens = Lexer.lex(source)
  let initial: ParseState = { tokens, nextId: 1, allTokens: tokens }
  let (topLevels, _finalState) = parseTopLevels(initial)
  let program: Ast.Program = { items: topLevels, core: false }
  program
}

parse(testStr)
