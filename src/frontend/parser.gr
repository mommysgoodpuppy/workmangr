module Parser

from "runtime/unsafe/panic" include Panic
use Panic.{ panic }
from "list" include List
from "string" include String

from "../core/ast.gr" include Ast
use Ast.*
from "./lexer.gr" include Lexer
from "../core/source.gr" include Source
from "../core/error.gr" include Error

from "../util.gr" include Util
use Util.{ testStr }

provide record MissingSemicolonRecovery {
  text: String,
  start: Number,
  end: Number,
  line: Number,
  col: Number,
  reason: String,
}

provide record ParseResult {
  program: Ast.Program,
  missingSemicolons: List<MissingSemicolonRecovery>,
}

record ParseState {
  tokens: List<Lexer.Token>,
  nextId: Number, // token id
  allTokens: List<Lexer.Token>,
  tolerant: Bool,
  missingSemicolons: List<MissingSemicolonRecovery>,
}

type Parser<a> = ParseState => (a, ParseState)

let makeExpr: (Number, Source.Span, Ast.ExprKind) => Ast.Expr = (id, span, kind) => {
  let node = { id, span }
  let attach = { leading: [], trailing: [], dangling: [] }
  { node, kind, attach }
}

let makeLineTrivia = (id: Number, span: Source.Span, text: String) => {
  let node = { id, span }
  {
    node,
    kind: Ast.LineComment(text),
    placement: Ast.Gap,
  }: Ast.Trivia
}

let makeOpaqueTrivia = (id: Number, span: Source.Span, text: String) => {
  let node = { id, span }
  {
    node,
    kind: Ast.Opaque(text),
    placement: Ast.Gap,
  }: Ast.Trivia
}

let withExprAttachments = (
  expr: Ast.Expr,
  leading: List<Ast.Trivia>,
  trailing: List<Ast.Trivia>,
) => {
  let attach = {
    ...expr.attach,
    leading: List.append(leading, expr.attach.leading),
    trailing: List.append(expr.attach.trailing, trailing),
  }
  { ...expr, attach }
}

let withPatternAttachments = (
  pattern: Ast.Pattern,
  leading: List<Ast.Trivia>,
  trailing: List<Ast.Trivia>,
) => {
  let attach = {
    ...pattern.attach,
    leading: List.append(leading, pattern.attach.leading),
    trailing: List.append(pattern.attach.trailing, trailing),
  }
  { ...pattern, attach }
}

let rec takeLeadingGapTrivia = (state: ParseState, acc: List<Ast.Trivia>) => {
  match (state.tokens) {
    [tok, ...tail] =>
      match (tok.kind) {
        Lexer.LineComment(text) => {
          let state1 = { ...state, tokens: tail }
          let id = state1.nextId
          let state2 = { ...state1, nextId: id + 1 }
          let trivia = makeLineTrivia(id, tok.span, text)
          takeLeadingGapTrivia(state2, [trivia, ...acc])
        },
        _ => (List.reverse(acc), state),
      },
    _ => (List.reverse(acc), state),
  }
}

let rec takeTrailingGapTriviaOnLine = (
  line: Number,
  state: ParseState,
  acc: List<Ast.Trivia>,
) => {
  match (state.tokens) {
    [tok, ...tail] =>
      match (tok.kind) {
        Lexer.LineComment(text) when tok.span.line == line => {
          let state1 = { ...state, tokens: tail }
          let id = state1.nextId
          let state2 = { ...state1, nextId: id + 1 }
          let trivia = makeLineTrivia(id, tok.span, text)
          takeTrailingGapTriviaOnLine(line, state2, [trivia, ...acc])
        },
        _ => (List.reverse(acc), state),
      },
    _ => (List.reverse(acc), state),
  }
}

// id +1
let freshId = (state: ParseState) => {
  let id = state.nextId
  (id, { ...state, nextId: id + 1 })
}

// inspect token
let currentToken = (state: ParseState) => match (state.tokens) {
  [head, ..._tail] => head,
  [] => { kind: Lexer.EOF, span: Source.makeSpan(1, 1, 0, 0), mate: None },
}

// drop 1 token from the list
let dropToken = (state: ParseState) => {
  match (state.tokens) {
    [_head, ...tail] => { ...state, tokens: tail },
    [] => { ...state, tokens: [] },
  }
}

//return token at an index
let rec tokenAt = (tokens: List<Lexer.Token>, index: Number) => {
  if (index < 0) {
    None
  } else {
    match (tokens) {
      [] => None,
      [head, ...tail] => if (index == 0) {
        Some(head)
      } else {
        tokenAt(tail, index - 1)
      },
    }
  }
}

// check token validity
let kindIs = (kind, expected) => kind == expected

let isTopLevelBoundary = (tok: Lexer.Token) =>
  match (tok.kind) {
    Lexer.EOF => true,
    Lexer.SemiColon => true,
    Lexer.LineComment(_) => true,
    Lexer.LitName(name) when (
      name == "let" || name == "export" || name == "type" || name == "record"
    ) =>
      true,
    _ => false,
  }

let recoverMissingTopLevelSemicolon = (
  state: ParseState,
  anchorSpan: Source.Span,
) => {
  let atTok = currentToken(state)
  if (state.tolerant) {
    let recovery: MissingSemicolonRecovery = {
      text: ";",
      start: anchorSpan.end,
      end: anchorSpan.end,
      line: atTok.span.line,
      col: atTok.span.col,
      reason: "required top-level terminator",
    }
    let updated = { ...state, missingSemicolons: [recovery, ...state.missingSemicolons] }
    Error.createError(
      Error.Parsing,
      atTok.span,
      "Expected ';' after top-level declaration",
      updated,
      clues=[Error.Expected(";"), Error.Received(Lexer.tokenKindToString(atTok.kind))],
    )
  } else {
    Error.createError(
      Error.Parsing,
      atTok.span,
      "Expected ';' after top-level declaration",
      state,
      clues=[Error.Received(Lexer.tokenKindToString(atTok.kind))],
    )
  }
}

let consumeTopLevelSemicolon = (state: ParseState, anchorSpan: Source.Span) =>
  if (kindIs(currentToken(state).kind, Lexer.SemiColon)) {
    dropToken(state)
  } else if (kindIs(currentToken(state).kind, Lexer.EOF)) {
    state
  } else {
    recoverMissingTopLevelSemicolon(state, anchorSpan)
  }

let topItemSpan = (item: Ast.TopItem) =>
  match (item) {
    Ast.DeclGroup(group) => group.node.span,
    Ast.Import(importDecl) => importDecl.node.span,
    Ast.Reexport(reexportDecl) => reexportDecl.node.span,
    Ast.Export(exportDecl) => exportDecl.node.span,
    Ast.Directive(directive) => directive.name.node.span,
    Ast.Recovery(recovery) => recovery.node.span,
    Ast.Trivia(trivia) => trivia.node.span,
  }

let recoverMissingBlockSemicolon = (state: ParseState, anchorSpan: Source.Span) => {
  let atTok = currentToken(state)
  if (state.tolerant) {
    let recovery: MissingSemicolonRecovery = {
      text: ";",
      start: anchorSpan.end,
      end: anchorSpan.end,
      line: atTok.span.line,
      col: atTok.span.col,
      reason: "required statement terminator",
    }
    let updated = { ...state, missingSemicolons: [recovery, ...state.missingSemicolons] }
    Error.createError(
      Error.Parsing,
      atTok.span,
      "Expected ';' after statement",
      updated,
      clues=[Error.Expected(";"), Error.Received(Lexer.tokenKindToString(atTok.kind))],
    )
  } else {
    Error.createError(
      Error.Parsing,
      atTok.span,
      "Expected ';' after statement",
      state,
      clues=[Error.Received(Lexer.tokenKindToString(atTok.kind))],
    )
  }
}

let consumeBlockSemicolon = (state: ParseState, anchorSpan: Source.Span) =>
  if (kindIs(currentToken(state).kind, Lexer.SemiColon)) {
    dropToken(state)
  } else if (kindIs(currentToken(state).kind, Lexer.EOF) || kindIs(
    currentToken(state).kind,
    Lexer.RBrace,
  )) {
    state
  } else {
    recoverMissingBlockSemicolon(state, anchorSpan)
  }

let startsBlockStatement = (tok: Lexer.Token) =>
  match (tok.kind) {
    Lexer.LitName("let") => true,
    Lexer.Directive => true,
    _ => false,
  }

let isValueBoundary = (tok: Lexer.Token) =>
  match (tok.kind) {
    Lexer.SemiColon => true,
    Lexer.Comma => true,
    Lexer.RBrace => true,
    Lexer.EOF => true,
    Lexer.LineComment(_) => true,
    Lexer.Directive => true,
    Lexer.LitName(name) when (
      name == "let" || name == "and" || name == "type" || name == "record"
      || name == "export"
    ) =>
      true,
    _ => false,
  }

let makeInferredExprHole = (
  state: ParseState,
  anchorSpan: Source.Span,
  message: String,
  clues: List<Error.ErrorClue>,
) => {
  let tok = currentToken(state)
  let (id, state1) = freshId(state)
  let span = Source.makeSpan(tok.span.line, tok.span.col, anchorSpan.end, anchorSpan.end)
  let hole: Ast.Hole = {
    node: { id, span },
    kind: ExprHole,
    origin: Inferred,
  }
  let expr = makeExpr(id, span, Hole(hole))
  let recoveryExpr = Error.createError(
    Error.Parsing,
    tok.span,
    message,
    expr,
    clues=clues,
  )
  (recoveryExpr, state1)
}

//expect type
let expectSimple = (expected, state: ParseState) => {
  let tok = currentToken(state)
  if (kindIs(tok.kind, expected)) {
    (tok, dropToken(state))
  } else {
    Error.createPanicError(
      Error.Parsing,
      tok.span,
      "Unexpected token",
      [
        Error.Expected(Lexer.tokenKindToString(expected)),
        Error.Received(Lexer.tokenKindToString(tok.kind)),
      ]
    )
  }
}

//expect name
let expectName = (state: ParseState) => {
  let tok = currentToken(state)
  match (tok.kind) {
    Lexer.LitName(name) => (name, tok, dropToken(state)),
    _ => {
      Error.createPanicError(
        Error.Parsing,
        tok.span,
        "Expected identifier",
        [Error.Received(Lexer.tokenKindToString(tok.kind))]
      )
    },
  }
}

//expect name
let expectConstructor = (state: ParseState) => {
  let tok = currentToken(state)
  match (tok.kind) {
    Lexer.ConstructorTok(name) => (name, tok, dropToken(state)),
    _ => {
      Error.createPanicError(
        Error.Parsing,
        tok.span,
        "Expected constructor",
        [Error.Received(Lexer.tokenKindToString(tok.kind))]
      )
    },
  }
}

//expect keyword tokenized as a name
let expectKeyword = (keyword: String, state: ParseState) => {
  let tok = currentToken(state)
  match (tok.kind) {
    Lexer.LitName(name) when name == keyword => (tok, dropToken(state)),
    _ => {
      Error.createPanicError(
        Error.Parsing,
        tok.span,
        "Expected keyword",
        [
          Error.Expected(keyword),
          Error.Received(Lexer.tokenKindToString(tok.kind)),
        ]
      )
    },
  }
}

//fetch the mate of a token that has one
let fetchMate = (state: ParseState, tok: Lexer.Token) => {
  match (tok.mate) {
    Some(mateIndex) => {
      let rec find = (ts: List<Lexer.Token>) => match (ts) {
        [] =>
          Error.createPanicError(
            Error.Parsing,
            tok.span,
            "Internal error",
            [Error.Note("matching delimiter not found")]
          ),
        [h, ...t] => if (h.span.start == mateIndex) {
          h
        } else {
          find(t)
        },
      }
      find(state.allTokens)
    },
    None =>
      Error.createPanicError(
        Error.Parsing,
        tok.span,
        "Internal error",
        [Error.Note("token has no mate")]
      ),
  }
}

//create a span from the end token
let spanFromTokens = (startSpan: Source.Span, endSpan: Source.Span) =>
  Source.makeSpan(startSpan.line, startSpan.col, startSpan.start, endSpan.end)

let spanFromEnd = (state: ParseState, endTok: Lexer.Token) => {
  let startTok = fetchMate(state, endTok)
  spanFromTokens(startTok.span, endTok.span)
}

let expectSimpleOrRecover = (expected, state: ParseState, context: String) => {
  let tok = currentToken(state)
  if (kindIs(tok.kind, expected)) {
    expectSimple(expected, state)
  } else if (state.tolerant) {
    let syntheticSpan = Source.makeSpan(tok.span.line, tok.span.col, tok.span.start, tok.span.start)
    let synthetic: Lexer.Token = { kind: expected, span: syntheticSpan, mate: None }
    let recoveryTok: Lexer.Token = Error.createError(
      Error.Parsing,
      tok.span,
      "Expected " ++ Lexer.tokenKindToString(expected) ++ " " ++ context,
      synthetic,
      clues=[
        Error.Expected(Lexer.tokenKindToString(expected)),
        Error.Received(Lexer.tokenKindToString(tok.kind)),
      ],
    )
    (recoveryTok, state)
  } else {
    Error.createPanicError(
      Error.Parsing,
      tok.span,
      "Expected " ++ Lexer.tokenKindToString(expected) ++ " " ++ context,
      [Error.Received(Lexer.tokenKindToString(tok.kind))]
    )
  }
}

//parse
let rec parseExpr: Parser<Ast.Expr> = state => {
  let (leadingTrivia, state0) = takeLeadingGapTrivia(state, [])
  let (coreExpr: Ast.Expr, coreState) = parseInfix(state0)
  let (expr, state1) = match (currentToken(coreState).kind) {
    Lexer.FatArrow => {
      let (id, stateAfterId) = freshId(coreState)
      let opTok = currentToken(stateAfterId)
      let (_, state2) = expectSimple(Lexer.FatArrow, stateAfterId)
      let (opId, state2b) = freshId(state2)
      let (rhs, state3): (Ast.Expr, ParseState) = parseExpr(state2b)
      let span = spanFromTokens(coreExpr.node.span, rhs.node.span)
      let node: Ast.Expr = makeExpr(
        id,
        span,
        InfixChain(
          {
            first: coreExpr,
            rest: [({ node: { id: opId, span: opTok.span }, text: "=>" }, rhs)],
          },
        )
      )
      (node, state3)
    },
    Lexer.PipeArrow => {
      let (id, stateAfterId) = freshId(coreState)
      let opTok = currentToken(stateAfterId)
      let (_, state2) = expectSimple(Lexer.PipeArrow, stateAfterId)
      let (opId, state2b) = freshId(state2)
      let (rhs, state3) = parseExpr(state2b)
      let span = spanFromTokens(coreExpr.node.span, rhs.node.span)
      let node = makeExpr(
        id,
        span,
        InfixChain(
          {
            first: coreExpr,
            rest: [({ node: { id: opId, span: opTok.span }, text: ":>" }, rhs)],
          },
        )
      )
      (node, state3)
    },
    _ => (coreExpr, coreState),
  }
  let (trailingTrivia, state2) = takeTrailingGapTriviaOnLine(expr.node.span.line, state1, [])
  (withExprAttachments(expr, leadingTrivia, trailingTrivia), state2)
}
and parseInfix: Parser<Ast.Expr> = state => {
  let (expr: Expr, state1) = parseTerm(state)
  match (currentToken(state1).kind) {
    Lexer.Plus => {
      let (id, stateAfterId) = freshId(state1)
      let opTok = currentToken(stateAfterId)
      let (_, state2) = expectSimple(Lexer.Plus, stateAfterId)
      let (opId, state2b) = freshId(state2)
      let (rhs, state3) = parseInfix(state2b)
      let span = spanFromTokens(expr.node.span, rhs.node.span)
      let node = makeExpr(
        id,
        span,
        InfixChain(
          {
            first: expr,
            rest: [({ node: { id: opId, span: opTok.span }, text: "+" }, rhs)],
          },
        )
      )
      (node, state3)
    },
    Lexer.Dash => {
      let (id, stateAfterId) = freshId(state1)
      let opTok = currentToken(stateAfterId)
      let (_, state2) = expectSimple(Lexer.Dash, stateAfterId)
      let (opId, state2b) = freshId(state2)
      let (rhs, state3) = parseInfix(state2b)
      let span = spanFromTokens(expr.node.span, rhs.node.span)
      let node = makeExpr(
        id,
        span,
        InfixChain(
          {
            first: expr,
            rest: [({ node: { id: opId, span: opTok.span }, text: "-" }, rhs)],
          },
        )
      )
      (node, state3)
    },
    Lexer.Arrow => {
      let (id, stateAfterId) = freshId(state1)
      let opTok = currentToken(stateAfterId)
      let (_, state2) = expectSimple(Lexer.Arrow, stateAfterId)
      let (opId, state2b) = freshId(state2)
      let (rhs, state3) = parseInfix(state2b)
      let span = spanFromTokens(expr.node.span, rhs.node.span)
      let node = makeExpr(
        id,
        span,
        InfixChain(
          {
            first: expr,
            rest: [({ node: { id: opId, span: opTok.span }, text: "->" }, rhs)],
          },
        )
      )
      (node, state3)
    },
    _ => (expr, state1),
  }
}
and parsePostfix = (
  target: Ast.Expr,
  segments: List<Ast.PostfixSegment>,
  state: ParseState,
) => {
  let tok = currentToken(state)
  match (tok.kind) {
    Lexer.LParen => {
      let (_, state1) = expectSimple(Lexer.LParen, state)
      let mut args = []
      let mut currentState = state1
      if (!kindIs(currentToken(currentState).kind, Lexer.RParen)) {
        let (arg, state_temp) = parseExpr(currentState)
        args = [arg, ...args]
        currentState = state_temp
        while (kindIs(currentToken(currentState).kind, Lexer.Comma)) {
          let (_, state_temp2) = expectSimple(Lexer.Comma, currentState)
          let (nextArg, state_temp3) = parseExpr(state_temp2)
          args = [nextArg, ...args]
          currentState = state_temp3
        }
      }
      let (rparenTok, state2) = expectSimpleOrRecover(
        Lexer.RParen,
        currentState,
        "to close call",
      )
      let segment = Call(List.reverse(args))
      let newSegments = [segment, ...segments]
      parsePostfix(target, newSegments, state2)
    },
    Lexer.Period => {
      let (_, state1) = expectSimple(Lexer.Period, state)
      let (name, nameTok, state2) = expectName(state1)
      let segment = Project(
        { node: { id: target.node.id, span: nameTok.span }, text: name },
      )
      let newSegments = [segment, ...segments]
      parsePostfix(target, newSegments, state2)
    },
    _ => {
      if (List.length(segments) == 0) {
        (target, state)
      } else {
        let postfix = Postfix({ target, segments: List.reverse(segments) })
        let newExpr = makeExpr(target.node.id, target.node.span, postfix)
        (newExpr, state)
      }
    },
  }
}
and parseTerm: Parser<Ast.Expr> = state => {
  let tok = currentToken(state)
  match (tok.kind) {
    Lexer.LBrace => parseBlock(state),
    Lexer.FatArrow => {
      // Thunk syntax: => body
      let (id, state1) = freshId(state)
      let (_, state2) = expectSimple(Lexer.FatArrow, state1)
      let (body, state3) = parseExpr(state2)
      let span = spanFromTokens(tok.span, body.node.span)
      let bodyBlock = match (body.kind) {
        Block(b) => b,
        _ => { node: body.node, items: [], result: [body] },
      }
      let (patId, state4) = freshId(state3)
      let wildcardPat: Ast.Pattern = {
        node: { id: patId, span: tok.span },
        kind: Wildcard,
        attach: { leading: [], trailing: [], dangling: [] },
      }
      let (clauseId, state5) = freshId(state4)
      let clause: Ast.FnClause = {
        node: { id: clauseId, span },
        param: wildcardPat,
        guard: None,
        body: bodyBlock,
        attach: { leading: [], trailing: [], dangling: [] },
      }
      let (itemId, state6) = freshId(state5)
      let item: Ast.FnItem = {
        node: { id: itemId, span },
        kind: Ast.Clause(clause),
        attach: { leading: [], trailing: [], dangling: [] },
      }
      let (fnExprId, state7) = freshId(state6)
      let fnExpr: Ast.FnExpr = {
        node: { id: fnExprId, span },
        items: [item],
        attach: { leading: [], trailing: [], dangling: [] },
      }
      let expr = makeExpr(id, span, Fn(fnExpr))
      (expr, state7)
    },
    _ => {
      let (expr, state1) = parsePrimary(state)
      parsePostfix(expr, [], state1)
    },
  }
}
//must support inner code
and parseBlock: Parser<Ast.Expr> = state => {
  let (id, state1) = freshId(state)
  let (lbraceTok, state2) = expectSimple(Lexer.LBrace, state1)
  let (items, result, state3) = parseStatements(state2)
  let (rbraceTok, state4) = expectSimpleOrRecover(
    Lexer.RBrace,
    state3,
    "to close block",
  )
  let span = spanFromTokens(lbraceTok.span, rbraceTok.span)
  let expr = makeExpr(id, span, Block({ node: { id, span }, items, result }))
  (expr, state4)
}
and parsePrimary: Parser<Ast.Expr> = state => {
  let (id, state1) = freshId(state)
  let tok = currentToken(state1)

  match (tok.kind) {
    Lexer.Wildcard => {
      let state2 = dropToken(state1)
      let (nameId, state3) = freshId(state2)
      let expr: Ast.Expr = makeExpr(
        id,
        tok.span,
        Ident({ node: { id: nameId, span: tok.span }, text: "_" })
      )
      (expr, state3)
    },
    Lexer.LitNum(value) => {
      let state2 = dropToken(state1)
      let expr: Ast.Expr = makeExpr(id, tok.span, Lit(Ast.Int(value)))
      (expr, state2)
    },
    Lexer.LitString(value) => {
      let state2 = dropToken(state1)
      let expr: Ast.Expr = makeExpr(id, tok.span, Lit(Ast.Str(value)))
      (expr, state2)
    },
    Lexer.LitChar(value) => {
      let state2 = dropToken(state1)
      let expr: Ast.Expr = makeExpr(id, tok.span, Lit(Ast.Char(value)))
      (expr, state2)
    },
    Lexer.LitName(name) => {
      if (name == "match") {
        parseMatch(state1)
      } else if (name == "if") {
        parseIf(state1)
      } else {
        let state2 = dropToken(state1)
        let (nameId, state3) = freshId(state2)
        let expr: Ast.Expr = makeExpr(
          id,
          tok.span,
          Ident({ node: { id: nameId, span: tok.span }, text: name })
        )
        (expr, state3)
      }
    },
    Lexer.ConstructorTok(name) => {
      let state1 = dropToken(state1)
      if (kindIs(currentToken(state1).kind, Lexer.LBrace)) {
        let (_, state2) = expectSimple(Lexer.LBrace, state1)
        let mut fields = []
        let mut currentState = state2
        while (!kindIs(currentToken(currentState).kind, Lexer.RBrace)) {
          if (kindIs(currentToken(currentState).kind, Lexer.Comma)) {
            let (_, state_temp) = expectSimple(Lexer.Comma, currentState)
            currentState = state_temp
          } else {
            let (fieldName, nameTok, state_temp) = expectName(currentState)
            let (fieldExpr, state_temp3) = if (
              kindIs(currentToken(state_temp).kind, Lexer.Eq)
            ) {
              let (_, state_temp2) = expectSimple(Lexer.Eq, state_temp)
              parseExpr(state_temp2)
            } else {
              (
                makeExpr(
                  id,
                  nameTok.span,
                  Ident({ node: { id, span: nameTok.span }, text: fieldName })
                ),
                state_temp,
              )
            }
            fields = [(fieldName, nameTok, fieldExpr), ...fields]
            currentState = state_temp3
            if (kindIs(currentToken(currentState).kind, Lexer.Comma)) {
              let (_, state_temp4) = expectSimple(Lexer.Comma, currentState)
              currentState = state_temp4
            }
          }
        }
        let (rbraceTok, state3) = expectSimpleOrRecover(
          Lexer.RBrace,
          currentState,
          "to close constructor record",
        )
        let span = spanFromTokens(tok.span, rbraceTok.span)
        let reversedFields = List.reverse(fields)
        let rec buildFieldItems: (List<(String, Lexer.Token, Ast.Expr)>, Number) => List<
          Ast.RecordItem
        > = (items, currentId) => match (items) {
          [] => [],
          [(name, tok, expr), ...rest] => {
            let field = Field(
              { node: { id: currentId, span: tok.span }, text: name },
              expr,
            )
            [field, ...buildFieldItems(rest, currentId + 1)]
          },
        }
        let fieldItems = buildFieldItems(reversedFields, id + 1)
        let expr: Ast.Expr = makeExpr(id, span, RecordLit(fieldItems))
        (expr, state3)
      } else {
        let expr: Ast.Expr = makeExpr(
          id,
          tok.span,
          Ident({ node: { id, span: tok.span }, text: name })
        )
        (expr, state1)
      }
    },
    Lexer.LParen => {
      let (_, state2) = expectSimple(Lexer.LParen, state1)
      if (kindIs(currentToken(state2).kind, Lexer.RParen)) {
        let (rparenTok, state3) = expectSimpleOrRecover(
          Lexer.RParen,
          state2,
          "to close tuple/paren",
        )
        let span = spanFromTokens(tok.span, rparenTok.span)
        let expr: Ast.Expr = makeExpr(id, span, Lit(Ast.Unit))
        (expr, state3)
      } else {
        let (inner, state3) = parseExpr(state2)
        if (kindIs(currentToken(state3).kind, Lexer.Comma)) {
          let mut exprs = [inner]
          let mut currentState = state3
          while (kindIs(currentToken(currentState).kind, Lexer.Comma)) {
            let (_, state_temp) = expectSimple(Lexer.Comma, currentState)
            let (nextExpr, state_next) = parseExpr(state_temp)
            exprs = [nextExpr, ...exprs]
            currentState = state_next
          }
          let (rparenTok, state4) = expectSimpleOrRecover(
            Lexer.RParen,
            currentState,
            "to close tuple",
          )
          let span = spanFromTokens(tok.span, rparenTok.span)
          let expr: Ast.Expr = makeExpr(id, span, Tuple(List.reverse(exprs)))
          (expr, state4)
        } else {
          let (rparenTok, state4) = expectSimpleOrRecover(
            Lexer.RParen,
            state3,
            "to close parenthesized expression",
          )
          let span = spanFromTokens(tok.span, rparenTok.span)
          let expr: Ast.Expr = makeExpr(id, span, Paren(inner))
          (expr, state4)
        }
      }
    },
    Lexer.Question => {
      let state2 = dropToken(state1)
      let expr: Ast.Expr = makeExpr(
        id,
        tok.span,
        Hole(
          { node: { id, span: tok.span }, kind: ExprHole, origin: UserTyped },
        )
      )
      (expr, state2)
    },
    Lexer.DotBrace => {
      let (_, state2) = expectSimple(Lexer.DotBrace, state1)
      let mut fields = []
      let mut currentState = state2
      while (!kindIs(currentToken(currentState).kind, Lexer.RBrace)) {
        if (kindIs(currentToken(currentState).kind, Lexer.Comma)) {
          // Skip leading/trailing commas
          let (_, state_temp) = expectSimple(Lexer.Comma, currentState)
          currentState = state_temp
        } else {
          let (fieldName, nameTok, state_temp) = expectName(currentState)
          let (fieldExpr, state_temp3) = if (
            kindIs(currentToken(state_temp).kind, Lexer.Eq)
          ) {
            let (_, state_temp2) = expectSimple(Lexer.Eq, state_temp)
            parseExpr(state_temp2)
          } else {
            (
              makeExpr(
                id,
                nameTok.span,
                Ident({ node: { id, span: nameTok.span }, text: fieldName })
              ),
              state_temp,
            )
          }
          fields = [(fieldName, nameTok, fieldExpr), ...fields]
          currentState = state_temp3
          if (kindIs(currentToken(currentState).kind, Lexer.Comma)) {
            let (_, state_temp4) = expectSimple(Lexer.Comma, currentState)
            currentState = state_temp4
          }
        }
      }
      let (rbraceTok, state3) = expectSimpleOrRecover(
        Lexer.RBrace,
        currentState,
        "to close record literal",
      )
      let span = spanFromTokens(tok.span, rbraceTok.span)
      let reversedFields = List.reverse(fields)
      let rec buildFieldItems: (List<(String, Lexer.Token, Ast.Expr)>, Number) => List<
        Ast.RecordItem
      > = (items, currentId) => match (items) {
        [] => [],
        [(name, tok, expr), ...rest] => {
          let field = Field(
            { node: { id: currentId, span: tok.span }, text: name },
            expr,
          )
          [field, ...buildFieldItems(rest, currentId + 1)]
        },
      }
      let fieldItems = buildFieldItems(reversedFields, id + 1)
      let expr: Ast.Expr = makeExpr(id, span, RecordLit(fieldItems))
      (expr, state3)
    },
    Lexer.FatArrow => {
      let state2 = dropToken(state1)
      let (bodyExpr, state3) = parseExpr(state2)
      let span = spanFromTokens(tok.span, bodyExpr.node.span)
      let (patId, state4) = freshId(state3)
      let pat: Ast.Pattern = {
        node: { id: patId, span: tok.span },
        kind: Wildcard,
        attach: { leading: [], trailing: [], dangling: [] },
      }
      let bodyBlock = match (bodyExpr.kind) {
        Block(b) => b,
        _ => { node: bodyExpr.node, items: [], result: [bodyExpr] },
      }
      let (clauseId, state5) = freshId(state4)
      let clause: Ast.FnClause = {
        node: { id: clauseId, span },
        param: pat,
        guard: None,
        body: bodyBlock,
        attach: { leading: [], trailing: [], dangling: [] },
      }
      let (itemId, state6) = freshId(state5)
      let item: Ast.FnItem = {
        node: { id: itemId, span },
        kind: Ast.Clause(clause),
        attach: { leading: [], trailing: [], dangling: [] },
      }
      let (fnExprId, state7) = freshId(state6)
      let fnExpr: Ast.FnExpr = {
        node: { id: fnExprId, span },
        items: [item],
        attach: { leading: [], trailing: [], dangling: [] },
      }
      let expr = makeExpr(id, span, Fn(fnExpr))
      (expr, state7)
    },
    _ => {
      if (state.tolerant) {
        makeInferredExprHole(
          state,
          tok.span,
          "Expected expression",
          [
            Error.Expected("expression"),
            Error.Received(Lexer.tokenKindToString(tok.kind)),
          ],
        )
      } else {
        Error.createPanicError(
          Error.Parsing,
          tok.span,
          "Expected expression",
          [Error.Received(Lexer.tokenKindToString(tok.kind))]
        )
      }
    },
  }
}
and parseIf = (state: ParseState) => {
  let (id, state1) = freshId(state)
  let (ifTok, state2) = expectKeyword("if", state)
  let (cond, state3) = parseExpr(state2)
  let (thenExpr, state4) = parseExpr(state3)
  let (elseExpr, state5) = if (
    kindIs(currentToken(state4).kind, Lexer.LitName("else"))
  ) {
    let (_, state_temp) = expectKeyword("else", state4)
    let (expr, state_temp2) = parseExpr(state_temp)
    (Some(expr), state_temp2)
  } else {
    (None, state4)
  }
  let endSpan = match (elseExpr) {
    Some(e) => e.node.span,
    None => thenExpr.node.span,
  }
  let span = spanFromTokens(ifTok.span, endSpan)
  let expr = makeExpr(id, span, Ast.If(cond, thenExpr, elseExpr))
  (expr, state5)
}
and parseTopLevels = (state: ParseState) => {
  let tok = currentToken(state)
  //print(tok)
  match (tok.kind) {
    Lexer.EOF => ([], state),
    Lexer.SemiColon => {
      // Skip semicolons
      let state1 = dropToken(state)
      parseTopLevels(state1)
    },
    Lexer.LineComment(text) => {
      let state1 = dropToken(state)
      let (id, state2) = freshId(state1)
      let trivia = makeLineTrivia(id, tok.span, text)
      let topTrivia: Ast.TopItem = Ast.Trivia(trivia)
      let (rest, state3) = parseTopLevels(state2)
      ([topTrivia, ...rest], state3)
    },
    Lexer.LitName(name) when name == "let" => {
      let (group, state1) = parseLetGroup(state)
      let state2 = consumeTopLevelSemicolon(state1, topItemSpan(group))
      let (rest, state3) = parseTopLevels(state2)
      ([group, ...rest], state3)
    },
    Lexer.LitName(name) when name == "export" => {
      let exportTok = tok
      let state1 = dropToken(state)
      let (exportId, state1b) = freshId(state1)
      let (inner, state2) = parseTopLevels(state1b)
      match (inner) {
        [DeclGroup(dg), ...rest] => {
          // Create Export node for the export keyword
          let exportNode = Export(
            { node: { id: exportId, span: exportTok.span }, },
          )
          // Mark DeclGroup as exported
          let exportedDg = { ...dg, exported: true }
          ([exportNode, DeclGroup(exportedDg), ...rest], state2)
        },
        [] => {
          let exportRecovery: Ast.Recovery = {
            node: { id: exportId, span: exportTok.span },
            kind: Ast.InvalidTopLevel("export"),
            expected: Ast.ExpectTopItem(Ast.TopItemDeclGroup),
          }
          let recoveryItem: Ast.TopItem = Error.createError(
            Error.Parsing,
            tok.span,
            "Expected declaration after export",
            Ast.Recovery(exportRecovery),
            clues=[Error.Note("export must be followed by a declaration")],
          )
          ([recoveryItem], state2)
        },
        [first, ...rest] => {
          let exportRecovery: Ast.Recovery = {
            node: { id: exportId, span: exportTok.span },
            kind: Ast.InvalidTopLevel("export"),
            expected: Ast.ExpectTopItem(Ast.TopItemDeclGroup),
          }
          let recoveryItem: Ast.TopItem = Error.createError(
            Error.Parsing,
            tok.span,
            "Invalid export",
            Ast.Recovery(exportRecovery),
            clues=[Error.Note("export can only be applied to declarations")],
          )
          ([recoveryItem, first, ...rest], state2)
        },
      }
    },
    Lexer.LitName(name) when name == "type" => {
      let (typeDef, state1) = parseTypeDef(state)
      let (rest, state2) = parseTopLevels(state1)
      ([typeDef, ...rest], state2)
    },
    Lexer.LitName(name) when name == "record" => {
      let (typeDef, state1) = parseRecordDef(state)
      let (rest, state2) = parseTopLevels(state1)
      ([typeDef, ...rest], state2)
    },
    _ => {
      // Unknown in top-level context: mark as recovery and continue.
      let state1 = dropToken(state)
      let (id, state2) = freshId(state1)
      let recovery: Ast.Recovery = {
        node: { id, span: tok.span },
        kind: Ast.UnknownTopLevel(Lexer.tokenKindToString(tok.kind)),
        expected: Ast.ExpectTopItem(Ast.TopItemAny),
      }
      let topRecovery: Ast.TopItem = Error.createError(
        Error.Parsing,
        tok.span,
        "Unexpected token at top-level",
        Ast.Recovery(recovery),
        clues=[
          Error.Expected("declaration or directive"),
          Error.Received(Lexer.tokenKindToString(tok.kind)),
        ],
      )
      let (rest, state3) = parseTopLevels(state2)
      ([topRecovery, ...rest], state3)
    },
  }
}
and parseBinding = (state: ParseState, startSpanOpt: Option<Source.Span>) => {
  let (id, state1) = freshId(state)
  let (pattern, state2) = parsePattern(state1)
  //Optionally parse type annotation after ':'
  let (typeOpt, state3) = if (kindIs(currentToken(state2).kind, Lexer.Colon)) {
    let (_, state_temp) = expectSimple(Lexer.Colon, state2)
    // Parse type tokens until '=' (approximate, like TypeDef)
    let rec parseType = (accumulator, state) => {
      let tok = currentToken(state)
      if (kindIs(tok.kind, Lexer.Eq)) {
        (Some(accumulator), state)
      } else if (state.tolerant && isValueBoundary(tok)) {
        (Some(accumulator), state)
      } else {
        parseType(accumulator ++ " " ++ toString(tok.kind), dropToken(state))
      }
    }
    parseType("", state_temp)
  } else {
    (None, state2)
  }
  let (state4, hasEq) = if (kindIs(currentToken(state3).kind, Lexer.Eq)) {
    let (_, nextState) = expectSimple(Lexer.Eq, state3)
    (nextState, true)
  } else if (state3.tolerant && isValueBoundary(currentToken(state3))) {
    let recoveryState = Error.createError(
      Error.Parsing,
      currentToken(state3).span,
      "Expected '=' in let binding",
      state3,
      clues=[
        Error.Expected("="),
        Error.Received(Lexer.tokenKindToString(currentToken(state3).kind)),
      ],
    )
    (recoveryState, false)
  } else {
    Error.createPanicError(
      Error.Parsing,
      currentToken(state3).span,
      "Expected '=' in let binding",
      [Error.Received(Lexer.tokenKindToString(currentToken(state3).kind))]
    )
  }
  let (value, state5): (Ast.Expr, ParseState) = if (
    hasEq && state4.tolerant && isValueBoundary(currentToken(state4))
  ) {
    makeInferredExprHole(
      state4,
      pattern.node.span,
      "Expected expression after '=' in let binding",
      [
        Error.Expected("expression"),
        Error.Received(Lexer.tokenKindToString(currentToken(state4).kind)),
      ],
    )
  } else if (hasEq) {
    parseExpr(state4)
  } else {
    makeInferredExprHole(
      state4,
      pattern.node.span,
      "Expected expression in let binding",
      [
        Error.Expected("expression"),
        Error.Received(Lexer.tokenKindToString(currentToken(state4).kind)),
      ],
    )
  }
  // Use startSpan if provided (for 'let' keyword), otherwise start from pattern
  let span = match (startSpanOpt) {
    Some(startSpan) => spanFromTokens(startSpan, value.node.span),
    None => spanFromTokens(pattern.node.span, value.node.span),
  }
  let binding: Ast.LetBinding = {
    node: { id, span },
    name: pattern,
    annotation: None,
    value,
  }
  (binding, state5)
}
and parseLetMods: ParseState => (Ast.LetGroupMods, ParseState) = state => {
  let tok = currentToken(state)
  if (kindIs(tok.kind, Lexer.LitName("rec"))) {
    let state1 = dropToken(state)
    (Ast.Rec, state1)
  } else if (kindIs(tok.kind, Lexer.LitName("mut"))) {
    let state1 = dropToken(state)
    (Ast.Mut, state1)
  } else {
    (Ast.Rec, state)
  }
}
and parseLetGroup: ParseState => (Ast.TopItem, ParseState) = state => {
  let (id, state1) = freshId(state)
  let (letTok, state2) = expectKeyword("let", state1)
  let (mods, state3) = parseLetMods(state2)
  let (firstBinding, state4) = parseBinding(state3, Some(letTok.span))
  let mut bindings = [firstBinding]
  let mut currentState = state4
  while (kindIs(currentToken(currentState).kind, Lexer.LitName("and"))) {
    let (andTok, state_temp) = expectKeyword("and", currentState)
    let (binding, state_temp2) = parseBinding(state_temp, Some(andTok.span))
    bindings = [binding, ...bindings]
    currentState = state_temp2
  }
  let reversedBindings = List.reverse(bindings)
  let lastBinding = match (List.head(reversedBindings)) {
    Some(b) => b,
    None =>
      Error.createPanicError(
        Error.Parsing,
        letTok.span,
        "Internal error",
        [Error.Note("bindings list should not be empty")]
      ),
  }
  let span = spanFromTokens(letTok.span, lastBinding.node.span)
  let topLevel = DeclGroup(
    {
      node: { id, span },
      exported: false,
      kind: LetGroup(mods),
      decls: [LetDecl({ node: { id, span }, bindings: reversedBindings })],
    },
  )
  (topLevel, currentState)
}
and parseTypeDef: ParseState => (Ast.TopItem, ParseState) = state => {
  let (id, state1) = freshId(state)
  let (typeTok, state2) = expectKeyword("type", state1)
  let (name, nameTok, state3) = expectConstructor(state2)
  let (_, state4) = expectSimple(Lexer.Eq, state3)
  // Simple: parse until ;
  let rec parseDef = (accumulator, lastSpan, state) => {
    let tok = currentToken(state)
    match (tok.kind) {
      Lexer.SemiColon => (accumulator, lastSpan, dropToken(state)),
      Lexer.EOF => (accumulator, lastSpan, state),
      _ when isTopLevelBoundary(tok) => {
        let recovered = recoverMissingTopLevelSemicolon(state, lastSpan)
        (accumulator, lastSpan, recovered)
      },
      _ => {
        let nextState = dropToken(state)
        parseDef(accumulator ++ " " ++ toString(tok.kind), tok.span, nextState)
      },
    }
  }
  let (def, endSpan, state5) = parseDef("", nameTok.span, state4)
  let fullSpan = spanFromTokens(typeTok.span, endSpan)
  let (typeDeclId, state6) = freshId(state5)
  let (nameId, state7) = freshId(state6)
  let topLevel = DeclGroup(
    {
      node: { id, span: fullSpan },
      exported: false,
      kind: TypeGroup(Rec),
      decls: [
        TypeDecl(
          {
            node: { id: typeDeclId, span: fullSpan },
            name: { node: { id: nameId, span: nameTok.span }, text: name },
            infection: None,
            typeParams: [],
            body: Alias(
              {
                node: { id, span: fullSpan },
                kind: Hole(
                  {
                    node: { id, span: fullSpan },
                    kind: TypeHole,
                    origin: UserTyped,
                  },
                ),
                attach: { leading: [], trailing: [], dangling: [] },
              }: TypeExpr,
            ),
          },
        ),
      ],
    },
  )
  (topLevel, state7)
}
and parseRecordDef = (state: ParseState) => {
  let (id, state1) = freshId(state)
  let (recordTok, state2) = expectKeyword("record", state1) // Expect "record" keyword
  let (name, nameTok, state3) = expectConstructor(state2) // Expect the record name (e.g., MyRecord)
  let (_, state4) = expectSimple(Lexer.Eq, state3) // Expect =
  // Simple: parse until ; (same as type for now; customize if record syntax differs)
  let rec parseDef = (accumulator, lastSpan, state) => {
    let tok = currentToken(state)
    match (tok.kind) {
      Lexer.SemiColon => (accumulator, lastSpan, dropToken(state)),
      Lexer.EOF => (accumulator, lastSpan, state),
      _ when isTopLevelBoundary(tok) => {
        let recovered = recoverMissingTopLevelSemicolon(state, lastSpan)
        (accumulator, lastSpan, recovered)
      },
      _ => {
        let nextState = dropToken(state)
        parseDef(accumulator ++ " " ++ toString(tok.kind), tok.span, nextState)
      },
    }
  }
  let (def, endSpan, state5) = parseDef("", nameTok.span, state4)
  let fullSpan = spanFromTokens(recordTok.span, endSpan)
  let (recordDeclId, state6) = freshId(state5)
  let (nameId, state7) = freshId(state6)
  let topLevel = DeclGroup(
    {
      node: { id, span: fullSpan },
      exported: false,
      kind: RecordGroup(Rec),
      decls: [
        RecordDecl(
          {
            node: { id: recordDeclId, span: fullSpan },
            name: { node: { id: nameId, span: nameTok.span }, text: name },
            typeParams: [],
            fields: [],
          },
        ),
      ],
    },
  )
  (topLevel, state7)
}
and parseStatements = (state: ParseState) => {
  let tok = currentToken(state)
  match (tok.kind) {
    Lexer.RBrace => ([], [], state),
    Lexer.EOF =>
      if (state.tolerant) {
        Error.createError(
          Error.Parsing,
          tok.span,
          "Expected '}' to close block",
          ([], [], state),
          clues=[Error.Expected("}"), Error.Received("EOF")],
        )
      } else {
        Error.createPanicError(
          Error.Parsing,
          tok.span,
          "Expected '}' to close block",
          [Error.Received("EOF")]
        )
      },
    Lexer.SemiColon => parseStatements(dropToken(state)),
    Lexer.Comma => parseStatements(dropToken(state)),
    Lexer.LineComment(text) => {
      let state1 = dropToken(state)
      let (id, state2) = freshId(state1)
      let trivia = makeLineTrivia(id, tok.span, text)
      let item = Ast.TriviaItem(trivia)
      let (restItems, result, state3) = parseStatements(state2)
      ([item, ...restItems], result, state3)
    },
    Lexer.LitName("let") => {
      let (letTok, state_temp) = expectKeyword("let", state)
      let (binding, state1) = parseBinding(state_temp, Some(letTok.span))
      let state1b = consumeBlockSemicolon(state1, binding.node.span)
      let (exprId, state2) = freshId(state1b)
      let expr = makeExpr(exprId, binding.node.span, Ast.Let(binding))
      let item = Ast.ExprItem(expr)
      let (restItems, result, state3) = parseStatements(state2)
      ([item, ...restItems], result, state3)
    },
    _ => {
      let (expr, state1) = parseExpr(state)
      if (kindIs(currentToken(state1).kind, Lexer.Eq)) {
        let (_, stateAssign0) = expectSimple(Lexer.Eq, state1)
        let (assignValue, stateAssign1) = if (
          stateAssign0.tolerant && isValueBoundary(currentToken(stateAssign0))
        ) {
          makeInferredExprHole(
            stateAssign0,
            expr.node.span,
            "Expected expression after '=' in assignment",
            [
              Error.Expected("expression"),
              Error.Received(Lexer.tokenKindToString(currentToken(stateAssign0).kind)),
            ],
          )
        } else {
          parseExpr(stateAssign0)
        }
        let stateAssign2 = consumeBlockSemicolon(stateAssign1, assignValue.node.span)
        let (exprId, stateAssign3) = freshId(stateAssign2)
        let span = spanFromTokens(expr.node.span, assignValue.node.span)
        let assignExpr = makeExpr(
          exprId,
          span,
          Ast.Assign({ target: expr, value: assignValue }),
        )
        let item = Ast.ExprItem(assignExpr)
        let (restItems, result, stateEnd) = parseStatements(stateAssign3)
        ([item, ...restItems], result, stateEnd)
      } else if (
        kindIs(currentToken(state1).kind, Lexer.SemiColon)
        || kindIs(currentToken(state1).kind, Lexer.Comma)
      ) {
        let stateExprStmt0 = dropToken(state1)
        let (restItems, result, stateEnd) = parseStatements(stateExprStmt0)
        let item = Ast.ExprItem(expr)
        ([item, ...restItems], result, stateEnd)
      } else if (startsBlockStatement(currentToken(state1))) {
        let stateExprStmt0 = consumeBlockSemicolon(state1, expr.node.span)
        let item = Ast.ExprItem(expr)
        let (restItems, result, stateEnd) = parseStatements(stateExprStmt0)
        ([item, ...restItems], result, stateEnd)
      } else {
        let (restItems, restResult, state2) = parseStatements(state1)
        (restItems, [expr, ...restResult], state2)
      }
    },
  }
}

and parsePatternWithPinMode = (state: ParseState, pinBareIdent: Bool) => {
  let (leadingTrivia, state0) = takeLeadingGapTrivia(state, [])
  let state = state0
  let tok = currentToken(state)
  let (corePattern, coreState) = match (tok.kind) {
    Lexer.Wildcard => {
      let state1 = dropToken(state)
      let (id, state2) = freshId(state1)
      let node = { id, span: tok.span }
      let attach = { leading: [], trailing: [], dangling: [] }
      let kind: Ast.PatternKind = Ast.Wildcard
      let pat: Ast.Pattern = { node, kind, attach }
      (pat, state2)
    },
    Lexer.LitName(name) => {
      let state1 = dropToken(state)
      let (patId, state2) = freshId(state1)
      let (nameId, state3) = freshId(state2)
      let node = { id: patId, span: tok.span }
      let attach = { leading: [], trailing: [], dangling: [] }
      let nameNode = { node: { id: nameId, span: tok.span }, text: name }
      let kind: Ast.PatternKind = if (pinBareIdent) {
        Ast.Pin(nameNode)
      } else {
        Ast.Var(nameNode)
      }
      let pat: Ast.Pattern = { node, kind, attach }
      (pat, state3)
    },
    Lexer.LitNum(value) => {
      let state1 = dropToken(state)
      let (id, state2) = freshId(state1)
      let node = { id, span: tok.span }
      let attach = { leading: [], trailing: [], dangling: [] }
      let lit: Ast.AtomLiteral = Ast.Int(value)
      let kind: Ast.PatternKind = Ast.Lit(lit)
      let pat: Ast.Pattern = { node, kind, attach }
      (pat, state2)
    },
    Lexer.LitString(value) => {
      let state1 = dropToken(state)
      let (id, state2) = freshId(state1)
      let node = { id, span: tok.span }
      let attach = { leading: [], trailing: [], dangling: [] }
      let lit: Ast.AtomLiteral = Ast.Str(value)
      let kind: Ast.PatternKind = Ast.Lit(lit)
      let pat: Ast.Pattern = { node, kind, attach }
      (pat, state2)
    },
    Lexer.LitChar(value) => {
      let state1 = dropToken(state)
      let (id, state2) = freshId(state1)
      let node = { id, span: tok.span }
      let attach = { leading: [], trailing: [], dangling: [] }
      let lit: Ast.AtomLiteral = Ast.Char(value)
      let kind: Ast.PatternKind = Ast.Lit(lit)
      let pat: Ast.Pattern = { node, kind, attach }
      (pat, state2)
    },
    Lexer.LitBool(value) => {
      let state1 = dropToken(state)
      let (id, state2) = freshId(state1)
      let node = { id, span: tok.span }
      let attach = { leading: [], trailing: [], dangling: [] }
      let lit: Ast.AtomLiteral = Ast.Bool(value)
      let kind: Ast.PatternKind = Ast.Lit(lit)
      let pat: Ast.Pattern = { node, kind, attach }
      (pat, state2)
    },
    Lexer.ConstructorTok(name) => {
      if (name == "Var") {
        // Var(name) for binding
        let (_, state1) = expectSimple(Lexer.LParen, dropToken(state))
        let (nameStr, nameTok, state2) = expectName(state1)
        let (_, state3) = expectSimpleOrRecover(
          Lexer.RParen,
          state2,
          "to close Var(...) pattern",
        )
        let (patId, state4) = freshId(state3)
        let (nameId, state5) = freshId(state4)
        let node = { id: patId, span: tok.span }
        let attach = { leading: [], trailing: [], dangling: [] }
        let nameNode = {
          node: { id: nameId, span: nameTok.span },
          text: nameStr,
        }
        let kind: Ast.PatternKind = Ast.Var(nameNode)
        let pat: Ast.Pattern = { node, kind, attach }
        (pat, state5)
      } else if (kindIs(currentToken(dropToken(state)).kind, Lexer.LParen)) {
        let state1 = dropToken(state)
        let (_, state2) = expectSimple(Lexer.LParen, state1)
        let mut args = []
        let mut currentState = state2
        if (!kindIs(currentToken(currentState).kind, Lexer.RParen)) {
          let (arg, state_temp) = parsePatternWithPinMode(currentState, false)
          args = [arg, ...args]
          currentState = state_temp
          while (kindIs(currentToken(currentState).kind, Lexer.Comma)) {
            let (_, state_temp2) = expectSimple(Lexer.Comma, currentState)
            let (nextArg, state_temp3) = parsePatternWithPinMode(state_temp2, false)
            args = [nextArg, ...args]
            currentState = state_temp3
          }
        }
        let (_, state3) = expectSimpleOrRecover(
          Lexer.RParen,
          currentState,
          "to close constructor pattern arguments",
        )
        let (patId, state4) = freshId(state3)
        let (nameId, state5) = freshId(state4)
        let node = { id: patId, span: tok.span }
        let attach = { leading: [], trailing: [], dangling: [] }
        let nameNode = { node: { id: nameId, span: tok.span }, text: name }
        let kind: Ast.PatternKind = Ast.Constructor(
          nameNode,
          List.reverse(args),
        )
        let pat: Ast.Pattern = { node, kind, attach }
        (pat, state5)
      } else {
        let (patId, state1) = freshId(dropToken(state))
        let (nameId, state2) = freshId(state1)
        let node = { id: patId, span: tok.span }
        let attach = { leading: [], trailing: [], dangling: [] }
        let nameNode = { node: { id: nameId, span: tok.span }, text: name }
        let kind: Ast.PatternKind = Ast.Constructor(nameNode, [])
        let pat: Ast.Pattern = { node, kind, attach }
        (pat, state2)
      }
    },
    Lexer.LParen => {
      let (_, state1) = expectSimple(Lexer.LParen, state)
      let (innerPat, state2) = parsePatternWithPinMode(state1, pinBareIdent)
      if (kindIs(currentToken(state2).kind, Lexer.Comma)) {
        let mut pats = [innerPat]
        let mut currentState = state2
        while (kindIs(currentToken(currentState).kind, Lexer.Comma)) {
          let (_, state_temp) = expectSimple(Lexer.Comma, currentState)
          let (nextPat, state_next) = parsePatternWithPinMode(
            state_temp,
            pinBareIdent,
          )
          pats = [nextPat, ...pats]
          currentState = state_next
        }
        let (_, state3) = expectSimpleOrRecover(
          Lexer.RParen,
          currentState,
          "to close tuple pattern",
        )
        let (id, state4) = freshId(state3)
        let node = { id, span: Source.makeSpan(0, 0, 0, 0) } // fix span
        let attach = { leading: [], trailing: [], dangling: [] }
        let kind: Ast.PatternKind = Ast.Tuple(List.reverse(pats))
        let pat: Ast.Pattern = { node, kind, attach }
        (pat, state4)
      } else {
        let (_, state3) = expectSimpleOrRecover(
          Lexer.RParen,
          state2,
          "to close parenthesized pattern",
        )
        (innerPat, state3)
      }
    },
    _ =>
      Error.createPanicError(
        Error.Parsing,
        tok.span,
        "Expected pattern",
        [Error.Received(Lexer.tokenKindToString(tok.kind))]
      ),
  }
  let (trailingTrivia, state1) = takeTrailingGapTriviaOnLine(corePattern.node.span.line, coreState, [])
  (withPatternAttachments(corePattern, leadingTrivia, trailingTrivia), state1)
}
and parsePattern: Parser<Ast.Pattern> = state => parsePatternWithPinMode(
  state,
  false,
)
and parseMatchPattern: Parser<Ast.Pattern> = state => parsePatternWithPinMode(
  state,
  true,
)
and parseMatch = (state: ParseState) => {
  let (id, state1) = freshId(state)
  let (matchTok, state2) = expectKeyword("match", state)
  let rec exprToParamPattern = (expr: Ast.Expr) => {
    match (expr.kind) {
      Ident({ _, text }) when text == "_" =>
        Some(
          {
            node: expr.node,
            kind: Ast.Wildcard,
            attach: expr.attach,
          }: Ast.Pattern,
        ),
      Ident(name) =>
        Some(
          {
            node: expr.node,
            kind: Ast.Var(name),
            attach: expr.attach,
          }: Ast.Pattern,
        ),
      Paren(inner) => exprToParamPattern(inner),
      Tuple(items) => {
        let rec convertAll = (es: List<Ast.Expr>) => {
          match (es) {
            [] => Some([]),
            [head, ...tail] =>
              match (exprToParamPattern(head)) {
                Some(hPat) => match (convertAll(tail)) {
                  Some(restPats) => Some([hPat, ...restPats]),
                  None => None,
                },
                None => None,
              },
          }
        }
        match (convertAll(items)) {
          Some(pats) =>
            Some(
              {
                node: expr.node,
                kind: Ast.Tuple(pats),
                attach: expr.attach,
              }: Ast.Pattern,
            ),
          None => None,
        }
      },
      _ => None,
    }
  }
  let parseFnItemsInBraces = (stateX: ParseState) => {
    let (_, state4) = expectSimple(Lexer.LBrace, stateX)
    let mut items: List<Ast.FnItem> = []
    let mut currentState = state4
    while (!kindIs(currentToken(currentState).kind, Lexer.RBrace)) {
      let tok = currentToken(currentState)
      let nextTok = currentToken(dropToken(currentState))
      let includeName = match (tok.kind) {
        Lexer.LitName(name) when (
          kindIs(nextTok.kind, Lexer.Comma) ||
          kindIs(nextTok.kind, Lexer.RBrace)
        ) =>
          Some(name),
        _ => None,
      }
      let (nextState, item) = match (tok.kind) {
        Lexer.LineComment(comment) => {
          let state_temp = dropToken(currentState)
          let (itemId, state_temp2) = freshId(state_temp)
          let trivia = makeLineTrivia(itemId, tok.span, comment)
          let triviaItem: Ast.FnItem = {
            node: { id: itemId, span: tok.span },
            kind: Ast.Trivia(trivia),
            attach: { leading: [], trailing: [], dangling: [] },
          }
          (state_temp2, triviaItem)
        },
        _ =>
          match (includeName) {
            Some(name) => {
              let state_temp = dropToken(currentState)
              let (nameId, state_temp1) = freshId(state_temp)
              let (itemId, state_temp2) = freshId(state_temp1)
              let includeRef: Ast.Name = {
                node: { id: nameId, span: tok.span },
                text: name,
              }
              let includeItem: Ast.FnItem = {
                node: { id: itemId, span: tok.span },
                kind: Ast.Include(includeRef),
                attach: { leading: [], trailing: [], dangling: [] },
              }
              (state_temp2, includeItem)
            },
            None => {
              let (pat, state_temp) = parseMatchPattern(currentState)
              let (guardOpt, state_temp1) = if (
                kindIs(currentToken(state_temp).kind, Lexer.LitName("when"))
              ) {
                let (_, state_temp0) = expectKeyword("when", state_temp)
                let (guard, state_temp00) = parseExpr(state_temp0)
                (Some(guard), state_temp00)
              } else {
                (None, state_temp)
              }
              let (_, state_temp2) = expectSimple(Lexer.FatArrow, state_temp1)
              let (blockExpr, state_temp3) = parseBlock(state_temp2)
              let body: Ast.Block = match (blockExpr.kind) {
                Block(b) => b,
                _ =>
                  Error.createPanicError(
                    Error.Parsing,
                    blockExpr.node.span,
                    "Expected block after =>",
                    [Error.Received("non-block expression")]
                  ),
              }
              let (clauseId, state_temp4) = freshId(state_temp3)
              let span = spanFromTokens(pat.node.span, body.node.span)
              let clause: Ast.FnClause = {
                node: { id: clauseId, span },
                param: pat,
                guard: guardOpt,
                body,
                attach: { leading: [], trailing: [], dangling: [] },
              }
              let (itemId, state_temp5) = freshId(state_temp4)
              let clauseItem: Ast.FnItem = {
                node: { id: itemId, span },
                kind: Ast.Clause(clause),
                attach: { leading: [], trailing: [], dangling: [] },
              }
              (state_temp5, clauseItem)
            },
          },
      }
      items = [item, ...items]
      if (kindIs(currentToken(nextState).kind, Lexer.Comma)) {
        let (_, state_temp6) = expectSimple(Lexer.Comma, nextState)
        currentState = state_temp6
      } else {
        currentState = nextState
      }
    }
    let (rbraceTok, state5) = expectSimpleOrRecover(
      Lexer.RBrace,
      currentState,
      "to close match bundle",
    )
    (List.reverse(items), rbraceTok, state5)
  }

  let mkMatchExpr = (
    exprId: Number,
    endSpan: Source.Span,
    scrutineeOpt: Option<Ast.Expr>,
    fnItems: List<Ast.FnItem>,
    arrowSugar: Bool,
    stateX: ParseState,
  ) => {
    let (fnExprId, stateY) = freshId(stateX)
    let fnExpr: Ast.FnExpr = {
      node: { id: fnExprId, span: endSpan },
      items: fnItems,
      attach: { leading: [], trailing: [], dangling: [] },
    }
    let matchExpr: Ast.MatchExpr = {
      node: { id: exprId, span: endSpan },
      scrutinee: scrutineeOpt,
      bundle: fnExpr,
      arrowSugar,
      attach: { leading: [], trailing: [], dangling: [] },
    }
    let expr = makeExpr(exprId, endSpan, Match(matchExpr))
    (expr, stateY)
  }

  if (kindIs(currentToken(state2).kind, Lexer.LBrace)) {
    let (fnItems, rbraceTok, state5) = parseFnItemsInBraces(state2)
    let span = spanFromTokens(matchTok.span, rbraceTok.span)
    mkMatchExpr(id, span, None, fnItems, false, state5)
  } else {
    let (scrutinee, state3) = parseInfix(state2)
    if (kindIs(currentToken(state3).kind, Lexer.LBrace)) {
      let (fnItems, rbraceTok, state5) = parseFnItemsInBraces(state3)
      let span = spanFromTokens(matchTok.span, rbraceTok.span)
      mkMatchExpr(id, span, Some(scrutinee), fnItems, false, state5)
    } else if (kindIs(currentToken(state3).kind, Lexer.FatArrow)) {
      let (_, state4) = expectSimple(Lexer.FatArrow, state3)
      if (kindIs(currentToken(state4).kind, Lexer.LBrace)) {
        let _ = match (exprToParamPattern(scrutinee)) {
          Some(_) => void,
          None =>
            Error.createPanicError(
              Error.Parsing,
              scrutinee.node.span,
              "Unsupported first-class match parameter",
              [
                Error.Note(
                  "match(param) => currently supports identifier or tuple of identifiers",
                ),
              ]
            ),
        }
        let (fnItems, rbraceTok, state5) = parseFnItemsInBraces(state4)
        let span = spanFromTokens(matchTok.span, rbraceTok.span)
        mkMatchExpr(id, span, Some(scrutinee), fnItems, true, state5)
      } else {
        Error.createPanicError(
          Error.Parsing,
          currentToken(state4).span,
          "Expected { ... } after match(...) =>",
          [Error.Note("match arrow form requires a clause block")]
        )
      }
    } else {
      Error.createPanicError(
        Error.Parsing,
        currentToken(state3).span,
        "Expected match body",
        [Error.Note("use match { ... }, match(expr) { ... }, or match(expr) => { ... }")]
      )
    }
  }
}

let parseWithRecovery = (source: String) => {
  let tokens = Lexer.lex(source)
  let initial: ParseState = {
    tokens,
    nextId: 1,
    allTokens: tokens,
    tolerant: true,
    missingSemicolons: [],
  }
  let (topLevels, _finalState) = parseTopLevels(initial)
  let program: Ast.Program = { items: topLevels, core: false }
  {
    program,
    missingSemicolons: List.reverse(_finalState.missingSemicolons),
  }
}

provide let parseResult = (source: String) => parseWithRecovery(source)

provide let parse = (source: String) => (parseResult(source)).program
