module Parser

from "runtime/unsafe/panic" include Panic
use Panic.{ panic }
from "list" include List
from "string" include String

from "../core/ast.gr" include Ast
use Ast.*
from "./lexer.gr" include Lexer
from "../core/source.gr" include Source

from "../util.gr" include Util
use Util.{ testStr }

record ParseState {
  tokens: List<Lexer.Token>,
  nextId: Number, // token id
  allTokens: List<Lexer.Token>,
}

type Parser<a> = ParseState => (a, ParseState)

let makeExpr: (Number, Source.Span, Ast.ExprKind) => Ast.Expr = (id, span, kind) => {
  let node = { id, span }
  let attach = { leading: [], trailing: [], dangling: [] }
  { node, kind, attach }
}

// id +1
let freshId = (state: ParseState) => {
  let id = state.nextId
  (id, { ...state, nextId: id + 1 })
}

// inspect token
let currentToken = (state: ParseState) => match (state.tokens) {
  [head, ..._tail] => head,
  [] => { kind: Lexer.EOF, span: Source.makeSpan(1, 1, 0, 0), mate: None },
}

// drop 1 token from the list
let dropToken = (state: ParseState) => {
  let tok = currentToken(state)
  //print(tok)
  print("Processed token: " ++ Lexer.tokenKindToString(tok.kind))
  match (state.tokens) {
    [_head, ...tail] => { ...state, tokens: tail },
    [] => { ...state, tokens: [] },
  }
}

//return token at an index
let rec tokenAt = (tokens: List<Lexer.Token>, index: Number) => {
  if (index < 0) {
    None
  } else {
    match (tokens) {
      [] => None,
      [head, ...tail] => if (index == 0) {
        Some(head)
      } else {
        tokenAt(tail, index - 1)
      },
    }
  }
}

// check token validity
let kindIs = (kind, expected) => kind == expected

//expect type
let expectSimple = (expected, state: ParseState) => {
  let tok = currentToken(state)
  if (kindIs(tok.kind, expected)) {
    (tok, dropToken(state))
  } else {
    print("expected: " ++ Lexer.tokenKindToString(expected))
    let str = "Parse error: unexpected token "
      ++ Lexer.tokenKindToString(tok.kind)
    Panic.panic(str)
  }
}

//expect name
let expectName = (state: ParseState) => {
  let tok = currentToken(state)
  match (tok.kind) {
    Lexer.LitName(name) => (name, tok, dropToken(state)),
    _ => {
      print(tok.kind)
      Panic.panic(
        "Parse error: expected identifier, tok: "
          ++ Lexer.tokenKindToString(tok.kind)
      )
    },
  }
}

//expect name
let expectConstructor = (state: ParseState) => {
  let tok = currentToken(state)
  match (tok.kind) {
    Lexer.ConstructorTok(name) => (name, tok, dropToken(state)),
    _ => {
      print(tok.kind)
      Panic.panic(
        "Parse error: expected identifier, tok: "
          ++ Lexer.tokenKindToString(tok.kind)
      )
    },
  }
}

//expect keyword tokenized as a name
let expectKeyword = (keyword: String, state: ParseState) => {
  let tok = currentToken(state)
  match (tok.kind) {
    Lexer.LitName(name) when name == keyword => (tok, dropToken(state)),
    _ => {
      print(tok.kind)
      Panic.panic("Parse error: expected keyword")
    },
  }
}

//fetch the mate of a token that has one
let fetchMate = (state: ParseState, tok: Lexer.Token) => {
  match (tok.mate) {
    Some(mateIndex) => {
      let rec find = (ts: List<Lexer.Token>) => match (ts) {
        [] => panic("Mate not found"),
        [h, ...t] => if (h.span.start == mateIndex) {
          h
        } else {
          find(t)
        },
      }
      find(state.allTokens)
    },
    None => panic("No mate"),
  }
}

//create a span from the end token
let spanFromTokens = (startSpan: Source.Span, endSpan: Source.Span) =>
  Source.makeSpan(startSpan.line, startSpan.col, startSpan.start, endSpan.end)

let spanFromEnd = (state: ParseState, endTok: Lexer.Token) => {
  let startTok = fetchMate(state, endTok)
  spanFromTokens(startTok.span, endTok.span)
}

//parse
let rec parseExpr: Parser<Ast.Expr> = state => {
  let (expr: Ast.Expr, state1) = parseInfix(state)
  match (currentToken(state1).kind) {
    Lexer.FatArrow => {
      let (id, stateAfterId) = freshId(state1)
      let (_, state2) = expectSimple(Lexer.FatArrow, stateAfterId)
      let (rhs, state3): (Ast.Expr, ParseState) = parseExpr(state2)
      let span = spanFromTokens(expr.node.span, rhs.node.span)
      let node: Ast.Expr = makeExpr(
        id,
        span,
        InfixChain(
          { first: expr, rest: [({ node: { id, span }, text: "=>" }, rhs)] },
        )
      )
      (node, state3)
    },
    Lexer.PipeArrow => {
      let (id, stateAfterId) = freshId(state1)
      let (_, state2) = expectSimple(Lexer.PipeArrow, stateAfterId)
      let (rhs, state3) = parseExpr(state2)
      let span = spanFromTokens(expr.node.span, rhs.node.span)
      let node = makeExpr(
        id,
        span,
        InfixChain(
          { first: expr, rest: [({ node: { id, span }, text: ":>" }, rhs)] },
        )
      )
      (node, state3)
    },
    _ => (expr, state1),
  }
}
and parseInfix: Parser<Ast.Expr> = state => {
  let (expr: Expr, state1) = parseTerm(state)
  match (currentToken(state1).kind) {
    Lexer.Plus => {
      let (id, stateAfterId) = freshId(state1)
      let (_, state2) = expectSimple(Lexer.Plus, stateAfterId)
      let (rhs, state3) = parseInfix(state2)
      let span = spanFromTokens(expr.node.span, rhs.node.span)
      let node = makeExpr(
        id,
        span,
        InfixChain(
          { first: expr, rest: [({ node: { id, span }, text: "+" }, rhs)] },
        )
      )
      (node, state3)
    },
    Lexer.Dash => {
      let (id, stateAfterId) = freshId(state1)
      let (_, state2) = expectSimple(Lexer.Dash, stateAfterId)
      let (rhs, state3) = parseInfix(state2)
      let span = spanFromTokens(expr.node.span, rhs.node.span)
      let node = makeExpr(
        id,
        span,
        InfixChain(
          { first: expr, rest: [({ node: { id, span }, text: "-" }, rhs)] },
        )
      )
      (node, state3)
    },
    Lexer.Arrow => {
      let (id, stateAfterId) = freshId(state1)
      let (_, state2) = expectSimple(Lexer.Arrow, stateAfterId)
      let (rhs, state3) = parseInfix(state2)
      let span = spanFromTokens(expr.node.span, rhs.node.span)
      let node = makeExpr(
        id,
        span,
        InfixChain(
          { first: expr, rest: [({ node: { id, span }, text: "->" }, rhs)] },
        )
      )
      (node, state3)
    },
    Lexer.Arrow => {
      let (id, stateAfterId) = freshId(state1)
      let (_, state2) = expectSimple(Lexer.Arrow, stateAfterId)
      let (rhs, state3) = parseInfix(state2)
      let span = spanFromTokens(expr.node.span, rhs.node.span)
      let node = makeExpr(
        id,
        span,
        InfixChain(
          { first: expr, rest: [({ node: { id, span }, text: ">" }, rhs)] },
        )
      )
      (node, state3)
    },
    _ => (expr, state1),
  }
}
and parsePostfix = (
  target: Ast.Expr,
  segments: List<Ast.PostfixSegment>,
  state: ParseState,
) => {
  let tok = currentToken(state)
  match (tok.kind) {
    Lexer.LParen => {
      let (_, state1) = expectSimple(Lexer.LParen, state)
      let mut args = []
      let mut currentState = state1
      if (!kindIs(currentToken(currentState).kind, Lexer.RParen)) {
        let (arg, state_temp) = parseExpr(currentState)
        args = [arg, ...args]
        currentState = state_temp
        while (kindIs(currentToken(currentState).kind, Lexer.Comma)) {
          let (_, state_temp2) = expectSimple(Lexer.Comma, currentState)
          let (nextArg, state_temp3) = parseExpr(state_temp2)
          args = [nextArg, ...args]
          currentState = state_temp3
        }
      }
      let (rparenTok, state2) = expectSimple(Lexer.RParen, currentState)
      let segment = Call(List.reverse(args))
      let newSegments = [segment, ...segments]
      parsePostfix(target, newSegments, state2)
    },
    Lexer.Period => {
      let (_, state1) = expectSimple(Lexer.Period, state)
      let (name, nameTok, state2) = expectName(state1)
      let segment = Project(
        { node: { id: target.node.id, span: nameTok.span }, text: name },
      )
      let newSegments = [segment, ...segments]
      parsePostfix(target, newSegments, state2)
    },
    _ => {
      if (List.length(segments) == 0) {
        (target, state)
      } else {
        let postfix = Postfix({ target, segments: List.reverse(segments) })
        let newExpr = makeExpr(target.node.id, target.node.span, postfix)
        (newExpr, state)
      }
    },
  }
}
and parseTerm: Parser<Ast.Expr> = state => {
  let tok = currentToken(state)
  match (tok.kind) {
    Lexer.LBrace => parseBlock(state),
    _ => {
      let (expr, state1) = parsePrimary(state)
      parsePostfix(expr, [], state1)
    },
  }
}
//must support inner code
and parseBlock: Parser<Ast.Expr> = state => {
  let (id, state1) = freshId(state)
  let (_, state2) = expectSimple(Lexer.LBrace, state1)
  let (items, result, state3) = parseStatements(state2)
  let (rbraceTok, state4) = expectSimple(Lexer.RBrace, state3)
  let span = spanFromEnd(state4, rbraceTok)
  let expr = makeExpr(id, span, Block({ node: { id, span }, items, result }))
  (expr, state4)
}
and parsePrimary: Parser<Ast.Expr> = state => {
  let (id, state1) = freshId(state)
  let tok = currentToken(state1)

  match (tok.kind) {
    Lexer.LitNum(value) => {
      let state2 = dropToken(state1)
      let expr: Ast.Expr = makeExpr(id, tok.span, Lit(Ast.Int(value)))
      (expr, state2)
    },
    Lexer.LitString(value) => {
      let state2 = dropToken(state1)
      let expr: Ast.Expr = makeExpr(id, tok.span, Lit(Ast.Str(value)))
      (expr, state2)
    },
    Lexer.LitChar(value) => {
      let state2 = dropToken(state1)
      let expr: Ast.Expr = makeExpr(id, tok.span, Lit(Ast.Char(value)))
      (expr, state2)
    },
    Lexer.LitName(name) => {
      if (name == "match") {
        parseMatch(state1)
      } else if (name == "if") {
        parseIf(state1)
      } else {
        let state2 = dropToken(state1)
        let expr: Ast.Expr = makeExpr(
          id,
          tok.span,
          Ident({ node: { id, span: tok.span }, text: name })
        )
        (expr, state2)
      }
    },
    Lexer.ConstructorTok(name) => {
      let state1 = dropToken(state1)
      if (kindIs(currentToken(state1).kind, Lexer.LBrace)) {
        let (_, state2) = expectSimple(Lexer.LBrace, state1)
        let mut fields = []
        let mut currentState = state2
        while (!kindIs(currentToken(currentState).kind, Lexer.RBrace)) {
          if (kindIs(currentToken(currentState).kind, Lexer.Comma)) {
            let (_, state_temp) = expectSimple(Lexer.Comma, currentState)
            currentState = state_temp
          } else {
            let (fieldName, nameTok, state_temp) = expectName(currentState)
            let (fieldExpr, state_temp3) = if (
              kindIs(currentToken(state_temp).kind, Lexer.Eq)
            ) {
              let (_, state_temp2) = expectSimple(Lexer.Eq, state_temp)
              parseExpr(state_temp2)
            } else {
              (
                makeExpr(
                  id,
                  nameTok.span,
                  Ident({ node: { id, span: nameTok.span }, text: fieldName })
                ),
                state_temp,
              )
            }
            fields = [(fieldName, nameTok, fieldExpr), ...fields]
            currentState = state_temp3
            if (kindIs(currentToken(currentState).kind, Lexer.Comma)) {
              let (_, state_temp4) = expectSimple(Lexer.Comma, currentState)
              currentState = state_temp4
            }
          }
        }
        let (rbraceTok, state3) = expectSimple(Lexer.RBrace, currentState)
        let span = spanFromTokens(tok.span, rbraceTok.span)
        let reversedFields = List.reverse(fields)
        let rec buildFieldItems: (List<(String, Lexer.Token, Ast.Expr)>, Number) => List<
          Ast.RecordItem
        > = (items, currentId) => match (items) {
          [] => [],
          [(name, tok, expr), ...rest] => {
            let field = Field(
              { node: { id: currentId, span: tok.span }, text: name },
              expr,
            )
            [field, ...buildFieldItems(rest, currentId + 1)]
          },
        }
        let fieldItems = buildFieldItems(reversedFields, id + 1)
        let expr: Ast.Expr = makeExpr(id, span, RecordLit(fieldItems))
        (expr, state3)
      } else {
        let expr: Ast.Expr = makeExpr(
          id,
          tok.span,
          Ident({ node: { id, span: tok.span }, text: name })
        )
        (expr, state1)
      }
    },
    Lexer.LParen => {
      let (_, state2) = expectSimple(Lexer.LParen, state1)
      if (kindIs(currentToken(state2).kind, Lexer.RParen)) {
        let (rparenTok, state3) = expectSimple(Lexer.RParen, state2)
        let span = spanFromTokens(tok.span, rparenTok.span)
        let expr: Ast.Expr = makeExpr(id, span, Lit(Ast.Unit))
        (expr, state3)
      } else {
        let (inner, state3) = parseExpr(state2)
        if (kindIs(currentToken(state3).kind, Lexer.Comma)) {
          let mut exprs = [inner]
          let mut currentState = state3
          while (kindIs(currentToken(currentState).kind, Lexer.Comma)) {
            let (_, state_temp) = expectSimple(Lexer.Comma, currentState)
            let (nextExpr, state_next) = parseExpr(state_temp)
            exprs = [nextExpr, ...exprs]
            currentState = state_next
          }
          let (rparenTok, state4) = expectSimple(Lexer.RParen, currentState)
          let span = spanFromTokens(tok.span, rparenTok.span)
          let expr: Ast.Expr = makeExpr(id, span, Tuple(List.reverse(exprs)))
          (expr, state4)
        } else {
          let (rparenTok, state4) = expectSimple(Lexer.RParen, state3)
          let span = spanFromTokens(tok.span, rparenTok.span)
          let expr: Ast.Expr = makeExpr(id, span, Paren(inner))
          (expr, state4)
        }
      }
    },
    Lexer.Question => {
      let state2 = dropToken(state1)
      let expr: Ast.Expr = makeExpr(
        id,
        tok.span,
        Hole(
          { node: { id, span: tok.span }, kind: ExprHole, origin: UserTyped },
        )
      )
      (expr, state2)
    },
    Lexer.DotBrace => {
      let (_, state2) = expectSimple(Lexer.DotBrace, state1)
      let mut fields = []
      let mut currentState = state2
      while (!kindIs(currentToken(currentState).kind, Lexer.RBrace)) {
        if (kindIs(currentToken(currentState).kind, Lexer.Comma)) {
          // Skip leading/trailing commas
          let (_, state_temp) = expectSimple(Lexer.Comma, currentState)
          currentState = state_temp
        } else {
          let (fieldName, nameTok, state_temp) = expectName(currentState)
          let (fieldExpr, state_temp3) = if (
            kindIs(currentToken(state_temp).kind, Lexer.Eq)
          ) {
            let (_, state_temp2) = expectSimple(Lexer.Eq, state_temp)
            parseExpr(state_temp2)
          } else {
            (
              makeExpr(
                id,
                nameTok.span,
                Ident({ node: { id, span: nameTok.span }, text: fieldName })
              ),
              state_temp,
            )
          }
          fields = [(fieldName, nameTok, fieldExpr), ...fields]
          currentState = state_temp3
          if (kindIs(currentToken(currentState).kind, Lexer.Comma)) {
            let (_, state_temp4) = expectSimple(Lexer.Comma, currentState)
            currentState = state_temp4
          }
        }
      }
      let (rbraceTok, state3) = expectSimple(Lexer.RBrace, currentState)
      let span = spanFromTokens(tok.span, rbraceTok.span)
      let reversedFields = List.reverse(fields)
      let rec buildFieldItems: (List<(String, Lexer.Token, Ast.Expr)>, Number) => List<
        Ast.RecordItem
      > = (items, currentId) => match (items) {
        [] => [],
        [(name, tok, expr), ...rest] => {
          let field = Field(
            { node: { id: currentId, span: tok.span }, text: name },
            expr,
          )
          [field, ...buildFieldItems(rest, currentId + 1)]
        },
      }
      let fieldItems = buildFieldItems(reversedFields, id + 1)
      let expr: Ast.Expr = makeExpr(id, span, RecordLit(fieldItems))
      (expr, state3)
    },
    Lexer.FatArrow => {
      let state2 = dropToken(state1)
      let (bodyExpr, state3) = parseExpr(state2)
      let body = match (bodyExpr.kind) {
        Block(b) => b,
        _ => panic("lambda body must be block"),
      }
      let span = spanFromTokens(tok.span, bodyExpr.node.span)
      let pat = {
        node: { id, span: tok.span },
        kind: Wildcard,
        attach: { leading: [], trailing: [], dangling: [] },
      }: Ast.Pattern 
      let expr = makeExpr(id, span, Lambda(pat, body))
      (expr, state3)
    },
    _ => {
      print(tok.kind)
      Panic.panic(
        "Parse error: expected expression, tok: "
          ++ Lexer.tokenKindToString(tok.kind)
      )
    },
  }
}
and parseIf = (state: ParseState) => {
  let (id, state1) = freshId(state)
  let (ifTok, state2) = expectKeyword("if", state)
  let (cond, state3) = parseExpr(state2)
  let (thenExpr, state4) = parseExpr(state3)
  let (elseExpr, state5) = if (
    kindIs(currentToken(state4).kind, Lexer.LitName("else"))
  ) {
    let (_, state_temp) = expectKeyword("else", state4)
    let (expr, state_temp2) = parseExpr(state_temp)
    (Some(expr), state_temp2)
  } else {
    (None, state4)
  }
  let endSpan = match (elseExpr) {
    Some(e) => e.node.span,
    None => thenExpr.node.span,
  }
  let span = spanFromTokens(ifTok.span, endSpan)
  let expr = makeExpr(id, span, Ast.If(cond, thenExpr, elseExpr))
  (expr, state5)
}
and parseTopLevels = (state: ParseState) => {
  let tok = currentToken(state)
  //print(tok)
  match (tok.kind) {
    Lexer.EOF => ([], state),
    Lexer.SemiColon => {
      // Skip semicolons
      let state1 = dropToken(state)
      parseTopLevels(state1)
    },
    Lexer.LitName(name) when name == "let" => {
      let (group, state1) = parseLetGroup(state)
      let (rest, state2) = parseTopLevels(state1)
      ([group, ...rest], state2)
    },
    Lexer.LitName(name) when name == "export" => {
      let state1 = dropToken(state)
      let (inner, state2) = parseTopLevels(state1)
      match (inner) {
        [DeclGroup(dg), ...rest] => {
          let exportedDg = { ...dg, exported: true }
          ([DeclGroup(exportedDg), ...rest], state2)
        },
        [] => panic("Expected something after export"),
        [first, ...rest] => panic("Export can only be applied to declarations"),
      }
    },
    Lexer.LitName(name) when name == "type" => {
      let (typeDef, state1) = parseTypeDef(state)
      let (rest, state2) = parseTopLevels(state1)
      ([typeDef, ...rest], state2)
    },
    Lexer.LitName(name) when name == "record" => {
      let (typeDef, state1) = parseRecordDef(state)
      let (rest, state2) = parseTopLevels(state1)
      ([typeDef, ...rest], state2)
    },
    _ =>
      panic(
        "Unknown top-level construct: " ++ Lexer.tokenKindToString(tok.kind)
      ),
  }
}
and parseBinding = (state: ParseState) => {
  let (id, state1) = freshId(state)
  let (pattern, state2) = parsePattern(state1)
  //Optionally parse type annotation after ':'
  let (typeOpt, state3) = if (kindIs(currentToken(state2).kind, Lexer.Colon)) {
    let (_, state_temp) = expectSimple(Lexer.Colon, state2)
    // Parse type tokens until '=' (approximate, like TypeDef)
    let rec parseType = (accumulator, state) => {
      let tok = currentToken(state)
      if (kindIs(tok.kind, Lexer.Eq)) {
        (Some(accumulator), state)
      } else {
        parseType(accumulator ++ " " ++ toString(tok.kind), dropToken(state))
      }
    }
    parseType("", state_temp)
  } else {
    (None, state2)
  }
  let (_, state4) = expectSimple(Lexer.Eq, state3)
  let (value, state5): (Ast.Expr, ParseState) = parseExpr(state4)
  let span = spanFromTokens(pattern.node.span, value.node.span)
  let binding: Ast.LetBinding = {
    node: { id, span },
    name: pattern,
    annotation: None,
    value,
  }
  (binding, state5)
}
and parseLetMods: ParseState => (Ast.LetGroupMods, ParseState) = state => {
  let tok = currentToken(state)
  if (kindIs(tok.kind, Lexer.LitName("rec"))) {
    let state1 = dropToken(state)
    (Ast.Rec, state1)
  } else if (kindIs(tok.kind, Lexer.LitName("mut"))) {
    let state1 = dropToken(state)
    (Ast.Mut, state1)
  } else {
    (Ast.Rec, state)
  }
}
and parseLetGroup: ParseState => (Ast.TopItem, ParseState) = state => {
  let (id, state1) = freshId(state)
  let (letTok, state2) = expectKeyword("let", state1)
  let (mods, state3) = parseLetMods(state2)
  let (firstBinding, state4) = parseBinding(state3)
  let mut bindings = [firstBinding]
  let mut currentState = state4
  while (kindIs(currentToken(currentState).kind, Lexer.LitName("and"))) {
    let (_, state_temp) = expectKeyword("and", currentState)
    let (binding, state_temp2) = parseBinding(state_temp)
    bindings = [binding, ...bindings]
    currentState = state_temp2
  }
  let reversedBindings = List.reverse(bindings)
  let lastBinding = match (List.head(reversedBindings)) {
    Some(b) => b,
    None => panic("Bindings list should not be empty"),
  }
  let span = spanFromTokens(letTok.span, lastBinding.node.span)
  let topLevel = DeclGroup(
    {
      node: { id, span },
      exported: false,
      kind: LetGroup(mods),
      decls: [LetDecl({ node: { id, span }, bindings: reversedBindings })],
    },
  )
  (topLevel, currentState)
}
and parseTypeDef: ParseState => (Ast.TopItem, ParseState) = state => {
  let (id, state1) = freshId(state)
  let (typeTok, state2) = expectKeyword("type", state1)
  let (name, _, state3) = expectConstructor(state2)
  let (_, state4) = expectSimple(Lexer.Eq, state3)
  // Simple: parse until ;
  let rec parseDef = (accumulator, state) => {
    let tok = currentToken(state)
    match (tok.kind) {
      Lexer.SemiColon => (accumulator, dropToken(state)),
      Lexer.EOF => (accumulator, state),
      _ => parseDef(accumulator ++ " " ++ toString(tok.kind), dropToken(state)), // approximate
    }
  }
  let (def, state5) = parseDef("", state4)
  let topLevel = DeclGroup(
    {
      node: { id, span: typeTok.span },
      exported: false,
      kind: TypeGroup(Rec),
      decls: [
        TypeDecl(
          {
            node: { id, span: typeTok.span },
            name: { node: { id, span: typeTok.span }, text: name },
            infection: None,
            typeParams: [],
            body: Alias(
              {
                node: { id, span: typeTok.span },
                kind: Hole(
                  {
                    node: { id, span: typeTok.span },
                    kind: TypeHole,
                    origin: UserTyped,
                  },
                ),
                attach: { leading: [], trailing: [], dangling: [] },
              }: TypeExpr,
            ),
          },
        ),
      ],
    },
  )
  (topLevel, state5)
}
and parseRecordDef = (state: ParseState) => {
  let (id, state1) = freshId(state)
  let (recordTok, state2) = expectKeyword("record", state1) // Expect "record" keyword
  let (name, _, state3) = expectConstructor(state2) // Expect the record name (e.g., MyRecord)
  let (_, state4) = expectSimple(Lexer.Eq, state3) // Expect =
  // Simple: parse until ; (same as type for now; customize if record syntax differs)
  let rec parseDef = (accumulator, state) => {
    let tok = currentToken(state)
    match (tok.kind) {
      Lexer.SemiColon => (accumulator, dropToken(state)),
      Lexer.EOF => (accumulator, state),
      _ => parseDef(accumulator ++ " " ++ toString(tok.kind), dropToken(state)), // approximate
    }
  }
  let (def, state5) = parseDef("", state4)
  let topLevel = DeclGroup(
    {
      node: { id, span: recordTok.span },
      exported: false,
      kind: RecordGroup(Rec),
      decls: [
        RecordDecl(
          {
            node: { id, span: recordTok.span },
            name: { node: { id, span: recordTok.span }, text: name },
            typeParams: [],
            fields: [],
          },
        ),
      ],
    },
  )
  (topLevel, state5)
}
and parseStatements = (state: ParseState) => {
  let tok = currentToken(state)
  match (tok.kind) {
    Lexer.RBrace => ([], [], state),
    Lexer.SemiColon => parseStatements(dropToken(state)),
    Lexer.LitName("let") => {
      let (_, state_temp) = expectKeyword("let", state)
      let (binding, state1) = parseBinding(state_temp)
      let (id, state2) = freshId(state1)
      let stmt = {
        node: { id, span: binding.node.span },
        kind: Let(binding),
        attach: { leading: [], trailing: [], dangling: [] },
      }: Stmt
      let item = Stmt(stmt)
      let (restItems, result, state3) = parseStatements(state2)
      ([item, ...restItems], result, state3)
    },
    _ => {
      let (expr, state1) = parseExpr(state)
      let (restItems, restResult, state2) = parseStatements(state1)
      ([], [expr, ...restResult], state2)
    },
  }
}
and parsePattern: Parser<Ast.Pattern> = state => {
  let tok = currentToken(state)
  match (tok.kind) {
    Lexer.LitName("_") => {
      let state1 = dropToken(state)
      let node = { id: 0, span: tok.span }
      let attach = { leading: [], trailing: [], dangling: [] }
      let kind: Ast.PatternKind = Ast.Wildcard
      let pat: Ast.Pattern = { node, kind, attach }
      (pat, state1)
    },
    Lexer.LitName(name) => {
      let state1 = dropToken(state)
      let node = { id: 0, span: tok.span }
      let attach = { leading: [], trailing: [], dangling: [] }
      let nameNode = { node: { id: 0, span: tok.span }, text: name }
      let kind: Ast.PatternKind = Ast.Var(nameNode)
      let pat: Ast.Pattern = { node, kind, attach }
      (pat, state1)
    },
    Lexer.ConstructorTok(name) => {
      let state1 = dropToken(state)
      if (kindIs(currentToken(state1).kind, Lexer.LParen)) {
        let (_, state2) = expectSimple(Lexer.LParen, state1)
        let mut args = []
        let mut currentState = state2
        if (!kindIs(currentToken(currentState).kind, Lexer.RParen)) {
          let (arg, state_temp) = parsePattern(currentState)
          args = [arg, ...args]
          currentState = state_temp
          while (kindIs(currentToken(currentState).kind, Lexer.Comma)) {
            let (_, state_temp2) = expectSimple(Lexer.Comma, currentState)
            let (nextArg, state_temp3) = parsePattern(state_temp2)
            args = [nextArg, ...args]
            currentState = state_temp3
          }
        }
        let (_, state3) = expectSimple(Lexer.RParen, currentState)
        let node = { id: 0, span: tok.span }
        let attach = { leading: [], trailing: [], dangling: [] }
        let nameNode = { node: { id: 0, span: tok.span }, text: name }
        let kind: Ast.PatternKind = Ast.Constructor(
          nameNode,
          List.reverse(args),
        )
        let pat: Ast.Pattern = { node, kind, attach }
        (pat, state3)
      } else {
        let node = { id: 0, span: tok.span }
        let attach = { leading: [], trailing: [], dangling: [] }
        let nameNode = { node: { id: 0, span: tok.span }, text: name }
        let kind: Ast.PatternKind = Ast.Constructor(nameNode, [])
        let pat: Ast.Pattern = { node, kind, attach }
        (pat, state1)
      }
    },
    Lexer.LParen => {
      let (_, state1) = expectSimple(Lexer.LParen, state)
      let (innerPat, state2) = parsePattern(state1)
      if (kindIs(currentToken(state2).kind, Lexer.Comma)) {
        let mut pats = [innerPat]
        let mut currentState = state2
        while (kindIs(currentToken(currentState).kind, Lexer.Comma)) {
          let (_, state_temp) = expectSimple(Lexer.Comma, currentState)
          let (nextPat, state_next) = parsePattern(state_temp)
          pats = [nextPat, ...pats]
          currentState = state_next
        }
        let (_, state3) = expectSimple(Lexer.RParen, currentState)
        let node = { id: 0, span: Source.makeSpan(0, 0, 0, 0) } // fix span
        let attach = { leading: [], trailing: [], dangling: [] }
        let kind: Ast.PatternKind = Ast.Tuple(List.reverse(pats))
        let pat: Ast.Pattern = { node, kind, attach }
        (pat, state3)
      } else {
        let (_, state3) = expectSimple(Lexer.RParen, state2)
        (innerPat, state3)
      }
    },
    _ => panic("expected pattern"),
  }
}
and parseMatch = (state: ParseState) => {
  let (id, state1) = freshId(state)
  let (matchTok, state2) = expectKeyword("match", state)
  let (scrutinee, state3) = parseExpr(state2)
  let (_, state4) = expectSimple(Lexer.LBrace, state3)
  let mut items: List<Ast.BundleItem> = []
  let mut currentState = state4
  while (!kindIs(currentToken(currentState).kind, Lexer.RBrace)) {
    let (pat, state_temp) = parsePattern(currentState)
    let (_, state_temp2) = expectSimple(Lexer.FatArrow, state_temp)
    let (blockExpr, state_temp3) = parseBlock(state_temp2)
    let block: Ast.Block = match (blockExpr.kind) {
      Block(b) => b,
      _ => panic("Expected block after =>"),
    }
    let caseKind: Ast.BundleItemKind = Ast.Case(pat, None, block)
    let caseItem: Ast.BundleItem = {
      node: { id: 0, span: Source.makeSpan(0, 0, 0, 0) },
      kind: caseKind,
      attach: { leading: [], trailing: [], dangling: [] },
    }
    items = [caseItem, ...items]
    if (kindIs(currentToken(state_temp3).kind, Lexer.Comma)) {
      let (_, state_temp4) = expectSimple(Lexer.Comma, state_temp3)
      currentState = state_temp4
    } else {
      currentState = state_temp3
    }
  }
  let (rbraceTok, state5) = expectSimple(Lexer.RBrace, currentState)
  let bundleLit = {
    node: { id, span: Source.makeSpan(0, 0, 0, 0) },
    items: List.reverse(items),
  }
  let bundleKind: Ast.BundleExprKind = Ast.Literal(bundleLit)
  let bundle: Ast.BundleExpr = {
    node: { id, span: Source.makeSpan(0, 0, 0, 0) },
    kind: bundleKind,
    attach: { leading: [], trailing: [], dangling: [] },
  }
  let matchApply = {
    node: { id, span: Source.makeSpan(0, 0, 0, 0) },
    scrutinees: [scrutinee],
    bundle,
  }
  let span = spanFromTokens(matchTok.span, rbraceTok.span)
  let expr = makeExpr(id, span, MatchApply(matchApply))
  (expr, state5)
}

provide let parse = (source: String) => {
  let tokens = Lexer.lex(source)
  let initial: ParseState = { tokens, nextId: 1, allTokens: tokens }
  let (topLevels, _finalState) = parseTopLevels(initial)
  let program: Ast.Program = { items: topLevels, core: false }
  program
}

parse(testStr)
