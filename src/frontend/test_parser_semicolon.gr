module TestParserSemicolon

from "list" include List
from "runtime/unsafe/panic" include Panic
use Panic.{ panic }
from "../core/surface_ast.gr" include SurfaceAst
use SurfaceAst.*
from "./parser.gr" include Parser

let assertOk = (cond: Bool, message: String) => {
  if (!cond) {
    panic(message)
  } else {
    void
  }
}

let main = () => {
  let source = "let a = 1\nlet b = 2;"
  let tolerantResult = Parser.parseResult(source)
  assertOk(
    List.length(tolerantResult.missingSemicolons) == 1,
    "expected one recovered top-level semicolon",
  )

  let blockSource = "let x = { let y = 1 y };"
  let tolerantBlock = Parser.parseResult(blockSource)
  assertOk(
    List.length(tolerantBlock.missingSemicolons) == 1,
    "expected one recovered block semicolon",
  )

  let exprStmtSource = "let x = { 1 let y = 2; y };"
  let tolerantExprStmt = Parser.parseResult(exprStmtSource)
  assertOk(
    List.length(tolerantExprStmt.missingSemicolons) == 1,
    "expected one recovered semicolon between expression statement and let",
  )

  let missingEq = Parser.parseResult("let a;")
  assertOk(
    List.length(missingEq.missingSemicolons) == 0,
    "expected tolerant parse to recover missing '=' in let binding",
  )

  let missingRhs = Parser.parseResult("let x = { y = ; y };")
  assertOk(
    List.length(missingRhs.missingSemicolons) == 0,
    "expected tolerant parse to recover missing assignment rhs",
  )

  let missingParen = Parser.parseResult("let x = (1 + 2;")
  assertOk(
    List.length(missingParen.missingSemicolons) == 0,
    "expected tolerant parse to recover missing ')'",
  )

  let missingBrace = Parser.parseResult("let x = { let y = 1;")
  assertOk(
    List.length(missingBrace.missingSemicolons) == 0,
    "expected tolerant parse to recover missing '}'",
  )

  let unknownTopLevel = Parser.parseResult("oops ; let ok = 1;")
  assertOk(
    List.length(unknownTopLevel.missingSemicolons) == 0,
    "expected tolerant parse to skip unknown top-level tokens",
  )

  let foldedSource = "let x = { let y = 1; y };"
  let foldedProgram = Parser.parse(foldedSource)
  let foldedOk = match (foldedProgram.items) {
    [SurfaceAst.DeclGroup(dg)] => match (dg.decls) {
      [SurfaceAst.LetDecl(ld)] => match (ld.bindings) {
        [binding] => match (binding.value.kind) {
          SurfaceAst.Block(block) => match (block.body.kind) {
            SurfaceAst.Let(letBinding, letBody) =>
              match ((letBinding.value.kind, letBody.kind)) {
                (SurfaceAst.Lit(SurfaceAst.Int(1)), SurfaceAst.Ident({ _, text })) when text == "y" => true,
                _ => false,
              },
            _ => false,
          },
          _ => false,
        },
        _ => false,
      },
      _ => false,
    },
    _ => false,
  }
  assertOk(
    foldedOk,
    "expected block body to fold into Let(binding, body)",
  )

  let seqSource = "let x = (1; 2);"
  let seqProgram = Parser.parse(seqSource)
  let seqOk = match (seqProgram.items) {
    [SurfaceAst.DeclGroup(dg)] => match (dg.decls) {
      [SurfaceAst.LetDecl(ld)] => match (ld.bindings) {
        [binding] => match (binding.value.kind) {
          SurfaceAst.Seq(items) =>
            match (items) {
              [
                { kind: SurfaceAst.Lit(SurfaceAst.Int(1)), _ },
                { kind: SurfaceAst.Lit(SurfaceAst.Int(2)), _ },
              ] => true,
              _ => false,
            },
          _ => false,
        },
        _ => false,
      },
      _ => false,
    },
    _ => false,
  }
  assertOk(
    seqOk,
    "expected top-level ';' to parse as sequencing in let RHS",
  )

  print("parser semicolon Mark test passed")
}

main()
