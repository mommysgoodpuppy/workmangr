module Lower

from "../core/surface_ast.gr" include SurfaceAst
from "../core/core_ast.gr" include CoreAst
from "char" include Char
from "list" include List
from "string" include String
from "../core/error.gr" include Error

let lowerNode = (node: SurfaceAst.Node) =>
  { id: node.id, span: node.span }: CoreAst.Node

let lowerName = (name: SurfaceAst.Name) =>
  { node: lowerNode(name.node), text: name.text }: CoreAst.Name

let lowerHole = (hole: SurfaceAst.Hole) =>
  {
    node: lowerNode(hole.node),
    kind: match (hole.kind) {
      SurfaceAst.ExprHole => CoreAst.ExprHole,
      SurfaceAst.TypeHole => CoreAst.TypeHole,
      SurfaceAst.PatternHole => CoreAst.PatternHole,
      SurfaceAst.NameHole => CoreAst.NameHole,
    },
    origin: match (hole.origin) {
      SurfaceAst.UserTyped => CoreAst.UserTyped,
      SurfaceAst.Inferred => CoreAst.Inferred,
    },
  }: CoreAst.Hole

let lowerAtomLiteral = (lit: SurfaceAst.AtomLiteral) => match (lit) {
  SurfaceAst.Int(n) => CoreAst.Int(n),
  SurfaceAst.Bool(b) => CoreAst.Bool(b),
  SurfaceAst.Char(c) => CoreAst.Char(c),
  SurfaceAst.Str(s) => CoreAst.Str(s),
  SurfaceAst.Byte(n) => CoreAst.Byte(n),
  SurfaceAst.Unit => CoreAst.Unit,
}

let mapOption = (opt, fn) => match (opt) {
  None => None,
  Some(value) => Some(fn(value)),
}

let makeExpr = (node: SurfaceAst.Node, kind: CoreAst.ExprKind) =>
  { node: lowerNode(node), kind }: CoreAst.Expr

let makeIdentExpr = (node: SurfaceAst.Node, text: String) => {
  let name: CoreAst.Name = { node: lowerNode(node), text }
  makeExpr(node, CoreAst.Ident(name))
}

let isLikelyModuleQualifier = (text: String) => {
  if (String.length(text) == 0) {
    false
  } else {
    let first = String.charAt(0, text)
    first == 'A'
      || first == 'B'
      || first == 'C'
      || first == 'D'
      || first == 'E'
      || first == 'F'
      || first == 'G'
      || first == 'H'
      || first == 'I'
      || first == 'J'
      || first == 'K'
      || first == 'L'
      || first == 'M'
      || first == 'N'
      || first == 'O'
      || first == 'P'
      || first == 'Q'
      || first == 'R'
      || first == 'S'
      || first == 'T'
      || first == 'U'
      || first == 'V'
      || first == 'W'
      || first == 'X'
      || first == 'Y'
      || first == 'Z'
  }
}

let makeUnitExpr = (node: SurfaceAst.Node) =>
  makeExpr(node, CoreAst.Lit(CoreAst.Unit))

let makeTupleExpr = (node: SurfaceAst.Node, exprs: List<CoreAst.Expr>) =>
  makeExpr(node, CoreAst.Tuple(exprs))

let makeWildcardPattern = (node: SurfaceAst.Node) =>
  { node: lowerNode(node), kind: CoreAst.Wildcard, resolvedConstructor: None }:
    CoreAst.Pattern

let rec lowerPattern = (pattern: SurfaceAst.Pattern) => {
  let lowered: (CoreAst.PatternKind, Option<CoreAst.Name>) = match (
    pattern.kind
  ) {
    SurfaceAst.Hole(hole) => (CoreAst.Hole(lowerHole(hole)), None),
    SurfaceAst.Wildcard => (CoreAst.Wildcard, None),
    SurfaceAst.Var(name) => (CoreAst.Var(lowerName(name)), None),
    SurfaceAst.Pin(name) => (CoreAst.Pin(lowerName(name)), None),
    SurfaceAst.Lit(lit) => (CoreAst.Lit(lowerAtomLiteral(lit)), None),
    SurfaceAst.Constructor(name, args) => {
      let loweredName = lowerName(name)
      let loweredArgs = List.map(lowerPattern, args)
      (CoreAst.Constructor(loweredName, loweredArgs), Some(loweredName))
    },
    SurfaceAst.Tuple(items) =>
      (CoreAst.Tuple(List.map(lowerPattern, items)), None),
    SurfaceAst.List(items, rest) =>
      (
        CoreAst.List(
          List.map(lowerPattern, items),
          mapOption(rest, lowerPattern),
        ),
        None,
      ),
    SurfaceAst.AllErrors => (CoreAst.AllErrors, None),
  }
  let (kind, resolvedConstructor) = lowered
  { node: lowerNode(pattern.node), kind, resolvedConstructor }: CoreAst.Pattern
}

let rec lowerTypeExpr = (typeExpr: SurfaceAst.TypeExpr) => {
  let kind: CoreAst.TypeExprKind = match (typeExpr.kind) {
    SurfaceAst.Hole(hole) => CoreAst.Hole(lowerHole(hole)),
    SurfaceAst.Var(name) => CoreAst.Var(lowerName(name)),
    SurfaceAst.Ref(name, args) =>
      CoreAst.Ref(lowerName(name), List.map(lowerTypeExpr, args)),
    SurfaceAst.Tuple(items) => CoreAst.Tuple(List.map(lowerTypeExpr, items)),
    SurfaceAst.Record(fields) =>
      CoreAst.Record(
        List.map(((name, t)) => (lowerName(name), lowerTypeExpr(t)), fields),
      ),
    SurfaceAst.Arrow(params, result) =>
      CoreAst.Arrow(List.map(lowerTypeExpr, params), lowerTypeExpr(result)),
    SurfaceAst.Ptr(inner, stateOpt) =>
      CoreAst.Ptr(lowerTypeExpr(inner), mapOption(stateOpt, lowerName)),
    SurfaceAst.EffectRow(cases, hasTail) =>
      CoreAst.EffectRow(
        List.map(
          (effectCase: SurfaceAst.EffectCase) =>
            {
              node: lowerNode(effectCase.node),
              name: lowerName(effectCase.name),
              payload: mapOption(effectCase.payload, lowerTypeExpr),
            }: CoreAst.EffectCase,
          cases
        ),
        hasTail,
      ),
    SurfaceAst.UnitType => CoreAst.UnitType,
  }
  { node: lowerNode(typeExpr.node), kind }: CoreAst.TypeExpr
}

let rec exprToPattern = (expr: SurfaceAst.Expr) => {
  match (expr.kind) {
    SurfaceAst.Ident({ text, _ }) when text == "_" => {
      {
        node: expr.node,
        kind: SurfaceAst.Wildcard,
        attach: { leading: [], trailing: [], dangling: [] },
      }: SurfaceAst.Pattern
    },
    SurfaceAst.Ident(name) => {
      {
        node: expr.node,
        kind: SurfaceAst.Var(name),
        attach: { leading: [], trailing: [], dangling: [] },
      }: SurfaceAst.Pattern
    },
    SurfaceAst.Paren(inner) => exprToPattern(inner),
    SurfaceAst.Tuple(exprs) => {
      let rec convert = (es: List<SurfaceAst.Expr>) => {
        match (es) {
          [] => [],
          [head, ...tail] => [exprToPattern(head), ...convert(tail)],
        }
      }
      {
        node: expr.node,
        kind: SurfaceAst.Tuple(convert(exprs)),
        attach: { leading: [], trailing: [], dangling: [] },
      }: SurfaceAst.Pattern
    },
    SurfaceAst.Lit(lit) => {
      {
        node: expr.node,
        kind: SurfaceAst.Lit(lit),
        attach: { leading: [], trailing: [], dangling: [] },
      }: SurfaceAst.Pattern
    },
    SurfaceAst.RecordLit(_) =>
      Error.createPanicError(
        Error.Lowering,
        expr.node.span,
        "Record patterns are not supported",
        [],
        severity=Error.SError
      ),
    SurfaceAst.Postfix(postfix) => {
      match (postfix.target.kind) {
        SurfaceAst.Ident(name) => {
          match (postfix.segments) {
            [SurfaceAst.Call(args)] => {
              let rec convertArgs = (es: List<SurfaceAst.Expr>) => {
                match (es) {
                  [] => [],
                  [head, ...tail] =>
                    [exprToPattern(head), ...convertArgs(tail)],
                }
              }
              {
                node: expr.node,
                kind: SurfaceAst.Constructor(name, convertArgs(args)),
                attach: { leading: [], trailing: [], dangling: [] },
              }: SurfaceAst.Pattern
            },
            _ =>
              Error.createPanicError(
                Error.Lowering,
                expr.node.span,
                "Unsupported postfix segments in => clause",
                [],
                severity=Error.SError
              ),
          }
        },
        _ =>
          Error.createPanicError(
            Error.Lowering,
            expr.node.span,
            "Unsupported postfix target in => clause",
            [],
            severity=Error.SError
          ),
      }
    },
  }
}

let rec lowerRecordItem = (item: SurfaceAst.RecordItem) => match (item) {
  SurfaceAst.Field(name, value) =>
    CoreAst.Field(lowerName(name), lowerExpr(value)),
  SurfaceAst.Spread(value) => CoreAst.Spread(lowerExpr(value)),
}
and lowerLetBinding = (binding: SurfaceAst.LetBinding) =>
  {
    node: lowerNode(binding.node),
    name: lowerPattern(binding.name),
    annotation: mapOption(binding.annotation, lowerTypeExpr),
    value: lowerExpr(binding.value),
  }: CoreAst.LetBinding
and lowerFnClause = (clause: SurfaceAst.FnClause) => {
  let guard = match (clause.guard) {
    None => None,
    Some(g) => Some(lowerExpr(g)),
  }
  let loweredBody = lowerExpr(clause.body.body)
  let loweredParam = lowerPattern(clause.param)
  {
    node: lowerNode(clause.node),
    param: loweredParam,
    guard,
    matchConstructor: loweredParam.resolvedConstructor,
    body: loweredBody,
  }: CoreAst.FnClause
}
and lowerFnExpr = (fnExpr: SurfaceAst.FnExpr) => {
  let items = List.filterMap(
    (item: SurfaceAst.FnItem) => match (item.kind) {
      SurfaceAst.Clause(clause) =>
        Some(
          {
            node: lowerNode(item.node),
            kind: CoreAst.Clause(lowerFnClause(clause)),
          }: CoreAst.FnItem,
        ),
      SurfaceAst.Include(name) =>
        Some(
          { node: lowerNode(item.node), kind: CoreAst.Include(lowerName(name)) }:
            CoreAst.FnItem,
        ),
      SurfaceAst.Hole(hole) =>
        Some(
          { node: lowerNode(item.node), kind: CoreAst.Hole(lowerHole(hole)) }:
            CoreAst.FnItem,
        ),
      SurfaceAst.Trivia(_) => None,
    },
    fnExpr.items
  )
  { node: lowerNode(fnExpr.node), items }: CoreAst.FnExpr
}
and normalizeCallArgs = (node: SurfaceAst.Node, args: List<CoreAst.Expr>) => {
  match (args) {
    [] => makeUnitExpr(node),
    [only] => only,
    _ => makeTupleExpr(node, args),
  }
}
and prependArg = (
  node: SurfaceAst.Node,
  firstArg: CoreAst.Expr,
  argExpr: CoreAst.Expr,
) => {
  match (argExpr.kind) {
    CoreAst.Tuple(items) => makeTupleExpr(node, [firstArg, ...items]),
    _ => makeTupleExpr(node, [firstArg, argExpr]),
  }
}
and apply2 = (
  node: SurfaceAst.Node,
  callee: CoreAst.Expr,
  arg1: CoreAst.Expr,
  arg2: CoreAst.Expr,
) => {
  let applied1 = makeExpr(node, CoreAst.Apply(callee, arg1))
  makeExpr(node, CoreAst.Apply(applied1, arg2))
}
and lowerPostfix = (node: SurfaceAst.Node, pf: SurfaceAst.Postfix) => {
  let loweredTarget = lowerExpr(pf.target)
  let rec fold = (
    currentExpr: CoreAst.Expr,
    segments: List<SurfaceAst.PostfixSegment>,
  ) => {
    match (segments) {
      [] => currentExpr,
      [SurfaceAst.Call(args), ...rest] => {
        let loweredArgs = List.map(lowerExpr, args)
        let argExpr = normalizeCallArgs(node, loweredArgs)
        let applied = makeExpr(node, CoreAst.Apply(currentExpr, argExpr))
        fold(applied, rest)
      },
      [SurfaceAst.Project(name), ...rest] => {
        match (currentExpr.kind) {
          // Module-style qualification: List.at => Ident("List.at")
          // Record projection remains `project(recordExpr, "field")`.
          CoreAst.Ident(base) when isLikelyModuleQualifier(base.text) => {
            let qualifiedName = {
              node: lowerNode(name.node),
              text: base.text ++ "." ++ name.text,
            }: CoreAst.Name
            let qualifiedExpr = makeExpr(node, CoreAst.Ident(qualifiedName))
            fold(qualifiedExpr, rest)
          },
          _ => {
            let projectFn = makeIdentExpr(node, "project")
            let fieldExpr = makeExpr(name.node, CoreAst.Lit(CoreAst.Str(name.text)))
            let applied = apply2(node, projectFn, currentExpr, fieldExpr)
            fold(applied, rest)
          },
        }
      },
      [SurfaceAst.Index(ix), ...rest] => {
        let indexFn = makeIdentExpr(node, "index")
        let ixExpr = lowerExpr(ix)
        let applied = apply2(node, indexFn, currentExpr, ixExpr)
        fold(applied, rest)
      },
    }
  }
  fold(loweredTarget, pf.segments)
}
and lowerArrow = (
  exprNode: SurfaceAst.Node,
  lhs: SurfaceAst.Expr,
  rhs: SurfaceAst.Expr,
) => {
  let paramPattern = exprToPattern(lhs)
  let loweredRhs = lowerExpr(rhs)
  let loweredParam = lowerPattern(paramPattern)
  let clause: CoreAst.FnClause = {
    node: lowerNode(exprNode),
    param: loweredParam,
    guard: None,
    matchConstructor: loweredParam.resolvedConstructor,
    body: loweredRhs,
  }
  let item: CoreAst.FnItem = {
    node: lowerNode(exprNode),
    kind: CoreAst.Clause(clause),
  }
  let fnExpr: CoreAst.FnExpr = { node: lowerNode(exprNode), items: [item] }
  makeExpr(exprNode, CoreAst.Fn(fnExpr))
}
and lowerPipe = (
  exprNode: SurfaceAst.Node,
  lhs: SurfaceAst.Expr,
  rhs: SurfaceAst.Expr,
) => {
  let loweredLhs = lowerExpr(lhs)
  let loweredRhs = lowerExpr(rhs)
  match (loweredRhs.kind) {
    CoreAst.Apply(callee, arg) => {
      let combinedArg = prependArg(exprNode, loweredLhs, arg)
      makeExpr(exprNode, CoreAst.Apply(callee, combinedArg))
    },
    _ => makeExpr(exprNode, CoreAst.Apply(loweredRhs, loweredLhs)),
  }
}
and lowerMatchExpr = (exprNode: SurfaceAst.Node, m: SurfaceAst.MatchExpr) => {
  let loweredBundle = lowerFnExpr(m.bundle)
  let bundleExpr = makeExpr(m.bundle.node, CoreAst.Fn(loweredBundle))
  match ((m.scrutinee, m.arrowSugar)) {
    (None, false) => makeExpr(exprNode, CoreAst.Fn(loweredBundle)),
    (Some(scrutinee), false) => {
      let loweredScrutinee = lowerExpr(scrutinee)
      makeExpr(exprNode, CoreAst.Apply(bundleExpr, loweredScrutinee))
    },
    (Some(scrutinee), true) => {
      let loweredScrutinee = lowerExpr(scrutinee)
      let param = exprToPattern(scrutinee)
      let loweredParam = lowerPattern(param)
      let innerApply = makeExpr(
        exprNode,
        CoreAst.Apply(bundleExpr, loweredScrutinee)
      )
      let clause: CoreAst.FnClause = {
        node: lowerNode(exprNode),
        param: loweredParam,
        guard: None,
        matchConstructor: loweredParam.resolvedConstructor,
        body: innerApply,
      }
      let item: CoreAst.FnItem = {
        node: lowerNode(exprNode),
        kind: CoreAst.Clause(clause),
      }
      let fnExpr: CoreAst.FnExpr = { node: lowerNode(exprNode), items: [item] }
      makeExpr(exprNode, CoreAst.Fn(fnExpr))
    },
    _ =>
      Error.createPanicError(
        Error.Lowering,
        exprNode.span,
        "invalid match arrow shape",
        [],
        severity=Error.SError
      ),
  }
}
and lowerAssignExpr = (exprNode: SurfaceAst.Node, asg: SurfaceAst.AssignExpr) => {
  let assignFn = makeIdentExpr(exprNode, "assign")
  let target = lowerExpr(asg.target)
  let value = lowerExpr(asg.value)
  let arg = makeTupleExpr(exprNode, [target, value])
  makeExpr(exprNode, CoreAst.Apply(assignFn, arg))
}
and lowerSeqExpr = (exprNode: SurfaceAst.Node, items: List<SurfaceAst.Expr>) => {
  let rec fold = (rest: List<SurfaceAst.Expr>) => {
    match (rest) {
      [] => makeUnitExpr(exprNode),
      [only] => lowerExpr(only),
      [head, ...tail] => {
        let binding: CoreAst.LetBinding = {
          node: lowerNode(head.node),
          name: makeWildcardPattern(head.node),
          annotation: None,
          value: lowerExpr(head),
        }
        let body = fold(tail)
        makeExpr(exprNode, CoreAst.Let(binding, body))
      },
    }
  }
  fold(items)
}
and lowerExpr = (expr: SurfaceAst.Expr) => {
  match (expr.kind: SurfaceAst.ExprKind) {
    SurfaceAst.Lit(lit) =>
      makeExpr(expr.node, CoreAst.Lit(lowerAtomLiteral(lit))),
    SurfaceAst.Ident(name) =>
      makeExpr(expr.node, CoreAst.Ident(lowerName(name))),
    SurfaceAst.Hole(hole) => makeExpr(expr.node, CoreAst.Hole(lowerHole(hole))),
    SurfaceAst.Paren(inner) => lowerExpr(inner),
    SurfaceAst.Tuple(exprs) =>
      makeExpr(expr.node, CoreAst.Tuple(List.map(lowerExpr, exprs))),
    SurfaceAst.RecordLit(items) =>
      makeExpr(expr.node, CoreAst.RecordLit(List.map(lowerRecordItem, items))),
    SurfaceAst.Seq(items) => lowerSeqExpr(expr.node, items),
    SurfaceAst.Apply(callee, arg) =>
      makeExpr(expr.node, CoreAst.Apply(lowerExpr(callee), lowerExpr(arg))),
    SurfaceAst.If(cond, thenExpr, elseOpt) => {
      let loweredElse = match (elseOpt) {
        None => None,
        Some(e) => Some(lowerExpr(e)),
      }
      makeExpr(
        expr.node,
        CoreAst.If(lowerExpr(cond), lowerExpr(thenExpr), loweredElse)
      )
    },
    SurfaceAst.Let(binding, body) => {
      let loweredBody = lowerExpr(body)
      let coreBinding = lowerLetBinding(binding)
      makeExpr(expr.node, CoreAst.Let(coreBinding, loweredBody))
    },
    SurfaceAst.Fn(fnExpr) =>
      makeExpr(expr.node, CoreAst.Fn(lowerFnExpr(fnExpr))),
    SurfaceAst.Match(m) => lowerMatchExpr(expr.node, m),
    SurfaceAst.Block(block) => lowerExpr(block.body),
    SurfaceAst.Assign(asg) => lowerAssignExpr(expr.node, asg),
    SurfaceAst.Postfix(pf) => lowerPostfix(expr.node, pf),
    SurfaceAst.InfixChain(chain) => {
      match (chain) {
        { first, rest: [(op, rhs)] } when op.text == "=>" =>
          lowerArrow(expr.node, first, rhs),
        { first, rest: [(op, rhs)] } when op.text == ":>" =>
          lowerPipe(expr.node, first, rhs),
        _ => {
          let loweredFirst = lowerExpr(chain.first)
          let rec fold = (
            acc: CoreAst.Expr,
            rest: List<(SurfaceAst.Name, SurfaceAst.Expr)>,
          ) => {
            match (rest) {
              [] => acc,
              [(op, rhs), ...tail] => {
                let opExpr = makeExpr(op.node, CoreAst.Ident(lowerName(op)))
                let rhsExpr = lowerExpr(rhs)
                let argExpr = makeTupleExpr(expr.node, [acc, rhsExpr])
                let applied = makeExpr(
                  expr.node,
                  CoreAst.Apply(opExpr, argExpr)
                )
                fold(applied, tail)
              },
            }
          }
          fold(loweredFirst, chain.rest)
        },
      }
    },
    _ =>
      Error.createPanicError(
        Error.Lowering,
        expr.node.span,
        "Unsupported surface expression in lowering",
        [],
        severity=Error.SError
      ),
  }
}

let lowerDecl = (d: SurfaceAst.Decl) => match (d) {
  SurfaceAst.LetDecl(ld) =>
    CoreAst.LetDecl(
      {
        node: lowerNode(ld.node),
        bindings: List.map(lowerLetBinding, ld.bindings),
      },
    ),
  SurfaceAst.TypeDecl(td) =>
    CoreAst.TypeDecl(
      {
        node: lowerNode(td.node),
        name: lowerName(td.name),
        infection: mapOption(td.infection, lowerName),
        typeParams: List.map(lowerName, td.typeParams),
        body: match (td.body) {
          SurfaceAst.Alias(t) => CoreAst.Alias(lowerTypeExpr(t)),
          SurfaceAst.Variant(cases, _) =>
            CoreAst.Variant(
              List.map(
                ((name, payload, annotation)) =>
                  (
                    lowerName(name),
                    mapOption(payload, lowerTypeExpr),
                    annotation,
                  ),
                cases
              ),
            ),
        },
      },
    ),
  SurfaceAst.RecordDecl(rd) =>
    CoreAst.RecordDecl(
      {
        node: lowerNode(rd.node),
        name: lowerName(rd.name),
        typeParams: List.map(lowerName, rd.typeParams),
        fields: List.map(
          ((name, t)) => (lowerName(name), lowerTypeExpr(t)),
          rd.fields
        ),
      },
    ),
  SurfaceAst.InfixDecl(id) =>
    CoreAst.InfixDecl(
      {
        node: lowerNode(id.node),
        name: lowerName(id.name),
        precedence: id.precedence,
        associativity: match (id.associativity) {
          SurfaceAst.Left => CoreAst.Left,
          SurfaceAst.Right => CoreAst.Right,
          SurfaceAst.NonAssoc => CoreAst.NonAssoc,
        },
      },
    ),
  SurfaceAst.PrefixDecl(pd) =>
    CoreAst.PrefixDecl({ node: lowerNode(pd.node), name: lowerName(pd.name) }),
}

let lowerDeclGroup = (dg: SurfaceAst.DeclGroup) =>
  {
    node: lowerNode(dg.node),
    exported: dg.exported,
    kind: match (dg.kind) {
      SurfaceAst.LetGroup(mods) => CoreAst.LetGroup(match (mods) {
        SurfaceAst.Plain => CoreAst.Plain,
        SurfaceAst.Rec => CoreAst.Rec,
        SurfaceAst.Mut => CoreAst.Mut,
      }),
      SurfaceAst.TypeGroup(mods) => CoreAst.TypeGroup(match (mods) {
        SurfaceAst.Plain => CoreAst.Plain,
        SurfaceAst.Rec => CoreAst.Rec,
      }),
      SurfaceAst.RecordGroup(mods) => CoreAst.RecordGroup(match (mods) {
        SurfaceAst.Plain => CoreAst.Plain,
        SurfaceAst.Rec => CoreAst.Rec,
      }),
      SurfaceAst.OpGroup => CoreAst.OpGroup,
      SurfaceAst.RuleGroup(kind) => CoreAst.RuleGroup(match (kind) {
        SurfaceAst.Domain => CoreAst.Domain,
        SurfaceAst.Policy => CoreAst.Policy,
        SurfaceAst.Op => CoreAst.Op,
        SurfaceAst.Annotate => CoreAst.Annotate,
      }),
    },
    decls: List.map(lowerDecl, dg.decls),
  }: CoreAst.DeclGroup

let lowerTopItem = (ti: SurfaceAst.TopItem) => match (ti) {
  SurfaceAst.DeclGroup(dg) => Some(CoreAst.DeclGroup(lowerDeclGroup(dg))),
  SurfaceAst.Import(id) =>
    Some(
      CoreAst.Import(
        {
          node: lowerNode(id.node),
          modulePath: id.modulePath,
          alias: mapOption(id.alias, lowerName),
          names: List.map((item: SurfaceAst.ImportName) => {
            {
              name: lowerName(item.name),
              alias: mapOption(item.alias, lowerName),
            }: CoreAst.ImportName
          }, id.names),
        },
      ),
    ),
  SurfaceAst.Reexport(rd) =>
    Some(
      CoreAst.Reexport({ node: lowerNode(rd.node), modulePath: rd.modulePath }),
    ),
  SurfaceAst.Export(exp) =>
    Some(CoreAst.Export({ node: lowerNode(exp.node), })),
  SurfaceAst.Directive(dir) =>
    Some(
      CoreAst.Directive(
        { name: lowerName(dir.name), args: List.map(lowerExpr, dir.args) },
      ),
    ),
  SurfaceAst.Mark(_) | SurfaceAst.Trivia(_) => None,
}

provide let lowerProgram = (program: SurfaceAst.Program) => {
  let items = List.filterMap(lowerTopItem, program.items)
  { items, }: CoreAst.Program
}
