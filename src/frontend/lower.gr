module Lower

from "../core/ast.gr" include Ast
use Ast.*
from "list" include List
from "runtime/unsafe/panic" include Panic
use Panic.{ panic }
from "../core/error.gr" include Error

// Convert block of case expressions to bundle
let rec blockToBundle = (block: Ast.Block) => {
  let items = List.map((expr: Ast.Expr) => {
    match (expr.kind: Ast.ExprKind) {
      Ast.InfixChain({ first: patExpr, rest: [(op, bodyExpr)] }) when op.text
        == "=>" => {
        let pat = exprToPattern(patExpr)
        let body = match (bodyExpr.kind: Ast.ExprKind) {
          Ast.Block(b) => b,
          _ =>
            Error.createError(
              Error.Lowering,
              bodyExpr.node.span,
              "Case body must be a block",
              []
            ),
        }
        let caseKind = Ast.Case(pat, None, body)
        {
          node: { id: expr.node.id, span: expr.node.span },
          kind: caseKind,
          attach: { leading: [], trailing: [], dangling: [] },
        }: Ast.BundleItem
      },
      _ =>
        Error.createError(
          Error.Lowering,
          expr.node.span,
          "Expected case pattern => block",
          []
        ),
    }
  }, block.result)
  let bundleLit = { node: { id: block.node.id, span: block.node.span }, items }
  {
    node: { id: block.node.id, span: block.node.span },
    kind: Ast.Literal(bundleLit),
    attach: { leading: [], trailing: [], dangling: [] },
  }: Ast.BundleExpr
}

// Convert expr to pattern (for case pats)
and exprToPattern = (expr: Ast.Expr) => {
  match (expr.kind) {
    Ast.Ident({ _, text }) when text == "_" => { //TODO: missing node
      {
        node: expr.node,
        kind: Ast.Wildcard,
        attach: { leading: [], trailing: [], dangling: [] },
      }
    },
    Ast.Ident({ _, text }) => { //TODO: missing node
      let nameNode = { node: { id: expr.node.id, span: expr.node.span }, text }
      {
        node: expr.node,
        kind: Ast.Pin(nameNode),
        attach: { leading: [], trailing: [], dangling: [] },
      }
    },
    Ast.Lit(lit) => {
      {
        node: expr.node,
        kind: Ast.Lit(lit),
        attach: { leading: [], trailing: [], dangling: [] },
      }
    },
    // Add more as needed
    _ =>
      Error.createError(
        Error.Lowering,
        expr.node.span,
        "Unsupported pattern in case",
        []
      ),
  }
}

// Transform => infix expressions into lambdas
let rec lowerExpr = (expr: Ast.Expr) => {
  match (expr.kind: Ast.ExprKind) {
    Ast.InfixChain(chain) => {
      match (chain) {
        {
          first: { node: _, kind: Ast.MatchApply(ma), attach: _ },
          rest: [(op, body)],
        } when op.text == "=>" => {
          let bundle = match (body.kind: Ast.ExprKind) {
            Ast.Bundle(b) => b,
            Ast.Block(b) => blockToBundle(b),
            _ =>
              Error.createError(
                Error.Lowering,
                body.node.span,
                "Match arrow expects bundle or block of cases",
                [
                  Error.Received("non-bundle/block expression"),
                  Error.Note(
                    "match => must be followed by a bundle or block of cases",
                  ),
                ]
              ),
          }
          let matchApply = Ast.MatchApply({ ...ma, bundle })
          { ...expr, kind: Ast.Lambda(None, { ...expr, kind: matchApply }) }
        },
        { first, rest: [(op, body)] } when op.text == "=>" => {
          // Normal param => body
          let param = first
          let pattern = extractParam(param)
          let loweredBody = lowerExpr(body)
          let lambda = match (pattern) {
            Some(p) => Ast.Lambda(Some(p), loweredBody),
            None =>
              Error.createError(
                Error.Lowering,
                expr.node.span,
                "Unsupported parameter",
                [
                  Error.Note(
                    "lambda parameter pattern not yet supported in lowering",
                  ),
                  Error.Hint("this AST node type needs to be implemented"),
                ]
              ),
          }
          { ...expr, kind: lambda }
        },
        _ => {
          // General infix chain
          let loweredFirst = lowerExpr(chain.first)
          let loweredRest = List.map(
            ((op, e)) => (op, lowerExpr(e)),
            chain.rest
          )
          {
            ...expr,
            kind: Ast.InfixChain({ first: loweredFirst, rest: loweredRest }),
          }
        },
      }
    },
    Ast.Block(inner) => {
      {
        ...expr,
        kind: Ast.Block({ ...inner, result: List.map(lowerExpr, inner.result) }),
      }
    },
    Ast.Paren(inner) => {
      { ...expr, kind: Ast.Paren(lowerExpr(inner)) }
    },
    Ast.Tuple(exprs) => {
      { ...expr, kind: Ast.Tuple(List.map(lowerExpr, exprs)) }
    },
    Ast.Lambda(optPat, body) => {
      { ...expr, kind: Ast.Lambda(optPat, lowerExpr(body)) }
    },
    // Other cases remain unchanged
    _ => expr,
  }
}
and extractParam = (param: Ast.Expr) => {
  match (param.kind) {
    Ast.Ident(name) =>
      Some({ node: param.node, kind: Var(name), attach: param.attach }),
    Ast.Paren(inner) => extractParam(inner), // Recursively extract from parenthesized expression
    Ast.Tuple(exprs) => {
      // Convert tuple expression to tuple pattern
      // Each element of the tuple should be convertible to a pattern
      let rec convertAll = (es: List<Ast.Expr>) => {
        match (es) {
          [] => Some([]),
          [h, ...t] => {
            match (extractParam(h)) {
              Some(pat) => match (convertAll(t)) {
                Some(pats) => Some([pat, ...pats]),
                None => None,
              },
              None => None,
            }
          },
        }
      }
      match (convertAll(exprs)) {
        Some(patterns) =>
          Some(
            { node: param.node, kind: Tuple(patterns), attach: param.attach },
          ),
        None => None,
      }
    },
    _ => None, // Other parameter patterns not supported yet
  }
}
let lowerBinding = (binding: Ast.LetBinding) => {
  { ...binding, value: lowerExpr(binding.value) }
}

let lowerLetDecl = (ld: Ast.LetDecl) => {
  { ...ld, bindings: List.map(lowerBinding, ld.bindings) }
}

let lowerDecl = (d: Ast.Decl) => {
  match (d) {
    Ast.LetDecl(ld) => Ast.LetDecl(lowerLetDecl(ld)),
    _ => d,
  }
}

let lowerDeclGroup = (dg: Ast.DeclGroup) => {
  { ...dg, decls: List.map(lowerDecl, dg.decls) }
}

let lowerTopItem = (ti: Ast.TopItem) => {
  match (ti) {
    Ast.DeclGroup(dg) => Ast.DeclGroup(lowerDeclGroup(dg)),
    _ => ti,
  }
}

provide let lowerProgram = (program: Ast.Program) => {
  { ...program, items: List.map(lowerTopItem, program.items) }
}
