module Lower

from "../core/ast.gr" include Ast
use Ast.*
from "list" include List
from "runtime/unsafe/panic" include Panic
use Panic.{ panic }
from "../core/error.gr" include Error

// Transform => infix expressions into lambdas
let rec lowerExpr = (expr: Ast.Expr) => {
  match (expr.kind) {
    Ast.InfixChain(chain) => {
      match (chain) {
        {
          first: { node: _, kind: Ast.MatchApply(ma), attach: _ },
          rest: [(op, body)],
        } when op.text == "=>" => {
          let bundle = match (body.kind) {
            Ast.Bundle(b) => b,
            _ => Error.createError(Error.Lowering, body.node.span, "Match arrow expects bundle", [Error.Received("non-bundle expression"), Error.Note("match => must be followed by a bundle of cases")]),
          }
          let matchApply = Ast.MatchApply({ ...ma, bundle })
          { ...expr, kind: Ast.Lambda(None, { ...expr, kind: matchApply }) }
        },
        { first, rest: [(op, body)] } when op.text == "=>" => {
          // Normal param => body
          let param = first
          let pattern = extractParam(param)
          let loweredBody = lowerExpr(body)
          let lambda = match (pattern) {
            Some(p) => Ast.Lambda(Some(p), loweredBody),
            None => Error.createError(Error.Lowering, expr.node.span, "Unsupported parameter", [Error.Note("lambda parameter pattern not yet supported in lowering"), Error.Hint("this AST node type needs to be implemented")]),
          }
          { ...expr, kind: lambda }
        },
        _ => {
          // General infix chain
          let loweredFirst = lowerExpr(chain.first)
          let loweredRest = List.map(
            ((op, e)) => (op, lowerExpr(e)),
            chain.rest
          )
          {
            ...expr,
            kind: Ast.InfixChain({ first: loweredFirst, rest: loweredRest }),
          }
        },
      }
    },
    Ast.Block(inner) => {
      {
        ...expr,
        kind: Ast.Block({ ...inner, result: List.map(lowerExpr, inner.result) }),
      }
    },
    Ast.Paren(inner) => {
      { ...expr, kind: Ast.Paren(lowerExpr(inner)) }
    },
    Ast.Tuple(exprs) => {
      { ...expr, kind: Ast.Tuple(List.map(lowerExpr, exprs)) }
    },
    Ast.Lambda(optPat, body) => {
      { ...expr, kind: Ast.Lambda(optPat, lowerExpr(body)) }
    },
    // Other cases remain unchanged
    _ => expr,
  }
}
and extractParam = (param: Ast.Expr) => {
  match (param.kind) {
    Ast.Ident(name) =>
      Some({ node: param.node, kind: Var(name), attach: param.attach }),
    Ast.Paren(inner) => extractParam(inner), // Recursively extract from parenthesized expression
    Ast.Tuple(exprs) => {
      // Convert tuple expression to tuple pattern
      // Each element of the tuple should be convertible to a pattern
      let rec convertAll = (es: List<Ast.Expr>) => {
        match (es) {
          [] => Some([]),
          [h, ...t] => {
            match (extractParam(h)) {
              Some(pat) => match (convertAll(t)) {
                Some(pats) => Some([pat, ...pats]),
                None => None,
              },
              None => None,
            }
          },
        }
      }
      match (convertAll(exprs)) {
        Some(patterns) => Some({ node: param.node, kind: Tuple(patterns), attach: param.attach }),
        None => None,
      }
    },
    _ => None, // Other parameter patterns not supported yet
  }
}
let lowerBinding = (binding: Ast.LetBinding) => {
  { ...binding, value: lowerExpr(binding.value) }
}

let lowerLetDecl = (ld: Ast.LetDecl) => {
  { ...ld, bindings: List.map(lowerBinding, ld.bindings) }
}

let lowerDecl = (d: Ast.Decl) => {
  match (d) {
    Ast.LetDecl(ld) => Ast.LetDecl(lowerLetDecl(ld)),
    _ => d,
  }
}

let lowerDeclGroup = (dg: Ast.DeclGroup) => {
  { ...dg, decls: List.map(lowerDecl, dg.decls) }
}

let lowerTopItem = (ti: Ast.TopItem) => {
  match (ti) {
    Ast.DeclGroup(dg) => Ast.DeclGroup(lowerDeclGroup(dg)),
    _ => ti,
  }
}

provide let lowerProgram = (program: Ast.Program) => {
  { ...program, items: List.map(lowerTopItem, program.items) }
}
