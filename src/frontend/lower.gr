module Lower

from "../core/ast.gr" include Ast
use Ast.*
from "list" include List
from "../core/error.gr" include Error

let emptyAttach = { leading: [], trailing: [], dangling: [] }

let makeUnitExpr = (node: Ast.Node) => {
  { node, kind: Ast.Lit(Ast.Unit), attach: emptyAttach }: Ast.Expr
}

let makeTupleExpr = (node: Ast.Node, exprs: List<Ast.Expr>) => {
  { node, kind: Ast.Tuple(exprs), attach: emptyAttach }: Ast.Expr
}

let rec exprToPattern = (expr: Ast.Expr) => {
  match (expr.kind) {
    Ast.Ident({ _, text }) when text == "_" => {
      {
        node: expr.node,
        kind: Ast.Wildcard,
        attach: expr.attach,
      }: Ast.Pattern
    },
    Ast.Ident(name) => {
      {
        node: expr.node,
        kind: Ast.Var(name),
        attach: expr.attach,
      }: Ast.Pattern
    },
    Ast.Paren(inner) => exprToPattern(inner),
    Ast.Tuple(exprs) => {
      let rec convert = (es: List<Ast.Expr>) => {
        match (es) {
          [] => [],
          [head, ...tail] => [exprToPattern(head), ...convert(tail)],
        }
      }
      {
        node: expr.node,
        kind: Ast.Tuple(convert(exprs)),
        attach: expr.attach,
      }: Ast.Pattern
    },
    Ast.Lit(lit) => {
      { node: expr.node, kind: Ast.Lit(lit), attach: expr.attach }: Ast.Pattern
    },
    _ =>
      Error.createError(
        Error.Lowering,
        expr.node.span,
        "Unsupported pattern in => clause",
        []
      ),
  }
}

let exprToBlock = (expr: Ast.Expr) => {
  match (expr.kind) {
    Ast.Block(b) => b,
    _ => ({ node: expr.node, items: [], result: [expr] }: Ast.Block),
  }
}

let rec lowerFnClause = (clause: Ast.FnClause) => {
  let guard = match (clause.guard) {
    None => None,
    Some(g) => Some(lowerExpr(g)),
  }
  let bodyExpr = {
    node: clause.body.node,
    kind: Ast.Block(clause.body),
    attach: emptyAttach,
  }: Ast.Expr
  let loweredBodyExpr: Ast.Expr = lowerExpr(bodyExpr)
  let loweredBody = match (loweredBodyExpr.kind: Ast.ExprKind) {
    Ast.Block(b) => b,
    _ =>
      Error.createError(
        Error.Lowering,
        clause.body.node.span,
        "internal lowering error: expected block body",
        []
      ),
  }
  { ...clause, guard, body: loweredBody }
}

and lowerFnItem = (item: Ast.FnItem) => {
  match (item.kind) {
    Ast.Clause(clause) => { ...item, kind: Ast.Clause(lowerFnClause(clause)) },
    Ast.Hole(_) | Ast.Include(_) | Ast.Trivia(_) => item,
  }
}

and lowerFnExpr = (fnExpr: Ast.FnExpr) => {
  { ...fnExpr, items: List.map(lowerFnItem, fnExpr.items) }
}

and lowerMatchExpr = (expr: Ast.Expr, m: Ast.MatchExpr) => {
  let loweredBundle = lowerFnExpr(m.bundle)
  let bundleExpr: Ast.Expr = {
    node: m.bundle.node,
    kind: Ast.Fn(loweredBundle),
    attach: m.attach,
  }
  match ((m.scrutinee, m.arrowSugar)) {
    (None, false) => {
      { ...expr, kind: Ast.Fn(loweredBundle) }
    },
    (Some(scrutinee), false) => {
      let loweredScrutinee = lowerExpr(scrutinee)
      { ...expr, kind: Ast.Apply(bundleExpr, loweredScrutinee) }
    },
    (Some(scrutinee), true) => {
      let loweredScrutinee = lowerExpr(scrutinee)
      let param = exprToPattern(loweredScrutinee)
      let innerApply: Ast.Expr = {
        node: expr.node,
        kind: Ast.Apply(bundleExpr, loweredScrutinee),
        attach: expr.attach,
      }
      let body: Ast.Block = {
        node: expr.node,
        items: [],
        result: [innerApply],
      }
      let clause: Ast.FnClause = {
        node: expr.node,
        param,
        guard: None,
        body,
        attach: emptyAttach,
      }
      let item: Ast.FnItem = {
        node: expr.node,
        kind: Ast.Clause(clause),
        attach: emptyAttach,
      }
      let fnExpr: Ast.FnExpr = { node: expr.node, items: [item], attach: expr.attach }
      { ...expr, kind: Ast.Fn(fnExpr) }
    },
    _ =>
      Error.createError(
        Error.Lowering,
        expr.node.span,
        "invalid match arrow shape",
        []
      ),
  }
}

and normalizeCallArgs = (node: Ast.Node, args: List<Ast.Expr>) => {
  match (args) {
    [] => makeUnitExpr(node),
    [only] => only,
    _ => makeTupleExpr(node, args),
  }
}

and prependArg = (node: Ast.Node, firstArg: Ast.Expr, argExpr: Ast.Expr) => {
  match (argExpr.kind) {
    Ast.Tuple(items) => makeTupleExpr(node, [firstArg, ...items]),
    _ => makeTupleExpr(node, [firstArg, argExpr]),
  }
}

and lowerCallOnlyPostfix = (expr: Ast.Expr, pf: Ast.Postfix) => {
  let loweredTarget = lowerExpr(pf.target)
  let rec foldCalls = (currentExpr: Ast.Expr, segments: List<Ast.PostfixSegment>) => {
    match (segments) {
      [] => currentExpr,
      [Ast.Call(args), ...rest] => {
        let loweredArgs = List.map(lowerExpr, args)
        let argExpr = normalizeCallArgs(currentExpr.node, loweredArgs)
        let applied = { ...currentExpr, kind: Ast.Apply(currentExpr, argExpr) }
        foldCalls(applied, rest)
      },
      _ =>
        Error.createError(
          Error.Lowering,
          expr.node.span,
          "internal lowering error: non-call segment in call-only fold",
          []
        ),
    }
  }
  foldCalls(loweredTarget, pf.segments)
}

and lowerPostfix = (expr: Ast.Expr, pf: Ast.Postfix) => {
  let isCallOnly = List.every(
    seg =>
      match (seg) {
        Ast.Call(_) => true,
        _ => false,
      },
    pf.segments
  )
  if (isCallOnly) {
    lowerCallOnlyPostfix(expr, pf)
  } else {
    let loweredTarget = lowerExpr(pf.target)
    let loweredSegments = List.map(seg =>
      match (seg) {
        Ast.Call(args) => Ast.Call(List.map(lowerExpr, args)),
        Ast.Index(ix) => Ast.Index(lowerExpr(ix)),
        Ast.Project(name) => Ast.Project(name),
      },
      pf.segments
    )
    { ...expr, kind: Ast.Postfix({ target: loweredTarget, segments: loweredSegments }) }
  }
}

and lowerArrow = (expr: Ast.Expr, lhs: Ast.Expr, rhs: Ast.Expr) => {
  let param = exprToPattern(lhs)
  let loweredRhs = lowerExpr(rhs)
  let body = exprToBlock(loweredRhs)
  let clause: Ast.FnClause = {
    node: expr.node,
    param,
    guard: None,
    body,
    attach: emptyAttach,
  }
  let item: Ast.FnItem = {
    node: expr.node,
    kind: Ast.Clause(clause),
    attach: emptyAttach,
  }
  let fnExpr: Ast.FnExpr = { node: expr.node, items: [item], attach: expr.attach }
  { ...expr, kind: Ast.Fn(fnExpr) }
}

and lowerPipe = (expr: Ast.Expr, lhs: Ast.Expr, rhs: Ast.Expr) => {
  let loweredLhs = lowerExpr(lhs)
  let loweredRhs = lowerExpr(rhs)
  match (loweredRhs.kind) {
    Ast.Apply(callee, arg) => {
      let combinedArg = prependArg(expr.node, loweredLhs, arg)
      { ...expr, kind: Ast.Apply(callee, combinedArg) }
    },
    _ => { ...expr, kind: Ast.Apply(loweredRhs, loweredLhs) },
  }
}

and lowerExpr = (expr: Ast.Expr) => {
  match (expr.kind: Ast.ExprKind) {
    Ast.InfixChain(chain) => {
      match (chain) {
        { first, rest: [(op, rhs)] } when op.text == "=>" =>
          lowerArrow(expr, first, rhs),
        { first, rest: [(op, rhs)] } when op.text == ":>" =>
          lowerPipe(expr, first, rhs),
        _ => {
          let loweredFirst = lowerExpr(chain.first)
          let loweredRest = List.map(((op, e)) => (op, lowerExpr(e)), chain.rest)
          { ...expr, kind: Ast.InfixChain({ first: loweredFirst, rest: loweredRest }) }
        },
      }
    },
    Ast.Postfix(pf) => lowerPostfix(expr, pf),
    Ast.Block(inner) => {
      let loweredItems = List.map(item =>
        match (item) {
          Ast.Stmt(stmt) => {
            let loweredStmt = match (stmt.kind) {
              Ast.Expr(e) => { ...stmt, kind: Ast.Expr(lowerExpr(e)) },
              Ast.Assign(asg) => {
                {
                  ...stmt,
                  kind: Ast.Assign({
                    target: lowerExpr(asg.target),
                    value: lowerExpr(asg.value),
                  }),
                }
              },
              Ast.Let(binding) => {
                let loweredBinding = { ...binding, value: lowerExpr(binding.value) }
                { ...stmt, kind: Ast.Let(loweredBinding) }
              },
            }
            Ast.Stmt(loweredStmt)
          },
          _ => item,
        },
        inner.items
      )
      let loweredResult = List.map(lowerExpr, inner.result)
      { ...expr, kind: Ast.Block({ ...inner, items: loweredItems, result: loweredResult }) }
    },
    Ast.Paren(inner) => { ...expr, kind: Ast.Paren(lowerExpr(inner)) },
    Ast.Tuple(exprs) => { ...expr, kind: Ast.Tuple(List.map(lowerExpr, exprs)) },
    Ast.RecordLit(items) => {
      let loweredItems = List.map(item =>
        match (item) {
          Ast.Field(name, value) => Ast.Field(name, lowerExpr(value)),
          Ast.Spread(value) => Ast.Spread(lowerExpr(value)),
        },
        items
      )
      { ...expr, kind: Ast.RecordLit(loweredItems) }
    },
    Ast.If(cond, thenExpr, elseOpt) => {
      let loweredElse = match (elseOpt) {
        None => None,
        Some(e) => Some(lowerExpr(e)),
      }
      {
        ...expr,
        kind: Ast.If(lowerExpr(cond), lowerExpr(thenExpr), loweredElse),
      }
    },
    Ast.Apply(callee, arg) => {
      { ...expr, kind: Ast.Apply(lowerExpr(callee), lowerExpr(arg)) }
    },
    Ast.Match(m) => lowerMatchExpr(expr, m),
    Ast.Fn(fnExpr) => { ...expr, kind: Ast.Fn(lowerFnExpr(fnExpr)) },
    _ => expr,
  }
}

let lowerBinding = (binding: Ast.LetBinding) => {
  { ...binding, value: lowerExpr(binding.value) }
}

let lowerLetDecl = (ld: Ast.LetDecl) => {
  { ...ld, bindings: List.map(lowerBinding, ld.bindings) }
}

let lowerDecl = (d: Ast.Decl) => {
  match (d) {
    Ast.LetDecl(ld) => Ast.LetDecl(lowerLetDecl(ld)),
    _ => d,
  }
}

let lowerDeclGroup = (dg: Ast.DeclGroup) => {
  { ...dg, decls: List.map(lowerDecl, dg.decls) }
}

let lowerTopItem = (ti: Ast.TopItem) => {
  match (ti) {
    Ast.DeclGroup(dg) => Ast.DeclGroup(lowerDeclGroup(dg)),
    _ => ti,
  }
}

provide let lowerProgram = (program: Ast.Program) => {
  { ...program, items: List.map(lowerTopItem, program.items), core: true }
}
